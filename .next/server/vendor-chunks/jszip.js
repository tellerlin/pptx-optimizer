"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jszip";
exports.ids = ["vendor-chunks/jszip"];
exports.modules = {

/***/ "(ssr)/./node_modules/jszip/lib/base64.js":
/*!******************************************!*\
  !*** ./node_modules/jszip/lib/base64.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\n// private property\nvar _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n// public method for encoding\nexports.encode = function(input) {\n    var output = [];\n    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n    var i = 0, len = input.length, remainingBytes = len;\n    var isArray = utils.getTypeOf(input) !== \"string\";\n    while(i < input.length){\n        remainingBytes = len - i;\n        if (!isArray) {\n            chr1 = input.charCodeAt(i++);\n            chr2 = i < len ? input.charCodeAt(i++) : 0;\n            chr3 = i < len ? input.charCodeAt(i++) : 0;\n        } else {\n            chr1 = input[i++];\n            chr2 = i < len ? input[i++] : 0;\n            chr3 = i < len ? input[i++] : 0;\n        }\n        enc1 = chr1 >> 2;\n        enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;\n        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;\n        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));\n    }\n    return output.join(\"\");\n};\n// public method for decoding\nexports.decode = function(input) {\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0, resultIndex = 0;\n    var dataUrlPrefix = \"data:\";\n    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {\n        // This is a common error: people give a data url\n        // (data:image/png;base64,iVBOR...) with a {base64: true} and\n        // wonders why things don't work.\n        // We can detect that the string input looks like a data url but we\n        // *can't* be sure it is one: removing everything up to the comma would\n        // be too dangerous.\n        throw new Error(\"Invalid base64 input, it looks like a data url.\");\n    }\n    input = input.replace(/[^A-Za-z0-9+/=]/g, \"\");\n    var totalLength = input.length * 3 / 4;\n    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if (totalLength % 1 !== 0) {\n        // totalLength is not an integer, the length does not match a valid\n        // base64 content. That can happen if:\n        // - the input is not a base64 content\n        // - the input is *almost* a base64 content, with a extra chars at the\n        //   beginning or at the end\n        // - the input uses a base64 variant (base64url for example)\n        throw new Error(\"Invalid base64 input, bad content length.\");\n    }\n    var output;\n    if (support.uint8array) {\n        output = new Uint8Array(totalLength | 0);\n    } else {\n        output = new Array(totalLength | 0);\n    }\n    while(i < input.length){\n        enc1 = _keyStr.indexOf(input.charAt(i++));\n        enc2 = _keyStr.indexOf(input.charAt(i++));\n        enc3 = _keyStr.indexOf(input.charAt(i++));\n        enc4 = _keyStr.indexOf(input.charAt(i++));\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n        output[resultIndex++] = chr1;\n        if (enc3 !== 64) {\n            output[resultIndex++] = chr2;\n        }\n        if (enc4 !== 64) {\n            output[resultIndex++] = chr3;\n        }\n    }\n    return output;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDLHdEQUFTO0FBQzdCLElBQUlDLFVBQVVELG1CQUFPQSxDQUFDLDREQUFXO0FBQ2pDLG1CQUFtQjtBQUNuQixJQUFJRSxVQUFVO0FBR2QsNkJBQTZCO0FBQzdCQyxjQUFjLEdBQUcsU0FBU0UsS0FBSztJQUMzQixJQUFJQyxTQUFTLEVBQUU7SUFDZixJQUFJQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQztJQUN4QyxJQUFJQyxJQUFJLEdBQUdDLE1BQU1WLE1BQU1XLE1BQU0sRUFBRUMsaUJBQWlCRjtJQUVoRCxJQUFJRyxVQUFVbkIsTUFBTW9CLFNBQVMsQ0FBQ2QsV0FBVztJQUN6QyxNQUFPUyxJQUFJVCxNQUFNVyxNQUFNLENBQUU7UUFDckJDLGlCQUFpQkYsTUFBTUQ7UUFFdkIsSUFBSSxDQUFDSSxTQUFTO1lBQ1ZYLE9BQU9GLE1BQU1lLFVBQVUsQ0FBQ047WUFDeEJOLE9BQU9NLElBQUlDLE1BQU1WLE1BQU1lLFVBQVUsQ0FBQ04sT0FBTztZQUN6Q0wsT0FBT0ssSUFBSUMsTUFBTVYsTUFBTWUsVUFBVSxDQUFDTixPQUFPO1FBQzdDLE9BQU87WUFDSFAsT0FBT0YsS0FBSyxDQUFDUyxJQUFJO1lBQ2pCTixPQUFPTSxJQUFJQyxNQUFNVixLQUFLLENBQUNTLElBQUksR0FBRztZQUM5QkwsT0FBT0ssSUFBSUMsTUFBTVYsS0FBSyxDQUFDUyxJQUFJLEdBQUc7UUFDbEM7UUFFQUosT0FBT0gsUUFBUTtRQUNmSSxPQUFPLENBQUVKLE9BQU8sTUFBTSxJQUFNQyxRQUFRO1FBQ3BDSSxPQUFPSyxpQkFBaUIsSUFBSyxDQUFFVCxPQUFPLEVBQUMsS0FBTSxJQUFNQyxRQUFRLElBQU07UUFDakVJLE9BQU9JLGlCQUFpQixJQUFLUixPQUFPLEtBQU07UUFFMUNILE9BQU9lLElBQUksQ0FBQ25CLFFBQVFvQixNQUFNLENBQUNaLFFBQVFSLFFBQVFvQixNQUFNLENBQUNYLFFBQVFULFFBQVFvQixNQUFNLENBQUNWLFFBQVFWLFFBQVFvQixNQUFNLENBQUNUO0lBRXBHO0lBRUEsT0FBT1AsT0FBT2lCLElBQUksQ0FBQztBQUN2QjtBQUVBLDZCQUE2QjtBQUM3QnBCLGNBQWMsR0FBRyxTQUFTRSxLQUFLO0lBQzNCLElBQUlFLE1BQU1DLE1BQU1DO0lBQ2hCLElBQUlDLE1BQU1DLE1BQU1DLE1BQU1DO0lBQ3RCLElBQUlDLElBQUksR0FBR1csY0FBYztJQUV6QixJQUFJQyxnQkFBZ0I7SUFFcEIsSUFBSXJCLE1BQU1zQixNQUFNLENBQUMsR0FBR0QsY0FBY1YsTUFBTSxNQUFNVSxlQUFlO1FBQ3pELGlEQUFpRDtRQUNqRCw2REFBNkQ7UUFDN0QsaUNBQWlDO1FBQ2pDLG1FQUFtRTtRQUNuRSx1RUFBdUU7UUFDdkUsb0JBQW9CO1FBQ3BCLE1BQU0sSUFBSUUsTUFBTTtJQUNwQjtJQUVBdkIsUUFBUUEsTUFBTXdCLE9BQU8sQ0FBQyxvQkFBb0I7SUFFMUMsSUFBSUMsY0FBY3pCLE1BQU1XLE1BQU0sR0FBRyxJQUFJO0lBQ3JDLElBQUdYLE1BQU1pQixNQUFNLENBQUNqQixNQUFNVyxNQUFNLEdBQUcsT0FBT2QsUUFBUW9CLE1BQU0sQ0FBQyxLQUFLO1FBQ3REUTtJQUNKO0lBQ0EsSUFBR3pCLE1BQU1pQixNQUFNLENBQUNqQixNQUFNVyxNQUFNLEdBQUcsT0FBT2QsUUFBUW9CLE1BQU0sQ0FBQyxLQUFLO1FBQ3REUTtJQUNKO0lBQ0EsSUFBSUEsY0FBYyxNQUFNLEdBQUc7UUFDdkIsbUVBQW1FO1FBQ25FLHNDQUFzQztRQUN0QyxzQ0FBc0M7UUFDdEMsc0VBQXNFO1FBQ3RFLDRCQUE0QjtRQUM1Qiw0REFBNEQ7UUFDNUQsTUFBTSxJQUFJRixNQUFNO0lBQ3BCO0lBQ0EsSUFBSXRCO0lBQ0osSUFBSUwsUUFBUThCLFVBQVUsRUFBRTtRQUNwQnpCLFNBQVMsSUFBSTBCLFdBQVdGLGNBQVk7SUFDeEMsT0FBTztRQUNIeEIsU0FBUyxJQUFJMkIsTUFBTUgsY0FBWTtJQUNuQztJQUVBLE1BQU9oQixJQUFJVCxNQUFNVyxNQUFNLENBQUU7UUFFckJOLE9BQU9SLFFBQVFnQyxPQUFPLENBQUM3QixNQUFNaUIsTUFBTSxDQUFDUjtRQUNwQ0gsT0FBT1QsUUFBUWdDLE9BQU8sQ0FBQzdCLE1BQU1pQixNQUFNLENBQUNSO1FBQ3BDRixPQUFPVixRQUFRZ0MsT0FBTyxDQUFDN0IsTUFBTWlCLE1BQU0sQ0FBQ1I7UUFDcENELE9BQU9YLFFBQVFnQyxPQUFPLENBQUM3QixNQUFNaUIsTUFBTSxDQUFDUjtRQUVwQ1AsT0FBTyxRQUFTLElBQU1JLFFBQVE7UUFDOUJILE9BQU8sQ0FBRUcsT0FBTyxFQUFDLEtBQU0sSUFBTUMsUUFBUTtRQUNyQ0gsT0FBTyxDQUFFRyxPQUFPLE1BQU0sSUFBS0M7UUFFM0JQLE1BQU0sQ0FBQ21CLGNBQWMsR0FBR2xCO1FBRXhCLElBQUlLLFNBQVMsSUFBSTtZQUNiTixNQUFNLENBQUNtQixjQUFjLEdBQUdqQjtRQUM1QjtRQUNBLElBQUlLLFNBQVMsSUFBSTtZQUNiUCxNQUFNLENBQUNtQixjQUFjLEdBQUdoQjtRQUM1QjtJQUVKO0lBRUEsT0FBT0g7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL3BwdHgtb3B0aW1pemVyLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9iYXNlNjQuanM/ZDY5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi9zdXBwb3J0XCIpO1xuLy8gcHJpdmF0ZSBwcm9wZXJ0eVxudmFyIF9rZXlTdHIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG5cblxuLy8gcHVibGljIG1ldGhvZCBmb3IgZW5jb2RpbmdcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjMsIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCBsZW4gPSBpbnB1dC5sZW5ndGgsIHJlbWFpbmluZ0J5dGVzID0gbGVuO1xuXG4gICAgdmFyIGlzQXJyYXkgPSB1dGlscy5nZXRUeXBlT2YoaW5wdXQpICE9PSBcInN0cmluZ1wiO1xuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJlbWFpbmluZ0J5dGVzID0gbGVuIC0gaTtcblxuICAgICAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICAgICAgICAgIGNocjIgPSBpIDwgbGVuID8gaW5wdXRbaSsrXSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG4gICAgICAgIGVuYzMgPSByZW1haW5pbmdCeXRlcyA+IDEgPyAoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpIDogNjQ7XG4gICAgICAgIGVuYzQgPSByZW1haW5pbmdCeXRlcyA+IDIgPyAoY2hyMyAmIDYzKSA6IDY0O1xuXG4gICAgICAgIG91dHB1dC5wdXNoKF9rZXlTdHIuY2hhckF0KGVuYzEpICsgX2tleVN0ci5jaGFyQXQoZW5jMikgKyBfa2V5U3RyLmNoYXJBdChlbmMzKSArIF9rZXlTdHIuY2hhckF0KGVuYzQpKTtcblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn07XG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGRlY29kaW5nXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICB2YXIgZGF0YVVybFByZWZpeCA9IFwiZGF0YTpcIjtcblxuICAgIGlmIChpbnB1dC5zdWJzdHIoMCwgZGF0YVVybFByZWZpeC5sZW5ndGgpID09PSBkYXRhVXJsUHJlZml4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBjb21tb24gZXJyb3I6IHBlb3BsZSBnaXZlIGEgZGF0YSB1cmxcbiAgICAgICAgLy8gKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUi4uLikgd2l0aCBhIHtiYXNlNjQ6IHRydWV9IGFuZFxuICAgICAgICAvLyB3b25kZXJzIHdoeSB0aGluZ3MgZG9uJ3Qgd29yay5cbiAgICAgICAgLy8gV2UgY2FuIGRldGVjdCB0aGF0IHRoZSBzdHJpbmcgaW5wdXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsIGJ1dCB3ZVxuICAgICAgICAvLyAqY2FuJ3QqIGJlIHN1cmUgaXQgaXMgb25lOiByZW1vdmluZyBldmVyeXRoaW5nIHVwIHRvIHRoZSBjb21tYSB3b3VsZFxuICAgICAgICAvLyBiZSB0b28gZGFuZ2Vyb3VzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgaXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsLlwiKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05Ky89XS9nLCBcIlwiKTtcblxuICAgIHZhciB0b3RhbExlbmd0aCA9IGlucHV0Lmxlbmd0aCAqIDMgLyA0O1xuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAxKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAyKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmICh0b3RhbExlbmd0aCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gdG90YWxMZW5ndGggaXMgbm90IGFuIGludGVnZXIsIHRoZSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggYSB2YWxpZFxuICAgICAgICAvLyBiYXNlNjQgY29udGVudC4gVGhhdCBjYW4gaGFwcGVuIGlmOlxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyBub3QgYSBiYXNlNjQgY29udGVudFxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyAqYWxtb3N0KiBhIGJhc2U2NCBjb250ZW50LCB3aXRoIGEgZXh0cmEgY2hhcnMgYXQgdGhlXG4gICAgICAgIC8vICAgYmVnaW5uaW5nIG9yIGF0IHRoZSBlbmRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgdXNlcyBhIGJhc2U2NCB2YXJpYW50IChiYXNlNjR1cmwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBiYWQgY29udGVudCBsZW5ndGguXCIpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0O1xuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGh8MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG5cbiAgICAgICAgZW5jMSA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzIgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMzID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jNCA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIxO1xuXG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjM7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsInN1cHBvcnQiLCJfa2V5U3RyIiwiZXhwb3J0cyIsImVuY29kZSIsImlucHV0Iiwib3V0cHV0IiwiY2hyMSIsImNocjIiLCJjaHIzIiwiZW5jMSIsImVuYzIiLCJlbmMzIiwiZW5jNCIsImkiLCJsZW4iLCJsZW5ndGgiLCJyZW1haW5pbmdCeXRlcyIsImlzQXJyYXkiLCJnZXRUeXBlT2YiLCJjaGFyQ29kZUF0IiwicHVzaCIsImNoYXJBdCIsImpvaW4iLCJkZWNvZGUiLCJyZXN1bHRJbmRleCIsImRhdGFVcmxQcmVmaXgiLCJzdWJzdHIiLCJFcnJvciIsInJlcGxhY2UiLCJ0b3RhbExlbmd0aCIsInVpbnQ4YXJyYXkiLCJVaW50OEFycmF5IiwiQXJyYXkiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/compressedObject.js":
/*!****************************************************!*\
  !*** ./node_modules/jszip/lib/compressedObject.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar external = __webpack_require__(/*! ./external */ \"(ssr)/./node_modules/jszip/lib/external.js\");\nvar DataWorker = __webpack_require__(/*! ./stream/DataWorker */ \"(ssr)/./node_modules/jszip/lib/stream/DataWorker.js\");\nvar Crc32Probe = __webpack_require__(/*! ./stream/Crc32Probe */ \"(ssr)/./node_modules/jszip/lib/stream/Crc32Probe.js\");\nvar DataLengthProbe = __webpack_require__(/*! ./stream/DataLengthProbe */ \"(ssr)/./node_modules/jszip/lib/stream/DataLengthProbe.js\");\n/**\n * Represent a compressed object, with everything needed to decompress it.\n * @constructor\n * @param {number} compressedSize the size of the data compressed.\n * @param {number} uncompressedSize the size of the data after decompression.\n * @param {number} crc32 the crc32 of the decompressed file.\n * @param {object} compression the type of compression, see lib/compressions.js.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.\n */ function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {\n    this.compressedSize = compressedSize;\n    this.uncompressedSize = uncompressedSize;\n    this.crc32 = crc32;\n    this.compression = compression;\n    this.compressedContent = data;\n}\nCompressedObject.prototype = {\n    /**\n     * Create a worker to get the uncompressed content.\n     * @return {GenericWorker} the worker.\n     */ getContentWorker: function() {\n        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe(\"data_length\"));\n        var that = this;\n        worker.on(\"end\", function() {\n            if (this.streamInfo[\"data_length\"] !== that.uncompressedSize) {\n                throw new Error(\"Bug : uncompressed data size mismatch\");\n            }\n        });\n        return worker;\n    },\n    /**\n     * Create a worker to get the compressed content.\n     * @return {GenericWorker} the worker.\n     */ getCompressedWorker: function() {\n        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo(\"compressedSize\", this.compressedSize).withStreamInfo(\"uncompressedSize\", this.uncompressedSize).withStreamInfo(\"crc32\", this.crc32).withStreamInfo(\"compression\", this.compression);\n    }\n};\n/**\n * Chain the given worker with other workers to compress the content with the\n * given compression.\n * @param {GenericWorker} uncompressedWorker the worker to pipe.\n * @param {Object} compression the compression object.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {GenericWorker} the new worker compressing the content.\n */ CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {\n    return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe(\"uncompressedSize\")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe(\"compressedSize\")).withStreamInfo(\"compression\", compression);\n};\nmodule.exports = CompressedObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzZWRPYmplY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxXQUFXQyxtQkFBT0EsQ0FBQyw4REFBWTtBQUNuQyxJQUFJQyxhQUFhRCxtQkFBT0EsQ0FBQyxnRkFBcUI7QUFDOUMsSUFBSUUsYUFBYUYsbUJBQU9BLENBQUMsZ0ZBQXFCO0FBQzlDLElBQUlHLGtCQUFrQkgsbUJBQU9BLENBQUMsMEZBQTBCO0FBRXhEOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0ksaUJBQWlCQyxjQUFjLEVBQUVDLGdCQUFnQixFQUFFQyxLQUFLLEVBQUVDLFdBQVcsRUFBRUMsSUFBSTtJQUNoRixJQUFJLENBQUNKLGNBQWMsR0FBR0E7SUFDdEIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0E7SUFDeEIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO0lBQ2IsSUFBSSxDQUFDQyxXQUFXLEdBQUdBO0lBQ25CLElBQUksQ0FBQ0UsaUJBQWlCLEdBQUdEO0FBQzdCO0FBRUFMLGlCQUFpQk8sU0FBUyxHQUFHO0lBQ3pCOzs7S0FHQyxHQUNEQyxrQkFBa0I7UUFDZCxJQUFJQyxTQUFTLElBQUlaLFdBQVdGLFNBQVNlLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLElBQUksQ0FBQ0wsaUJBQWlCLEdBQ3RFTSxJQUFJLENBQUMsSUFBSSxDQUFDUixXQUFXLENBQUNTLGdCQUFnQixJQUN0Q0QsSUFBSSxDQUFDLElBQUliLGdCQUFnQjtRQUU5QixJQUFJZSxPQUFPLElBQUk7UUFDZkwsT0FBT00sRUFBRSxDQUFDLE9BQU87WUFDYixJQUFJLElBQUksQ0FBQ0MsVUFBVSxDQUFDLGNBQWMsS0FBS0YsS0FBS1osZ0JBQWdCLEVBQUU7Z0JBQzFELE1BQU0sSUFBSWUsTUFBTTtZQUNwQjtRQUNKO1FBQ0EsT0FBT1I7SUFDWDtJQUNBOzs7S0FHQyxHQUNEUyxxQkFBcUI7UUFDakIsT0FBTyxJQUFJckIsV0FBV0YsU0FBU2UsT0FBTyxDQUFDQyxPQUFPLENBQUMsSUFBSSxDQUFDTCxpQkFBaUIsR0FDaEVhLGNBQWMsQ0FBQyxrQkFBa0IsSUFBSSxDQUFDbEIsY0FBYyxFQUNwRGtCLGNBQWMsQ0FBQyxvQkFBb0IsSUFBSSxDQUFDakIsZ0JBQWdCLEVBQ3hEaUIsY0FBYyxDQUFDLFNBQVMsSUFBSSxDQUFDaEIsS0FBSyxFQUNsQ2dCLGNBQWMsQ0FBQyxlQUFlLElBQUksQ0FBQ2YsV0FBVztJQUV2RDtBQUNKO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNESixpQkFBaUJvQixnQkFBZ0IsR0FBRyxTQUFVQyxrQkFBa0IsRUFBRWpCLFdBQVcsRUFBRWtCLGtCQUFrQjtJQUM3RixPQUFPRCxtQkFDRlQsSUFBSSxDQUFDLElBQUlkLGNBQ1RjLElBQUksQ0FBQyxJQUFJYixnQkFBZ0IscUJBQ3pCYSxJQUFJLENBQUNSLFlBQVltQixjQUFjLENBQUNELHFCQUNoQ1YsSUFBSSxDQUFDLElBQUliLGdCQUFnQixtQkFDekJvQixjQUFjLENBQUMsZUFBZWY7QUFDdkM7QUFFQW9CLE9BQU9DLE9BQU8sR0FBR3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1vcHRpbWl6ZXIvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzZWRPYmplY3QuanM/OTUxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG52YXIgRGF0YVdvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9EYXRhV29ya2VyXCIpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKFwiLi9zdHJlYW0vQ3JjMzJQcm9iZVwiKTtcbnZhciBEYXRhTGVuZ3RoUHJvYmUgPSByZXF1aXJlKFwiLi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlXCIpO1xuXG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbXByZXNzZWQgb2JqZWN0LCB3aXRoIGV2ZXJ5dGhpbmcgbmVlZGVkIHRvIGRlY29tcHJlc3MgaXQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb21wcmVzc2VkU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSBjb21wcmVzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IHVuY29tcHJlc3NlZFNpemUgdGhlIHNpemUgb2YgdGhlIGRhdGEgYWZ0ZXIgZGVjb21wcmVzc2lvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjcmMzMiB0aGUgY3JjMzIgb2YgdGhlIGRlY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXByZXNzaW9uIHRoZSB0eXBlIG9mIGNvbXByZXNzaW9uLCBzZWUgbGliL2NvbXByZXNzaW9ucy5qcy5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBjb21wcmVzc2VkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIENvbXByZXNzZWRPYmplY3QoY29tcHJlc3NlZFNpemUsIHVuY29tcHJlc3NlZFNpemUsIGNyYzMyLCBjb21wcmVzc2lvbiwgZGF0YSkge1xuICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSBjb21wcmVzc2VkU2l6ZTtcbiAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSB1bmNvbXByZXNzZWRTaXplO1xuICAgIHRoaXMuY3JjMzIgPSBjcmMzMjtcbiAgICB0aGlzLmNvbXByZXNzaW9uID0gY29tcHJlc3Npb247XG4gICAgdGhpcy5jb21wcmVzc2VkQ29udGVudCA9IGRhdGE7XG59XG5cbkNvbXByZXNzZWRPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHdvcmtlciB0byBnZXQgdGhlIHVuY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgZ2V0Q29udGVudFdvcmtlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IERhdGFXb3JrZXIoZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tcHJlc3NlZENvbnRlbnQpKVxuICAgICAgICAgICAgLnBpcGUodGhpcy5jb21wcmVzc2lvbi51bmNvbXByZXNzV29ya2VyKCkpXG4gICAgICAgICAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwiZGF0YV9sZW5ndGhcIikpO1xuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgd29ya2VyLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbUluZm9bXCJkYXRhX2xlbmd0aFwiXSAhPT0gdGhhdC51bmNvbXByZXNzZWRTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIDogdW5jb21wcmVzc2VkIGRhdGEgc2l6ZSBtaXNtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB3b3JrZXIgdG8gZ2V0IHRoZSBjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBnZXRDb21wcmVzc2VkV29ya2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVdvcmtlcihleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUodGhpcy5jb21wcmVzc2VkQ29udGVudCkpXG4gICAgICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2VkU2l6ZVwiLCB0aGlzLmNvbXByZXNzZWRTaXplKVxuICAgICAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwidW5jb21wcmVzc2VkU2l6ZVwiLCB0aGlzLnVuY29tcHJlc3NlZFNpemUpXG4gICAgICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCB0aGlzLmNyYzMyKVxuICAgICAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3Npb25cIiwgdGhpcy5jb21wcmVzc2lvbilcbiAgICAgICAgO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2hhaW4gdGhlIGdpdmVuIHdvcmtlciB3aXRoIG90aGVyIHdvcmtlcnMgdG8gY29tcHJlc3MgdGhlIGNvbnRlbnQgd2l0aCB0aGVcbiAqIGdpdmVuIGNvbXByZXNzaW9uLlxuICogQHBhcmFtIHtHZW5lcmljV29ya2VyfSB1bmNvbXByZXNzZWRXb3JrZXIgdGhlIHdvcmtlciB0byBwaXBlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb25PcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIGNvbXByZXNzaW5nLlxuICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIG5ldyB3b3JrZXIgY29tcHJlc3NpbmcgdGhlIGNvbnRlbnQuXG4gKi9cbkNvbXByZXNzZWRPYmplY3QuY3JlYXRlV29ya2VyRnJvbSA9IGZ1bmN0aW9uICh1bmNvbXByZXNzZWRXb3JrZXIsIGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICByZXR1cm4gdW5jb21wcmVzc2VkV29ya2VyXG4gICAgICAgIC5waXBlKG5ldyBDcmMzMlByb2JlKCkpXG4gICAgICAgIC5waXBlKG5ldyBEYXRhTGVuZ3RoUHJvYmUoXCJ1bmNvbXByZXNzZWRTaXplXCIpKVxuICAgICAgICAucGlwZShjb21wcmVzc2lvbi5jb21wcmVzc1dvcmtlcihjb21wcmVzc2lvbk9wdGlvbnMpKVxuICAgICAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwiY29tcHJlc3NlZFNpemVcIikpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzaW9uXCIsIGNvbXByZXNzaW9uKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcHJlc3NlZE9iamVjdDtcbiJdLCJuYW1lcyI6WyJleHRlcm5hbCIsInJlcXVpcmUiLCJEYXRhV29ya2VyIiwiQ3JjMzJQcm9iZSIsIkRhdGFMZW5ndGhQcm9iZSIsIkNvbXByZXNzZWRPYmplY3QiLCJjb21wcmVzc2VkU2l6ZSIsInVuY29tcHJlc3NlZFNpemUiLCJjcmMzMiIsImNvbXByZXNzaW9uIiwiZGF0YSIsImNvbXByZXNzZWRDb250ZW50IiwicHJvdG90eXBlIiwiZ2V0Q29udGVudFdvcmtlciIsIndvcmtlciIsIlByb21pc2UiLCJyZXNvbHZlIiwicGlwZSIsInVuY29tcHJlc3NXb3JrZXIiLCJ0aGF0Iiwib24iLCJzdHJlYW1JbmZvIiwiRXJyb3IiLCJnZXRDb21wcmVzc2VkV29ya2VyIiwid2l0aFN0cmVhbUluZm8iLCJjcmVhdGVXb3JrZXJGcm9tIiwidW5jb21wcmVzc2VkV29ya2VyIiwiY29tcHJlc3Npb25PcHRpb25zIiwiY29tcHJlc3NXb3JrZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/compressedObject.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/compressions.js":
/*!************************************************!*\
  !*** ./node_modules/jszip/lib/compressions.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nexports.STORE = {\n    magic: \"\\x00\\x00\",\n    compressWorker: function() {\n        return new GenericWorker(\"STORE compression\");\n    },\n    uncompressWorker: function() {\n        return new GenericWorker(\"STORE decompression\");\n    }\n};\nexports.DEFLATE = __webpack_require__(/*! ./flate */ \"(ssr)/./node_modules/jszip/lib/flate.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzaW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLGdCQUFnQkMsbUJBQU9BLENBQUMsc0ZBQXdCO0FBRXBEQyxhQUFhLEdBQUc7SUFDWkUsT0FBTztJQUNQQyxnQkFBaUI7UUFDYixPQUFPLElBQUlMLGNBQWM7SUFDN0I7SUFDQU0sa0JBQW1CO1FBQ2YsT0FBTyxJQUFJTixjQUFjO0lBQzdCO0FBQ0o7QUFDQUUsK0ZBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1vcHRpbWl6ZXIvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzaW9ucy5qcz9mNTc1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG5leHBvcnRzLlNUT1JFID0ge1xuICAgIG1hZ2ljOiBcIlxceDAwXFx4MDBcIixcbiAgICBjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljV29ya2VyKFwiU1RPUkUgY29tcHJlc3Npb25cIik7XG4gICAgfSxcbiAgICB1bmNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNXb3JrZXIoXCJTVE9SRSBkZWNvbXByZXNzaW9uXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLkRFRkxBVEUgPSByZXF1aXJlKFwiLi9mbGF0ZVwiKTtcbiJdLCJuYW1lcyI6WyJHZW5lcmljV29ya2VyIiwicmVxdWlyZSIsImV4cG9ydHMiLCJTVE9SRSIsIm1hZ2ljIiwiY29tcHJlc3NXb3JrZXIiLCJ1bmNvbXByZXNzV29ya2VyIiwiREVGTEFURSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/compressions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/crc32.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/crc32.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\n/**\n * The following functions come from pako, from pako/lib/zlib/crc32.js\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */ // Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n    var c, table = [];\n    for(var n = 0; n < 256; n++){\n        c = n;\n        for(var k = 0; k < 8; k++){\n            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;\n        }\n        table[n] = c;\n    }\n    return table;\n}\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\nfunction crc32(crc, buf, len, pos) {\n    var t = crcTable, end = pos + len;\n    crc = crc ^ -1;\n    for(var i = pos; i < end; i++){\n        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n    return crc ^ -1; // >>> 0;\n}\n// That's all for the pako functions.\n/**\n * Compute the crc32 of a string.\n * This is almost the same as the function crc32, but for strings. Using the\n * same function for the two use cases leads to horrible performances.\n * @param {Number} crc the starting value of the crc.\n * @param {String} str the string to use.\n * @param {Number} len the length of the string.\n * @param {Number} pos the starting position for the crc32 computation.\n * @return {Number} the computed crc32.\n */ function crc32str(crc, str, len, pos) {\n    var t = crcTable, end = pos + len;\n    crc = crc ^ -1;\n    for(var i = pos; i < end; i++){\n        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];\n    }\n    return crc ^ -1; // >>> 0;\n}\nmodule.exports = function crc32wrapper(input, crc) {\n    if (typeof input === \"undefined\" || !input.length) {\n        return 0;\n    }\n    var isArray = utils.getTypeOf(input) !== \"string\";\n    if (isArray) {\n        return crc32(crc | 0, input, input.length, 0);\n    } else {\n        return crc32str(crc | 0, input, input.length, 0);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NyYzMyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMsd0RBQVM7QUFFN0I7OztDQUdDLEdBRUQsd0RBQXdEO0FBQ3hELFNBQVNDO0lBQ0wsSUFBSUMsR0FBR0MsUUFBUSxFQUFFO0lBRWpCLElBQUksSUFBSUMsSUFBRyxHQUFHQSxJQUFJLEtBQUtBLElBQUk7UUFDdkJGLElBQUlFO1FBQ0osSUFBSSxJQUFJQyxJQUFHLEdBQUdBLElBQUksR0FBR0EsSUFBSTtZQUNyQkgsSUFBSyxJQUFHLElBQU0sYUFBY0EsTUFBTSxJQUFPQSxNQUFNO1FBQ25EO1FBQ0FDLEtBQUssQ0FBQ0MsRUFBRSxHQUFHRjtJQUNmO0lBRUEsT0FBT0M7QUFDWDtBQUVBLDhEQUE4RDtBQUM5RCxJQUFJRyxXQUFXTDtBQUdmLFNBQVNNLE1BQU1DLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFDN0IsSUFBSUMsSUFBSU4sVUFBVU8sTUFBTUYsTUFBTUQ7SUFFOUJGLE1BQU1BLE1BQU8sQ0FBQztJQUVkLElBQUssSUFBSU0sSUFBSUgsS0FBS0csSUFBSUQsS0FBS0MsSUFBTTtRQUM3Qk4sTUFBTSxRQUFTLElBQUtJLENBQUMsQ0FBQyxDQUFDSixNQUFNQyxHQUFHLENBQUNLLEVBQUUsSUFBSSxLQUFLO0lBQ2hEO0lBRUEsT0FBUU4sTUFBTyxDQUFDLEdBQUssU0FBUztBQUNsQztBQUVBLHFDQUFxQztBQUVyQzs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTTyxTQUFTUCxHQUFHLEVBQUVRLEdBQUcsRUFBRU4sR0FBRyxFQUFFQyxHQUFHO0lBQ2hDLElBQUlDLElBQUlOLFVBQVVPLE1BQU1GLE1BQU1EO0lBRTlCRixNQUFNQSxNQUFPLENBQUM7SUFFZCxJQUFLLElBQUlNLElBQUlILEtBQUtHLElBQUlELEtBQUtDLElBQU07UUFDN0JOLE1BQU0sUUFBUyxJQUFLSSxDQUFDLENBQUMsQ0FBQ0osTUFBTVEsSUFBSUMsVUFBVSxDQUFDSCxFQUFDLElBQUssS0FBSztJQUMzRDtJQUVBLE9BQVFOLE1BQU8sQ0FBQyxHQUFLLFNBQVM7QUFDbEM7QUFFQVUsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLGFBQWFDLEtBQUssRUFBRWIsR0FBRztJQUM3QyxJQUFJLE9BQU9hLFVBQVUsZUFBZSxDQUFDQSxNQUFNQyxNQUFNLEVBQUU7UUFDL0MsT0FBTztJQUNYO0lBRUEsSUFBSUMsVUFBVXhCLE1BQU15QixTQUFTLENBQUNILFdBQVc7SUFFekMsSUFBR0UsU0FBUztRQUNSLE9BQU9oQixNQUFNQyxNQUFJLEdBQUdhLE9BQU9BLE1BQU1DLE1BQU0sRUFBRTtJQUM3QyxPQUFPO1FBQ0gsT0FBT1AsU0FBU1AsTUFBSSxHQUFHYSxPQUFPQSxNQUFNQyxNQUFNLEVBQUU7SUFDaEQ7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3BwdHgtb3B0aW1pemVyLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jcmMzMi5qcz84ZjhhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjb21lIGZyb20gcGFrbywgZnJvbSBwYWtvL2xpYi96bGliL2NyYzMyLmpzXG4gKiByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UsIHNlZSBwYWtvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9cbiAqL1xuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICAgIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gICAgZm9yKHZhciBuID0wOyBuIDwgMjU2OyBuKyspe1xuICAgICAgICBjID0gbjtcbiAgICAgICAgZm9yKHZhciBrID0wOyBrIDwgODsgaysrKXtcbiAgICAgICAgICAgIGMgPSAoKGMmMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlW25dID0gYztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgICBjcmMgPSBjcmMgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGNyYzMyIG9mIGEgc3RyaW5nLlxuICogVGhpcyBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgdGhlIGZ1bmN0aW9uIGNyYzMyLCBidXQgZm9yIHN0cmluZ3MuIFVzaW5nIHRoZVxuICogc2FtZSBmdW5jdGlvbiBmb3IgdGhlIHR3byB1c2UgY2FzZXMgbGVhZHMgdG8gaG9ycmlibGUgcGVyZm9ybWFuY2VzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNyYyB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgdGhlIGNyYy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGZvciB0aGUgY3JjMzIgY29tcHV0YXRpb24uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjb21wdXRlZCBjcmMzMi5cbiAqL1xuZnVuY3Rpb24gY3JjMzJzdHIoY3JjLCBzdHIsIGxlbiwgcG9zKSB7XG4gICAgdmFyIHQgPSBjcmNUYWJsZSwgZW5kID0gcG9zICsgbGVuO1xuXG4gICAgY3JjID0gY3JjIF4gKC0xKTtcblxuICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBzdHIuY2hhckNvZGVBdChpKSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmMzMndyYXBwZXIoaW5wdXQsIGNyYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIgfHwgIWlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgaXNBcnJheSA9IHV0aWxzLmdldFR5cGVPZihpbnB1dCkgIT09IFwic3RyaW5nXCI7XG5cbiAgICBpZihpc0FycmF5KSB7XG4gICAgICAgIHJldHVybiBjcmMzMihjcmN8MCwgaW5wdXQsIGlucHV0Lmxlbmd0aCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyYzMyc3RyKGNyY3wwLCBpbnB1dCwgaW5wdXQubGVuZ3RoLCAwKTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIm1ha2VUYWJsZSIsImMiLCJ0YWJsZSIsIm4iLCJrIiwiY3JjVGFibGUiLCJjcmMzMiIsImNyYyIsImJ1ZiIsImxlbiIsInBvcyIsInQiLCJlbmQiLCJpIiwiY3JjMzJzdHIiLCJzdHIiLCJjaGFyQ29kZUF0IiwibW9kdWxlIiwiZXhwb3J0cyIsImNyYzMyd3JhcHBlciIsImlucHV0IiwibGVuZ3RoIiwiaXNBcnJheSIsImdldFR5cGVPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/crc32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/defaults.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nexports.base64 = false;\nexports.binary = false;\nexports.dir = false;\nexports.createFolders = true;\nexports.date = null;\nexports.compression = null;\nexports.compressionOptions = null;\nexports.comment = null;\nexports.unixPermissions = null;\nexports.dosPermissions = null;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2RlZmF1bHRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLGNBQWMsR0FBRztBQUNqQkEsY0FBYyxHQUFHO0FBQ2pCQSxXQUFXLEdBQUc7QUFDZEEscUJBQXFCLEdBQUc7QUFDeEJBLFlBQVksR0FBRztBQUNmQSxtQkFBbUIsR0FBRztBQUN0QkEsMEJBQTBCLEdBQUc7QUFDN0JBLGVBQWUsR0FBRztBQUNsQkEsdUJBQXVCLEdBQUc7QUFDMUJBLHNCQUFzQixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1vcHRpbWl6ZXIvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2RlZmF1bHRzLmpzPzU0MWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmJhc2U2NCA9IGZhbHNlO1xuZXhwb3J0cy5iaW5hcnkgPSBmYWxzZTtcbmV4cG9ydHMuZGlyID0gZmFsc2U7XG5leHBvcnRzLmNyZWF0ZUZvbGRlcnMgPSB0cnVlO1xuZXhwb3J0cy5kYXRlID0gbnVsbDtcbmV4cG9ydHMuY29tcHJlc3Npb24gPSBudWxsO1xuZXhwb3J0cy5jb21wcmVzc2lvbk9wdGlvbnMgPSBudWxsO1xuZXhwb3J0cy5jb21tZW50ID0gbnVsbDtcbmV4cG9ydHMudW5peFBlcm1pc3Npb25zID0gbnVsbDtcbmV4cG9ydHMuZG9zUGVybWlzc2lvbnMgPSBudWxsO1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJiYXNlNjQiLCJiaW5hcnkiLCJkaXIiLCJjcmVhdGVGb2xkZXJzIiwiZGF0ZSIsImNvbXByZXNzaW9uIiwiY29tcHJlc3Npb25PcHRpb25zIiwiY29tbWVudCIsInVuaXhQZXJtaXNzaW9ucyIsImRvc1Blcm1pc3Npb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/defaults.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/external.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/external.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// load the global object first:\n// - it should be better integrated in the system (unhandledRejection in node)\n// - the environment may have a custom Promise implementation (see zone.js)\nvar ES6Promise = null;\nif (typeof Promise !== \"undefined\") {\n    ES6Promise = Promise;\n} else {\n    ES6Promise = __webpack_require__(/*! lie */ \"(ssr)/./node_modules/lie/lib/index.js\");\n}\n/**\n * Let the user use/change some implementations.\n */ module.exports = {\n    Promise: ES6Promise\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2V4dGVybmFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsZ0NBQWdDO0FBQ2hDLDhFQUE4RTtBQUM5RSwyRUFBMkU7QUFDM0UsSUFBSUEsYUFBYTtBQUNqQixJQUFJLE9BQU9DLFlBQVksYUFBYTtJQUNoQ0QsYUFBYUM7QUFDakIsT0FBTztJQUNIRCxhQUFhRSxtQkFBT0EsQ0FBQyxrREFBSztBQUM5QjtBQUVBOztDQUVDLEdBQ0RDLE9BQU9DLE9BQU8sR0FBRztJQUNiSCxTQUFTRDtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1vcHRpbWl6ZXIvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2V4dGVybmFsLmpzPzUwZDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGxvYWQgdGhlIGdsb2JhbCBvYmplY3QgZmlyc3Q6XG4vLyAtIGl0IHNob3VsZCBiZSBiZXR0ZXIgaW50ZWdyYXRlZCBpbiB0aGUgc3lzdGVtICh1bmhhbmRsZWRSZWplY3Rpb24gaW4gbm9kZSlcbi8vIC0gdGhlIGVudmlyb25tZW50IG1heSBoYXZlIGEgY3VzdG9tIFByb21pc2UgaW1wbGVtZW50YXRpb24gKHNlZSB6b25lLmpzKVxudmFyIEVTNlByb21pc2UgPSBudWxsO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgRVM2UHJvbWlzZSA9IFByb21pc2U7XG59IGVsc2Uge1xuICAgIEVTNlByb21pc2UgPSByZXF1aXJlKFwibGllXCIpO1xufVxuXG4vKipcbiAqIExldCB0aGUgdXNlciB1c2UvY2hhbmdlIHNvbWUgaW1wbGVtZW50YXRpb25zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQcm9taXNlOiBFUzZQcm9taXNlXG59O1xuIl0sIm5hbWVzIjpbIkVTNlByb21pc2UiLCJQcm9taXNlIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/external.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/flate.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/flate.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar USE_TYPEDARRAY = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Uint32Array !== \"undefined\";\nvar pako = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/index.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nvar ARRAY_TYPE = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\nexports.magic = \"\\b\\x00\";\n/**\n * Create a worker that uses pako to inflate/deflate.\n * @constructor\n * @param {String} action the name of the pako function to call : either \"Deflate\" or \"Inflate\".\n * @param {Object} options the options to use when (de)compressing.\n */ function FlateWorker(action, options) {\n    GenericWorker.call(this, \"FlateWorker/\" + action);\n    this._pako = null;\n    this._pakoAction = action;\n    this._pakoOptions = options;\n    // the `meta` object from the last chunk received\n    // this allow this worker to pass around metadata\n    this.meta = {};\n}\nutils.inherits(FlateWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ FlateWorker.prototype.processChunk = function(chunk) {\n    this.meta = chunk.meta;\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);\n};\n/**\n * @see GenericWorker.flush\n */ FlateWorker.prototype.flush = function() {\n    GenericWorker.prototype.flush.call(this);\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push([], true);\n};\n/**\n * @see GenericWorker.cleanUp\n */ FlateWorker.prototype.cleanUp = function() {\n    GenericWorker.prototype.cleanUp.call(this);\n    this._pako = null;\n};\n/**\n * Create the _pako object.\n * TODO: lazy-loading this object isn't the best solution but it's the\n * quickest. The best solution is to lazy-load the worker list. See also the\n * issue #446.\n */ FlateWorker.prototype._createPako = function() {\n    this._pako = new pako[this._pakoAction]({\n        raw: true,\n        level: this._pakoOptions.level || -1 // default compression\n    });\n    var self = this;\n    this._pako.onData = function(data) {\n        self.push({\n            data: data,\n            meta: self.meta\n        });\n    };\n};\nexports.compressWorker = function(compressionOptions) {\n    return new FlateWorker(\"Deflate\", compressionOptions);\n};\nexports.uncompressWorker = function() {\n    return new FlateWorker(\"Inflate\", {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2ZsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsaUJBQWlCLE9BQVFDLGVBQWUsZUFBaUIsT0FBT0MsZ0JBQWdCLGVBQWlCLE9BQU9DLGdCQUFnQjtBQUU1SCxJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQyxnREFBTTtBQUN6QixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQyx3REFBUztBQUM3QixJQUFJRSxnQkFBZ0JGLG1CQUFPQSxDQUFDLHNGQUF3QjtBQUVwRCxJQUFJRyxhQUFhUixpQkFBaUIsZUFBZTtBQUVqRFMsYUFBYSxHQUFHO0FBRWhCOzs7OztDQUtDLEdBQ0QsU0FBU0UsWUFBWUMsTUFBTSxFQUFFQyxPQUFPO0lBQ2hDTixjQUFjTyxJQUFJLENBQUMsSUFBSSxFQUFFLGlCQUFpQkY7SUFFMUMsSUFBSSxDQUFDRyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLFdBQVcsR0FBR0o7SUFDbkIsSUFBSSxDQUFDSyxZQUFZLEdBQUdKO0lBQ3BCLGlEQUFpRDtJQUNqRCxpREFBaUQ7SUFDakQsSUFBSSxDQUFDSyxJQUFJLEdBQUcsQ0FBQztBQUNqQjtBQUVBWixNQUFNYSxRQUFRLENBQUNSLGFBQWFKO0FBRTVCOztDQUVDLEdBQ0RJLFlBQVlTLFNBQVMsQ0FBQ0MsWUFBWSxHQUFHLFNBQVVDLEtBQUs7SUFDaEQsSUFBSSxDQUFDSixJQUFJLEdBQUdJLE1BQU1KLElBQUk7SUFDdEIsSUFBSSxJQUFJLENBQUNILEtBQUssS0FBSyxNQUFNO1FBQ3JCLElBQUksQ0FBQ1EsV0FBVztJQUNwQjtJQUNBLElBQUksQ0FBQ1IsS0FBSyxDQUFDUyxJQUFJLENBQUNsQixNQUFNbUIsV0FBVyxDQUFDakIsWUFBWWMsTUFBTUksSUFBSSxHQUFHO0FBQy9EO0FBRUE7O0NBRUMsR0FDRGYsWUFBWVMsU0FBUyxDQUFDTyxLQUFLLEdBQUc7SUFDMUJwQixjQUFjYSxTQUFTLENBQUNPLEtBQUssQ0FBQ2IsSUFBSSxDQUFDLElBQUk7SUFDdkMsSUFBSSxJQUFJLENBQUNDLEtBQUssS0FBSyxNQUFNO1FBQ3JCLElBQUksQ0FBQ1EsV0FBVztJQUNwQjtJQUNBLElBQUksQ0FBQ1IsS0FBSyxDQUFDUyxJQUFJLENBQUMsRUFBRSxFQUFFO0FBQ3hCO0FBQ0E7O0NBRUMsR0FDRGIsWUFBWVMsU0FBUyxDQUFDUSxPQUFPLEdBQUc7SUFDNUJyQixjQUFjYSxTQUFTLENBQUNRLE9BQU8sQ0FBQ2QsSUFBSSxDQUFDLElBQUk7SUFDekMsSUFBSSxDQUFDQyxLQUFLLEdBQUc7QUFDakI7QUFFQTs7Ozs7Q0FLQyxHQUNESixZQUFZUyxTQUFTLENBQUNHLFdBQVcsR0FBRztJQUNoQyxJQUFJLENBQUNSLEtBQUssR0FBRyxJQUFJWCxJQUFJLENBQUMsSUFBSSxDQUFDWSxXQUFXLENBQUMsQ0FBQztRQUNwQ2EsS0FBSztRQUNMQyxPQUFPLElBQUksQ0FBQ2IsWUFBWSxDQUFDYSxLQUFLLElBQUksQ0FBQyxFQUFFLHNCQUFzQjtJQUMvRDtJQUNBLElBQUlDLE9BQU8sSUFBSTtJQUNmLElBQUksQ0FBQ2hCLEtBQUssQ0FBQ2lCLE1BQU0sR0FBRyxTQUFTTixJQUFJO1FBQzdCSyxLQUFLUCxJQUFJLENBQUM7WUFDTkUsTUFBT0E7WUFDUFIsTUFBT2EsS0FBS2IsSUFBSTtRQUNwQjtJQUNKO0FBQ0o7QUFFQVQsc0JBQXNCLEdBQUcsU0FBVXlCLGtCQUFrQjtJQUNqRCxPQUFPLElBQUl2QixZQUFZLFdBQVd1QjtBQUN0QztBQUNBekIsd0JBQXdCLEdBQUc7SUFDdkIsT0FBTyxJQUFJRSxZQUFZLFdBQVcsQ0FBQztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BwdHgtb3B0aW1pemVyLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9mbGF0ZS5qcz9jZGMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIFVTRV9UWVBFREFSUkFZID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAmJiAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAmJiAodHlwZW9mIFVpbnQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKTtcblxudmFyIHBha28gPSByZXF1aXJlKFwicGFrb1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxudmFyIEFSUkFZX1RZUEUgPSBVU0VfVFlQRURBUlJBWSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuXG5leHBvcnRzLm1hZ2ljID0gXCJcXHgwOFxceDAwXCI7XG5cbi8qKlxuICogQ3JlYXRlIGEgd29ya2VyIHRoYXQgdXNlcyBwYWtvIHRvIGluZmxhdGUvZGVmbGF0ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiB0aGUgbmFtZSBvZiB0aGUgcGFrbyBmdW5jdGlvbiB0byBjYWxsIDogZWl0aGVyIFwiRGVmbGF0ZVwiIG9yIFwiSW5mbGF0ZVwiLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gKGRlKWNvbXByZXNzaW5nLlxuICovXG5mdW5jdGlvbiBGbGF0ZVdvcmtlcihhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJGbGF0ZVdvcmtlci9cIiArIGFjdGlvbik7XG5cbiAgICB0aGlzLl9wYWtvID0gbnVsbDtcbiAgICB0aGlzLl9wYWtvQWN0aW9uID0gYWN0aW9uO1xuICAgIHRoaXMuX3Bha29PcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyB0aGUgYG1ldGFgIG9iamVjdCBmcm9tIHRoZSBsYXN0IGNodW5rIHJlY2VpdmVkXG4gICAgLy8gdGhpcyBhbGxvdyB0aGlzIHdvcmtlciB0byBwYXNzIGFyb3VuZCBtZXRhZGF0YVxuICAgIHRoaXMubWV0YSA9IHt9O1xufVxuXG51dGlscy5pbmhlcml0cyhGbGF0ZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5tZXRhID0gY2h1bmsubWV0YTtcbiAgICBpZiAodGhpcy5fcGFrbyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQYWtvKCk7XG4gICAgfVxuICAgIHRoaXMuX3Bha28ucHVzaCh1dGlscy50cmFuc2Zvcm1UbyhBUlJBWV9UWVBFLCBjaHVuay5kYXRhKSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuX3Bha28gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUGFrbygpO1xuICAgIH1cbiAgICB0aGlzLl9wYWtvLnB1c2goW10sIHRydWUpO1xufTtcbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuY2xlYW5VcC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3Bha28gPSBudWxsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIF9wYWtvIG9iamVjdC5cbiAqIFRPRE86IGxhenktbG9hZGluZyB0aGlzIG9iamVjdCBpc24ndCB0aGUgYmVzdCBzb2x1dGlvbiBidXQgaXQncyB0aGVcbiAqIHF1aWNrZXN0LiBUaGUgYmVzdCBzb2x1dGlvbiBpcyB0byBsYXp5LWxvYWQgdGhlIHdvcmtlciBsaXN0LiBTZWUgYWxzbyB0aGVcbiAqIGlzc3VlICM0NDYuXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5fY3JlYXRlUGFrbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wYWtvID0gbmV3IHBha29bdGhpcy5fcGFrb0FjdGlvbl0oe1xuICAgICAgICByYXc6IHRydWUsXG4gICAgICAgIGxldmVsOiB0aGlzLl9wYWtvT3B0aW9ucy5sZXZlbCB8fCAtMSAvLyBkZWZhdWx0IGNvbXByZXNzaW9uXG4gICAgfSk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3Bha28ub25EYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzZWxmLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDogc2VsZi5tZXRhXG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5leHBvcnRzLmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJEZWZsYXRlXCIsIGNvbXByZXNzaW9uT3B0aW9ucyk7XG59O1xuZXhwb3J0cy51bmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJJbmZsYXRlXCIsIHt9KTtcbn07XG4iXSwibmFtZXMiOlsiVVNFX1RZUEVEQVJSQVkiLCJVaW50OEFycmF5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsInBha28iLCJyZXF1aXJlIiwidXRpbHMiLCJHZW5lcmljV29ya2VyIiwiQVJSQVlfVFlQRSIsImV4cG9ydHMiLCJtYWdpYyIsIkZsYXRlV29ya2VyIiwiYWN0aW9uIiwib3B0aW9ucyIsImNhbGwiLCJfcGFrbyIsIl9wYWtvQWN0aW9uIiwiX3Bha29PcHRpb25zIiwibWV0YSIsImluaGVyaXRzIiwicHJvdG90eXBlIiwicHJvY2Vzc0NodW5rIiwiY2h1bmsiLCJfY3JlYXRlUGFrbyIsInB1c2giLCJ0cmFuc2Zvcm1UbyIsImRhdGEiLCJmbHVzaCIsImNsZWFuVXAiLCJyYXciLCJsZXZlbCIsInNlbGYiLCJvbkRhdGEiLCJjb21wcmVzc1dvcmtlciIsImNvbXByZXNzaW9uT3B0aW9ucyIsInVuY29tcHJlc3NXb3JrZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/flate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/generate/ZipFileWorker.js":
/*!**********************************************************!*\
  !*** ./node_modules/jszip/lib/generate/ZipFileWorker.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ../stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nvar utf8 = __webpack_require__(/*! ../utf8 */ \"(ssr)/./node_modules/jszip/lib/utf8.js\");\nvar crc32 = __webpack_require__(/*! ../crc32 */ \"(ssr)/./node_modules/jszip/lib/crc32.js\");\nvar signature = __webpack_require__(/*! ../signature */ \"(ssr)/./node_modules/jszip/lib/signature.js\");\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */ var decToHex = function(dec, bytes) {\n    var hex = \"\", i;\n    for(i = 0; i < bytes; i++){\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */ var generateUnixExternalFileAttr = function(unixPermissions, isDir) {\n    var result = unixPermissions;\n    if (!unixPermissions) {\n        // I can't use octal values in strict mode, hence the hexa.\n        //  040775 => 0x41fd\n        // 0100664 => 0x81b4\n        result = isDir ? 0x41fd : 0x81b4;\n    }\n    return (result & 0xFFFF) << 16;\n};\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */ var generateDosExternalFileAttr = function(dosPermissions) {\n    // the dir flag is already set for compatibility\n    return (dosPermissions || 0) & 0x3F;\n};\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {Object} streamInfo the hash with information about the compressed file.\n * @param {Boolean} streamedContent is the content streamed ?\n * @param {Boolean} streamingEnded is the stream finished ?\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {Object} the zip parts.\n */ var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {\n    var file = streamInfo[\"file\"], compression = streamInfo[\"compression\"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo(\"string\", encodeFileName(comment)), utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = \"\", unicodePathExtraField = \"\", unicodeCommentExtraField = \"\", dir = file.dir, date = file.date;\n    var dataInfo = {\n        crc32: 0,\n        compressedSize: 0,\n        uncompressedSize: 0\n    };\n    // if the content is streamed, the sizes/crc32 are only available AFTER\n    // the end of the stream.\n    if (!streamedContent || streamingEnded) {\n        dataInfo.crc32 = streamInfo[\"crc32\"];\n        dataInfo.compressedSize = streamInfo[\"compressedSize\"];\n        dataInfo.uncompressedSize = streamInfo[\"uncompressedSize\"];\n    }\n    var bitflag = 0;\n    if (streamedContent) {\n        // Bit 3: the sizes/crc32 are set to zero in the local header.\n        // The correct values are put in the data descriptor immediately\n        // following the compressed data.\n        bitflag |= 0x0008;\n    }\n    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {\n        // Bit 11: Language encoding flag (EFS).\n        bitflag |= 0x0800;\n    }\n    var extFileAttr = 0;\n    var versionMadeBy = 0;\n    if (dir) {\n        // dos or unix, we set the dos dir flag\n        extFileAttr |= 0x00010;\n    }\n    if (platform === \"UNIX\") {\n        versionMadeBy = 0x031E; // UNIX, version 3.0\n        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n    } else {\n        versionMadeBy = 0x0014; // DOS, version 2.0\n        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n    }\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n    dosTime = date.getUTCHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getUTCMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getUTCSeconds() / 2;\n    dosDate = date.getUTCFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | date.getUTCMonth() + 1;\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getUTCDate();\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows' default compressed folders feature but\n        // breaks on p7zip which doesn't seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField = // Version\n        decToHex(1, 1) + // NameCRC32\n        decToHex(crc32(encodedFileName), 4) + // UnicodeName\n        utfEncodedFileName;\n        extraFields += // Info-ZIP Unicode Path Extra Field\n        \"up\" + // size\n        decToHex(unicodePathExtraField.length, 2) + // content\n        unicodePathExtraField;\n    }\n    if (useUTF8ForComment) {\n        unicodeCommentExtraField = // Version\n        decToHex(1, 1) + // CommentCRC32\n        decToHex(crc32(encodedComment), 4) + // UnicodeName\n        utfEncodedComment;\n        extraFields += // Info-ZIP Unicode Path Extra Field\n        \"uc\" + // size\n        decToHex(unicodeCommentExtraField.length, 2) + // content\n        unicodeCommentExtraField;\n    }\n    var header = \"\";\n    // version needed to extract\n    header += \"\\n\\x00\";\n    // general purpose bit flag\n    header += decToHex(bitflag, 2);\n    // compression method\n    header += compression.magic;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(dataInfo.crc32, 4);\n    // compressed size\n    header += decToHex(dataInfo.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(dataInfo.uncompressedSize, 4);\n    // file name length\n    header += decToHex(encodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n    var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)\n    decToHex(versionMadeBy, 2) + // file header (common to file and central directory)\n    header + // file comment length\n    decToHex(encodedComment.length, 2) + // disk number start\n    \"\\x00\\x00\" + // internal file attributes TODO\n    \"\\x00\\x00\" + // external file attributes\n    decToHex(extFileAttr, 4) + // relative offset of local header\n    decToHex(offset, 4) + // file name\n    encodedFileName + // extra field\n    extraFields + // file comment\n    encodedComment;\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord\n    };\n};\n/**\n * Generate the EOCD record.\n * @param {Number} entriesCount the number of entries in the zip file.\n * @param {Number} centralDirLength the length (in bytes) of the central dir.\n * @param {Number} localDirLength the length (in bytes) of the local dir.\n * @param {String} comment the zip file comment as a binary string.\n * @param {Function} encodeFileName the function to encode the comment.\n * @return {String} the EOCD record.\n */ var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {\n    var dirEnd = \"\";\n    var encodedComment = utils.transformTo(\"string\", encodeFileName(comment));\n    // end of central dir signature\n    dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk\n    \"\\x00\\x00\" + // number of the disk with the start of the central directory\n    \"\\x00\\x00\" + // total number of entries in the central directory on this disk\n    decToHex(entriesCount, 2) + // total number of entries in the central directory\n    decToHex(entriesCount, 2) + // size of the central directory   4 bytes\n    decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number\n    decToHex(localDirLength, 4) + // .ZIP file comment length\n    decToHex(encodedComment.length, 2) + // .ZIP file comment\n    encodedComment;\n    return dirEnd;\n};\n/**\n * Generate data descriptors for a file entry.\n * @param {Object} streamInfo the hash generated by a worker, containing information\n * on the file entry.\n * @return {String} the data descriptors.\n */ var generateDataDescriptors = function(streamInfo) {\n    var descriptor = \"\";\n    descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes\n    decToHex(streamInfo[\"crc32\"], 4) + // compressed size                 4 bytes\n    decToHex(streamInfo[\"compressedSize\"], 4) + // uncompressed size               4 bytes\n    decToHex(streamInfo[\"uncompressedSize\"], 4);\n    return descriptor;\n};\n/**\n * A worker to concatenate other workers to create a zip file.\n * @param {Boolean} streamFiles `true` to stream the content of the files,\n * `false` to accumulate it.\n * @param {String} comment the comment to use.\n * @param {String} platform the platform to use, \"UNIX\" or \"DOS\".\n * @param {Function} encodeFileName the function to encode file names and comments.\n */ function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {\n    GenericWorker.call(this, \"ZipFileWorker\");\n    // The number of bytes written so far. This doesn't count accumulated chunks.\n    this.bytesWritten = 0;\n    // The comment of the zip file\n    this.zipComment = comment;\n    // The platform \"generating\" the zip file.\n    this.zipPlatform = platform;\n    // the function to encode file names and comments.\n    this.encodeFileName = encodeFileName;\n    // Should we stream the content of the files ?\n    this.streamFiles = streamFiles;\n    // If `streamFiles` is false, we will need to accumulate the content of the\n    // files to calculate sizes / crc32 (and write them *before* the content).\n    // This boolean indicates if we are accumulating chunks (it will change a lot\n    // during the lifetime of this worker).\n    this.accumulate = false;\n    // The buffer receiving chunks when accumulating content.\n    this.contentBuffer = [];\n    // The list of generated directory records.\n    this.dirRecords = [];\n    // The offset (in bytes) from the beginning of the zip file for the current source.\n    this.currentSourceOffset = 0;\n    // The total number of entries in this zip file.\n    this.entriesCount = 0;\n    // the name of the file currently being added, null when handling the end of the zip file.\n    // Used for the emitted metadata.\n    this.currentFile = null;\n    this._sources = [];\n}\nutils.inherits(ZipFileWorker, GenericWorker);\n/**\n * @see GenericWorker.push\n */ ZipFileWorker.prototype.push = function(chunk) {\n    var currentFilePercent = chunk.meta.percent || 0;\n    var entriesCount = this.entriesCount;\n    var remainingFiles = this._sources.length;\n    if (this.accumulate) {\n        this.contentBuffer.push(chunk);\n    } else {\n        this.bytesWritten += chunk.data.length;\n        GenericWorker.prototype.push.call(this, {\n            data: chunk.data,\n            meta: {\n                currentFile: this.currentFile,\n                percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100\n            }\n        });\n    }\n};\n/**\n * The worker started a new source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the new source.\n */ ZipFileWorker.prototype.openedSource = function(streamInfo) {\n    this.currentSourceOffset = this.bytesWritten;\n    this.currentFile = streamInfo[\"file\"].name;\n    var streamedContent = this.streamFiles && !streamInfo[\"file\"].dir;\n    // don't stream folders (because they don't have any content)\n    if (streamedContent) {\n        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n        this.push({\n            data: record.fileRecord,\n            meta: {\n                percent: 0\n            }\n        });\n    } else {\n        // we need to wait for the whole file before pushing anything\n        this.accumulate = true;\n    }\n};\n/**\n * The worker finished a source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the finished source.\n */ ZipFileWorker.prototype.closedSource = function(streamInfo) {\n    this.accumulate = false;\n    var streamedContent = this.streamFiles && !streamInfo[\"file\"].dir;\n    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n    this.dirRecords.push(record.dirRecord);\n    if (streamedContent) {\n        // after the streamed file, we put data descriptors\n        this.push({\n            data: generateDataDescriptors(streamInfo),\n            meta: {\n                percent: 100\n            }\n        });\n    } else {\n        // the content wasn't streamed, we need to push everything now\n        // first the file record, then the content\n        this.push({\n            data: record.fileRecord,\n            meta: {\n                percent: 0\n            }\n        });\n        while(this.contentBuffer.length){\n            this.push(this.contentBuffer.shift());\n        }\n    }\n    this.currentFile = null;\n};\n/**\n * @see GenericWorker.flush\n */ ZipFileWorker.prototype.flush = function() {\n    var localDirLength = this.bytesWritten;\n    for(var i = 0; i < this.dirRecords.length; i++){\n        this.push({\n            data: this.dirRecords[i],\n            meta: {\n                percent: 100\n            }\n        });\n    }\n    var centralDirLength = this.bytesWritten - localDirLength;\n    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);\n    this.push({\n        data: dirEnd,\n        meta: {\n            percent: 100\n        }\n    });\n};\n/**\n * Prepare the next source to be read.\n */ ZipFileWorker.prototype.prepareNextSource = function() {\n    this.previous = this._sources.shift();\n    this.openedSource(this.previous.streamInfo);\n    if (this.isPaused) {\n        this.previous.pause();\n    } else {\n        this.previous.resume();\n    }\n};\n/**\n * @see GenericWorker.registerPrevious\n */ ZipFileWorker.prototype.registerPrevious = function(previous) {\n    this._sources.push(previous);\n    var self = this;\n    previous.on(\"data\", function(chunk) {\n        self.processChunk(chunk);\n    });\n    previous.on(\"end\", function() {\n        self.closedSource(self.previous.streamInfo);\n        if (self._sources.length) {\n            self.prepareNextSource();\n        } else {\n            self.end();\n        }\n    });\n    previous.on(\"error\", function(e) {\n        self.error(e);\n    });\n    return this;\n};\n/**\n * @see GenericWorker.resume\n */ ZipFileWorker.prototype.resume = function() {\n    if (!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n    if (!this.previous && this._sources.length) {\n        this.prepareNextSource();\n        return true;\n    }\n    if (!this.previous && !this._sources.length && !this.generatedError) {\n        this.end();\n        return true;\n    }\n};\n/**\n * @see GenericWorker.error\n */ ZipFileWorker.prototype.error = function(e) {\n    var sources = this._sources;\n    if (!GenericWorker.prototype.error.call(this, e)) {\n        return false;\n    }\n    for(var i = 0; i < sources.length; i++){\n        try {\n            sources[i].error(e);\n        } catch (e) {\n        // the `error` exploded, nothing to do\n        }\n    }\n    return true;\n};\n/**\n * @see GenericWorker.lock\n */ ZipFileWorker.prototype.lock = function() {\n    GenericWorker.prototype.lock.call(this);\n    var sources = this._sources;\n    for(var i = 0; i < sources.length; i++){\n        sources[i].lock();\n    }\n};\nmodule.exports = ZipFileWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL1ppcEZpbGVXb3JrZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQyx5REFBVTtBQUM5QixJQUFJQyxnQkFBZ0JELG1CQUFPQSxDQUFDLHVGQUF5QjtBQUNyRCxJQUFJRSxPQUFPRixtQkFBT0EsQ0FBQyx1REFBUztBQUM1QixJQUFJRyxRQUFRSCxtQkFBT0EsQ0FBQyx5REFBVTtBQUM5QixJQUFJSSxZQUFZSixtQkFBT0EsQ0FBQyxpRUFBYztBQUV0Qzs7Ozs7O0NBTUMsR0FDRCxJQUFJSyxXQUFXLFNBQVNDLEdBQUcsRUFBRUMsS0FBSztJQUM5QixJQUFJQyxNQUFNLElBQUlDO0lBQ2QsSUFBS0EsSUFBSSxHQUFHQSxJQUFJRixPQUFPRSxJQUFLO1FBQ3hCRCxPQUFPRSxPQUFPQyxZQUFZLENBQUNMLE1BQU07UUFDakNBLE1BQU1BLFFBQVE7SUFDbEI7SUFDQSxPQUFPRTtBQUNYO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDRCxJQUFJSSwrQkFBK0IsU0FBVUMsZUFBZSxFQUFFQyxLQUFLO0lBRS9ELElBQUlDLFNBQVNGO0lBQ2IsSUFBSSxDQUFDQSxpQkFBaUI7UUFDbEIsMkRBQTJEO1FBQzNELG9CQUFvQjtRQUNwQixvQkFBb0I7UUFDcEJFLFNBQVNELFFBQVEsU0FBUztJQUM5QjtJQUNBLE9BQU8sQ0FBQ0MsU0FBUyxNQUFLLEtBQU07QUFDaEM7QUFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxJQUFJQyw4QkFBOEIsU0FBVUMsY0FBYztJQUN0RCxnREFBZ0Q7SUFDaEQsT0FBTyxDQUFDQSxrQkFBa0IsS0FBTTtBQUNwQztBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNELElBQUlDLG1CQUFtQixTQUFTQyxVQUFVLEVBQUVDLGVBQWUsRUFBRUMsY0FBYyxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsY0FBYztJQUN6RyxJQUFJQyxPQUFPTixVQUFV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QyxVQUFVLElBQUksQ0FBQzVCLFFBQVE7SUFDM0IsSUFBSSxJQUFJM0UsSUFBSSxHQUFHQSxJQUFJdUcsUUFBUTNFLE1BQU0sRUFBRTVCLElBQUs7UUFDcEN1RyxPQUFPLENBQUN2RyxFQUFFLENBQUN3RyxJQUFJO0lBQ25CO0FBQ0o7QUFFQUMsT0FBT0MsT0FBTyxHQUFHMUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcHR4LW9wdGltaXplci8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvZ2VuZXJhdGUvWmlwRmlsZVdvcmtlci5qcz81ZTM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcbnZhciB1dGY4ID0gcmVxdWlyZShcIi4uL3V0ZjhcIik7XG52YXIgY3JjMzIgPSByZXF1aXJlKFwiLi4vY3JjMzJcIik7XG52YXIgc2lnbmF0dXJlID0gcmVxdWlyZShcIi4uL3NpZ25hdHVyZVwiKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gaW50ZWdlciBpbnRvIGEgc3RyaW5nIGluIGhleGFkZWNpbWFsLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWMgdGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcmVzdWx0LlxuICovXG52YXIgZGVjVG9IZXggPSBmdW5jdGlvbihkZWMsIGJ5dGVzKSB7XG4gICAgdmFyIGhleCA9IFwiXCIsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGVjICYgMHhmZik7XG4gICAgICAgIGRlYyA9IGRlYyA+Pj4gODtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIFVOSVggcGFydCBvZiB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtPYmplY3R9IHVuaXhQZXJtaXNzaW9ucyB0aGUgdW5peCBwZXJtaXNzaW9ucyBvciBudWxsLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0RpciB0cnVlIGlmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHJldHVybiB7TnVtYmVyfSBhIDMyIGJpdCBpbnRlZ2VyLlxuICpcbiAqIGFkYXB0ZWQgZnJvbSBodHRwOi8vdW5peC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTQ3MDUvdGhlLXppcC1mb3JtYXRzLWV4dGVybmFsLWZpbGUtYXR0cmlidXRlIDpcbiAqXG4gKiBUVFRUc3N0cnd4cnd4cnd4MDAwMDAwMDAwMEFEVlNIUlxuICogXl5eXl9fX19fX19fX19fX19fX19fX19fX19fX19fX18gZmlsZSB0eXBlLCBzZWUgemlwaW5mby5jIChVTlhfKilcbiAqICAgICBeXl5fX19fX19fX19fX19fX19fX19fX19fX19fIHNldHVpZCwgc2V0Z2lkLCBzdGlja3lcbiAqICAgICAgICBeXl5eXl5eXl5fX19fX19fX19fX19fX19fIHBlcm1pc3Npb25zXG4gKiAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl9fX19fXyBub3QgdXNlZCA/XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXiBET1MgYXR0cmlidXRlIGJpdHMgOiBBcmNoaXZlLCBEaXJlY3RvcnksIFZvbHVtZSBsYWJlbCwgU3lzdGVtIGZpbGUsIEhpZGRlbiwgUmVhZCBvbmx5XG4gKi9cbnZhciBnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyID0gZnVuY3Rpb24gKHVuaXhQZXJtaXNzaW9ucywgaXNEaXIpIHtcblxuICAgIHZhciByZXN1bHQgPSB1bml4UGVybWlzc2lvbnM7XG4gICAgaWYgKCF1bml4UGVybWlzc2lvbnMpIHtcbiAgICAgICAgLy8gSSBjYW4ndCB1c2Ugb2N0YWwgdmFsdWVzIGluIHN0cmljdCBtb2RlLCBoZW5jZSB0aGUgaGV4YS5cbiAgICAgICAgLy8gIDA0MDc3NSA9PiAweDQxZmRcbiAgICAgICAgLy8gMDEwMDY2NCA9PiAweDgxYjRcbiAgICAgICAgcmVzdWx0ID0gaXNEaXIgPyAweDQxZmQgOiAweDgxYjQ7XG4gICAgfVxuICAgIHJldHVybiAocmVzdWx0ICYgMHhGRkZGKSA8PCAxNjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIERPUyBwYXJ0IG9mIHRoZSBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gZG9zUGVybWlzc2lvbnMgdGhlIGRvcyBwZXJtaXNzaW9ucyBvciBudWxsLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0RpciB0cnVlIGlmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHJldHVybiB7TnVtYmVyfSBhIDMyIGJpdCBpbnRlZ2VyLlxuICpcbiAqIEJpdCAwICAgICBSZWFkLU9ubHlcbiAqIEJpdCAxICAgICBIaWRkZW5cbiAqIEJpdCAyICAgICBTeXN0ZW1cbiAqIEJpdCAzICAgICBWb2x1bWUgTGFiZWxcbiAqIEJpdCA0ICAgICBEaXJlY3RvcnlcbiAqIEJpdCA1ICAgICBBcmNoaXZlXG4gKi9cbnZhciBnZW5lcmF0ZURvc0V4dGVybmFsRmlsZUF0dHIgPSBmdW5jdGlvbiAoZG9zUGVybWlzc2lvbnMpIHtcbiAgICAvLyB0aGUgZGlyIGZsYWcgaXMgYWxyZWFkeSBzZXQgZm9yIGNvbXBhdGliaWxpdHlcbiAgICByZXR1cm4gKGRvc1Blcm1pc3Npb25zIHx8IDApICAmIDB4M0Y7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSB2YXJpb3VzIHBhcnRzIHVzZWQgaW4gdGhlIGNvbnN0cnVjdGlvbiBvZiB0aGUgZmluYWwgemlwIGZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgaGFzaCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb21wcmVzc2VkIGZpbGUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN0cmVhbWVkQ29udGVudCBpcyB0aGUgY29udGVudCBzdHJlYW1lZCA/XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN0cmVhbWluZ0VuZGVkIGlzIHRoZSBzdHJlYW0gZmluaXNoZWQgP1xuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCB0aGUgY3VycmVudCBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHppcCBmaWxlLlxuICogQHBhcmFtIHtTdHJpbmd9IHBsYXRmb3JtIGxldCdzIHByZXRlbmQgd2UgYXJlIHRoaXMgcGxhdGZvcm0gKGNoYW5nZSBwbGF0Zm9ybSBkZXBlbmRlbnRzIGZpZWxkcylcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZUZpbGVOYW1lIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgdGhlIGZpbGUgbmFtZSAvIGNvbW1lbnQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSB6aXAgcGFydHMuXG4gKi9cbnZhciBnZW5lcmF0ZVppcFBhcnRzID0gZnVuY3Rpb24oc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCBzdHJlYW1pbmdFbmRlZCwgb2Zmc2V0LCBwbGF0Zm9ybSwgZW5jb2RlRmlsZU5hbWUpIHtcbiAgICB2YXIgZmlsZSA9IHN0cmVhbUluZm9bXCJmaWxlXCJdLFxuICAgICAgICBjb21wcmVzc2lvbiA9IHN0cmVhbUluZm9bXCJjb21wcmVzc2lvblwiXSxcbiAgICAgICAgdXNlQ3VzdG9tRW5jb2RpbmcgPSBlbmNvZGVGaWxlTmFtZSAhPT0gdXRmOC51dGY4ZW5jb2RlLFxuICAgICAgICBlbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShmaWxlLm5hbWUpKSxcbiAgICAgICAgdXRmRW5jb2RlZEZpbGVOYW1lID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdXRmOC51dGY4ZW5jb2RlKGZpbGUubmFtZSkpLFxuICAgICAgICBjb21tZW50ID0gZmlsZS5jb21tZW50LFxuICAgICAgICBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGNvbW1lbnQpKSxcbiAgICAgICAgdXRmRW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoY29tbWVudCkpLFxuICAgICAgICB1c2VVVEY4Rm9yRmlsZU5hbWUgPSB1dGZFbmNvZGVkRmlsZU5hbWUubGVuZ3RoICE9PSBmaWxlLm5hbWUubGVuZ3RoLFxuICAgICAgICB1c2VVVEY4Rm9yQ29tbWVudCA9IHV0ZkVuY29kZWRDb21tZW50Lmxlbmd0aCAhPT0gY29tbWVudC5sZW5ndGgsXG4gICAgICAgIGRvc1RpbWUsXG4gICAgICAgIGRvc0RhdGUsXG4gICAgICAgIGV4dHJhRmllbGRzID0gXCJcIixcbiAgICAgICAgdW5pY29kZVBhdGhFeHRyYUZpZWxkID0gXCJcIixcbiAgICAgICAgdW5pY29kZUNvbW1lbnRFeHRyYUZpZWxkID0gXCJcIixcbiAgICAgICAgZGlyID0gZmlsZS5kaXIsXG4gICAgICAgIGRhdGUgPSBmaWxlLmRhdGU7XG5cblxuICAgIHZhciBkYXRhSW5mbyA9IHtcbiAgICAgICAgY3JjMzIgOiAwLFxuICAgICAgICBjb21wcmVzc2VkU2l6ZSA6IDAsXG4gICAgICAgIHVuY29tcHJlc3NlZFNpemUgOiAwXG4gICAgfTtcblxuICAgIC8vIGlmIHRoZSBjb250ZW50IGlzIHN0cmVhbWVkLCB0aGUgc2l6ZXMvY3JjMzIgYXJlIG9ubHkgYXZhaWxhYmxlIEFGVEVSXG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgc3RyZWFtLlxuICAgIGlmICghc3RyZWFtZWRDb250ZW50IHx8IHN0cmVhbWluZ0VuZGVkKSB7XG4gICAgICAgIGRhdGFJbmZvLmNyYzMyID0gc3RyZWFtSW5mb1tcImNyYzMyXCJdO1xuICAgICAgICBkYXRhSW5mby5jb21wcmVzc2VkU2l6ZSA9IHN0cmVhbUluZm9bXCJjb21wcmVzc2VkU2l6ZVwiXTtcbiAgICAgICAgZGF0YUluZm8udW5jb21wcmVzc2VkU2l6ZSA9IHN0cmVhbUluZm9bXCJ1bmNvbXByZXNzZWRTaXplXCJdO1xuICAgIH1cblxuICAgIHZhciBiaXRmbGFnID0gMDtcbiAgICBpZiAoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIC8vIEJpdCAzOiB0aGUgc2l6ZXMvY3JjMzIgYXJlIHNldCB0byB6ZXJvIGluIHRoZSBsb2NhbCBoZWFkZXIuXG4gICAgICAgIC8vIFRoZSBjb3JyZWN0IHZhbHVlcyBhcmUgcHV0IGluIHRoZSBkYXRhIGRlc2NyaXB0b3IgaW1tZWRpYXRlbHlcbiAgICAgICAgLy8gZm9sbG93aW5nIHRoZSBjb21wcmVzc2VkIGRhdGEuXG4gICAgICAgIGJpdGZsYWcgfD0gMHgwMDA4O1xuICAgIH1cbiAgICBpZiAoIXVzZUN1c3RvbUVuY29kaW5nICYmICh1c2VVVEY4Rm9yRmlsZU5hbWUgfHwgdXNlVVRGOEZvckNvbW1lbnQpKSB7XG4gICAgICAgIC8vIEJpdCAxMTogTGFuZ3VhZ2UgZW5jb2RpbmcgZmxhZyAoRUZTKS5cbiAgICAgICAgYml0ZmxhZyB8PSAweDA4MDA7XG4gICAgfVxuXG5cbiAgICB2YXIgZXh0RmlsZUF0dHIgPSAwO1xuICAgIHZhciB2ZXJzaW9uTWFkZUJ5ID0gMDtcbiAgICBpZiAoZGlyKSB7XG4gICAgICAgIC8vIGRvcyBvciB1bml4LCB3ZSBzZXQgdGhlIGRvcyBkaXIgZmxhZ1xuICAgICAgICBleHRGaWxlQXR0ciB8PSAweDAwMDEwO1xuICAgIH1cbiAgICBpZihwbGF0Zm9ybSA9PT0gXCJVTklYXCIpIHtcbiAgICAgICAgdmVyc2lvbk1hZGVCeSA9IDB4MDMxRTsgLy8gVU5JWCwgdmVyc2lvbiAzLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0cihmaWxlLnVuaXhQZXJtaXNzaW9ucywgZGlyKTtcbiAgICB9IGVsc2UgeyAvLyBET1Mgb3Igb3RoZXIsIGZhbGxiYWNrIHRvIERPU1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMDE0OyAvLyBET1MsIHZlcnNpb24gMi4wXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IGdlbmVyYXRlRG9zRXh0ZXJuYWxGaWxlQXR0cihmaWxlLmRvc1Blcm1pc3Npb25zLCBkaXIpO1xuICAgIH1cblxuICAgIC8vIGRhdGVcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNTIvMTMuaHRtbFxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC82NS8xNi5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY2LzE2Lmh0bWxcblxuICAgIGRvc1RpbWUgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNjtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0VVRDTWludXRlcygpO1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIDw8IDU7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgfCBkYXRlLmdldFVUQ1NlY29uZHMoKSAvIDI7XG5cbiAgICBkb3NEYXRlID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpIC0gMTk4MDtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSA8PCA0O1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIHwgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDU7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCBkYXRlLmdldFVUQ0RhdGUoKTtcblxuICAgIGlmICh1c2VVVEY4Rm9yRmlsZU5hbWUpIHtcbiAgICAgICAgLy8gc2V0IHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuIHVuemlwIG5lZWRzIGF0IGxlYXN0IG9uZSBleHRyYVxuICAgICAgICAvLyBmaWVsZCB0byBjb3JyZWN0bHkgaGFuZGxlIHVuaWNvZGUgcGF0aCwgc28gdXNpbmcgdGhlIHBhdGggaXMgYXMgZ29vZFxuICAgICAgICAvLyBhcyBhbnkgb3RoZXIgaW5mb3JtYXRpb24uIFRoaXMgY291bGQgaW1wcm92ZSB0aGUgc2l0dWF0aW9uIHdpdGhcbiAgICAgICAgLy8gb3RoZXIgYXJjaGl2ZSBtYW5hZ2VycyB0b28uXG4gICAgICAgIC8vIFRoaXMgZmllbGQgaXMgdXN1YWxseSB1c2VkIHdpdGhvdXQgdGhlIHV0ZjggZmxhZywgd2l0aCBhIG5vblxuICAgICAgICAvLyB1bmljb2RlIHBhdGggaW4gdGhlIGhlYWRlciAod2lucmFyLCB3aW56aXApLiBUaGlzIGhlbHBzIChhIGJpdClcbiAgICAgICAgLy8gd2l0aCB0aGUgbWVzc3kgV2luZG93cycgZGVmYXVsdCBjb21wcmVzc2VkIGZvbGRlcnMgZmVhdHVyZSBidXRcbiAgICAgICAgLy8gYnJlYWtzIG9uIHA3emlwIHdoaWNoIGRvZXNuJ3Qgc2VlayB0aGUgdW5pY29kZSBwYXRoIGV4dHJhIGZpZWxkLlxuICAgICAgICAvLyBTbyBmb3Igbm93LCBVVEYtOCBldmVyeXdoZXJlICFcbiAgICAgICAgdW5pY29kZVBhdGhFeHRyYUZpZWxkID1cbiAgICAgICAgICAgIC8vIFZlcnNpb25cbiAgICAgICAgICAgIGRlY1RvSGV4KDEsIDEpICtcbiAgICAgICAgICAgIC8vIE5hbWVDUkMzMlxuICAgICAgICAgICAgZGVjVG9IZXgoY3JjMzIoZW5jb2RlZEZpbGVOYW1lKSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRGaWxlTmFtZTtcblxuICAgICAgICBleHRyYUZpZWxkcyArPVxuICAgICAgICAgICAgLy8gSW5mby1aSVAgVW5pY29kZSBQYXRoIEV4dHJhIEZpZWxkXG4gICAgICAgICAgICBcIlxceDc1XFx4NzBcIiArXG4gICAgICAgICAgICAvLyBzaXplXG4gICAgICAgICAgICBkZWNUb0hleCh1bmljb2RlUGF0aEV4dHJhRmllbGQubGVuZ3RoLCAyKSArXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQ7XG4gICAgfVxuXG4gICAgaWYodXNlVVRGOEZvckNvbW1lbnQpIHtcblxuICAgICAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gQ29tbWVudENSQzMyXG4gICAgICAgICAgICBkZWNUb0hleChjcmMzMihlbmNvZGVkQ29tbWVudCksIDQpICtcbiAgICAgICAgICAgIC8vIFVuaWNvZGVOYW1lXG4gICAgICAgICAgICB1dGZFbmNvZGVkQ29tbWVudDtcblxuICAgICAgICBleHRyYUZpZWxkcyArPVxuICAgICAgICAgICAgLy8gSW5mby1aSVAgVW5pY29kZSBQYXRoIEV4dHJhIEZpZWxkXG4gICAgICAgICAgICBcIlxceDc1XFx4NjNcIiArXG4gICAgICAgICAgICAvLyBzaXplXG4gICAgICAgICAgICBkZWNUb0hleCh1bmljb2RlQ29tbWVudEV4dHJhRmllbGQubGVuZ3RoLCAyKSArXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQ7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlciA9IFwiXCI7XG5cbiAgICAvLyB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0XG4gICAgaGVhZGVyICs9IFwiXFx4MEFcXHgwMFwiO1xuICAgIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuICAgIGhlYWRlciArPSBkZWNUb0hleChiaXRmbGFnLCAyKTtcbiAgICAvLyBjb21wcmVzc2lvbiBtZXRob2RcbiAgICBoZWFkZXIgKz0gY29tcHJlc3Npb24ubWFnaWM7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSB0aW1lXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc1RpbWUsIDIpO1xuICAgIC8vIGxhc3QgbW9kIGZpbGUgZGF0ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkb3NEYXRlLCAyKTtcbiAgICAvLyBjcmMtMzJcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZGF0YUluZm8uY3JjMzIsIDQpO1xuICAgIC8vIGNvbXByZXNzZWQgc2l6ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby5jb21wcmVzc2VkU2l6ZSwgNCk7XG4gICAgLy8gdW5jb21wcmVzc2VkIHNpemVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZGF0YUluZm8udW5jb21wcmVzc2VkU2l6ZSwgNCk7XG4gICAgLy8gZmlsZSBuYW1lIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChlbmNvZGVkRmlsZU5hbWUubGVuZ3RoLCAyKTtcbiAgICAvLyBleHRyYSBmaWVsZCBsZW5ndGhcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZXh0cmFGaWVsZHMubGVuZ3RoLCAyKTtcblxuXG4gICAgdmFyIGZpbGVSZWNvcmQgPSBzaWduYXR1cmUuTE9DQUxfRklMRV9IRUFERVIgKyBoZWFkZXIgKyBlbmNvZGVkRmlsZU5hbWUgKyBleHRyYUZpZWxkcztcblxuICAgIHZhciBkaXJSZWNvcmQgPSBzaWduYXR1cmUuQ0VOVFJBTF9GSUxFX0hFQURFUiArXG4gICAgICAgIC8vIHZlcnNpb24gbWFkZSBieSAoMDA6IERPUylcbiAgICAgICAgZGVjVG9IZXgodmVyc2lvbk1hZGVCeSwgMikgK1xuICAgICAgICAvLyBmaWxlIGhlYWRlciAoY29tbW9uIHRvIGZpbGUgYW5kIGNlbnRyYWwgZGlyZWN0b3J5KVxuICAgICAgICBoZWFkZXIgK1xuICAgICAgICAvLyBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyBkaXNrIG51bWJlciBzdGFydFxuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIGludGVybmFsIGZpbGUgYXR0cmlidXRlcyBUT0RPXG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzXG4gICAgICAgIGRlY1RvSGV4KGV4dEZpbGVBdHRyLCA0KSArXG4gICAgICAgIC8vIHJlbGF0aXZlIG9mZnNldCBvZiBsb2NhbCBoZWFkZXJcbiAgICAgICAgZGVjVG9IZXgob2Zmc2V0LCA0KSArXG4gICAgICAgIC8vIGZpbGUgbmFtZVxuICAgICAgICBlbmNvZGVkRmlsZU5hbWUgK1xuICAgICAgICAvLyBleHRyYSBmaWVsZFxuICAgICAgICBleHRyYUZpZWxkcyArXG4gICAgICAgIC8vIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVSZWNvcmQ6IGZpbGVSZWNvcmQsXG4gICAgICAgIGRpclJlY29yZDogZGlyUmVjb3JkXG4gICAgfTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIEVPQ0QgcmVjb3JkLlxuICogQHBhcmFtIHtOdW1iZXJ9IGVudHJpZXNDb3VudCB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHppcCBmaWxlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNlbnRyYWxEaXJMZW5ndGggdGhlIGxlbmd0aCAoaW4gYnl0ZXMpIG9mIHRoZSBjZW50cmFsIGRpci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhbERpckxlbmd0aCB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIGxvY2FsIGRpci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSB6aXAgZmlsZSBjb21tZW50IGFzIGEgYmluYXJ5IHN0cmluZy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZUZpbGVOYW1lIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgdGhlIGNvbW1lbnQuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBFT0NEIHJlY29yZC5cbiAqL1xudmFyIGdlbmVyYXRlQ2VudHJhbERpcmVjdG9yeUVuZCA9IGZ1bmN0aW9uIChlbnRyaWVzQ291bnQsIGNlbnRyYWxEaXJMZW5ndGgsIGxvY2FsRGlyTGVuZ3RoLCBjb21tZW50LCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIHZhciBkaXJFbmQgPSBcIlwiO1xuICAgIHZhciBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGNvbW1lbnQpKTtcblxuICAgIC8vIGVuZCBvZiBjZW50cmFsIGRpciBzaWduYXR1cmVcbiAgICBkaXJFbmQgPSBzaWduYXR1cmUuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EICtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoaXMgZGlza1xuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIG51bWJlciBvZiB0aGUgZGlzayB3aXRoIHRoZSBzdGFydCBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3Rvcnkgb24gdGhpcyBkaXNrXG4gICAgICAgIGRlY1RvSGV4KGVudHJpZXNDb3VudCwgMikgK1xuICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgZGVjVG9IZXgoZW50cmllc0NvdW50LCAyKSArXG4gICAgICAgIC8vIHNpemUgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5ICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChjZW50cmFsRGlyTGVuZ3RoLCA0KSArXG4gICAgICAgIC8vIG9mZnNldCBvZiBzdGFydCBvZiBjZW50cmFsIGRpcmVjdG9yeSB3aXRoIHJlc3BlY3QgdG8gdGhlIHN0YXJ0aW5nIGRpc2sgbnVtYmVyXG4gICAgICAgIGRlY1RvSGV4KGxvY2FsRGlyTGVuZ3RoLCA0KSArXG4gICAgICAgIC8vIC5aSVAgZmlsZSBjb21tZW50IGxlbmd0aFxuICAgICAgICBkZWNUb0hleChlbmNvZGVkQ29tbWVudC5sZW5ndGgsIDIpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnRcbiAgICAgICAgZW5jb2RlZENvbW1lbnQ7XG5cbiAgICByZXR1cm4gZGlyRW5kO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBkYXRhIGRlc2NyaXB0b3JzIGZvciBhIGZpbGUgZW50cnkuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgaGFzaCBnZW5lcmF0ZWQgYnkgYSB3b3JrZXIsIGNvbnRhaW5pbmcgaW5mb3JtYXRpb25cbiAqIG9uIHRoZSBmaWxlIGVudHJ5LlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZGF0YSBkZXNjcmlwdG9ycy5cbiAqL1xudmFyIGdlbmVyYXRlRGF0YURlc2NyaXB0b3JzID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IFwiXCI7XG4gICAgZGVzY3JpcHRvciA9IHNpZ25hdHVyZS5EQVRBX0RFU0NSSVBUT1IgK1xuICAgICAgICAvLyBjcmMtMzIgICAgICAgICAgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1tcImNyYzMyXCJdLCA0KSArXG4gICAgICAgIC8vIGNvbXByZXNzZWQgc2l6ZSAgICAgICAgICAgICAgICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChzdHJlYW1JbmZvW1wiY29tcHJlc3NlZFNpemVcIl0sIDQpICtcbiAgICAgICAgLy8gdW5jb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KHN0cmVhbUluZm9bXCJ1bmNvbXByZXNzZWRTaXplXCJdLCA0KTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxuXG4vKipcbiAqIEEgd29ya2VyIHRvIGNvbmNhdGVuYXRlIG90aGVyIHdvcmtlcnMgdG8gY3JlYXRlIGEgemlwIGZpbGUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN0cmVhbUZpbGVzIGB0cnVlYCB0byBzdHJlYW0gdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGVzLFxuICogYGZhbHNlYCB0byBhY2N1bXVsYXRlIGl0LlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIGNvbW1lbnQgdG8gdXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IHBsYXRmb3JtIHRoZSBwbGF0Zm9ybSB0byB1c2UsIFwiVU5JWFwiIG9yIFwiRE9TXCIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIGZpbGUgbmFtZXMgYW5kIGNvbW1lbnRzLlxuICovXG5mdW5jdGlvbiBaaXBGaWxlV29ya2VyKHN0cmVhbUZpbGVzLCBjb21tZW50LCBwbGF0Zm9ybSwgZW5jb2RlRmlsZU5hbWUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJaaXBGaWxlV29ya2VyXCIpO1xuICAgIC8vIFRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBzbyBmYXIuIFRoaXMgZG9lc24ndCBjb3VudCBhY2N1bXVsYXRlZCBjaHVua3MuXG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwO1xuICAgIC8vIFRoZSBjb21tZW50IG9mIHRoZSB6aXAgZmlsZVxuICAgIHRoaXMuemlwQ29tbWVudCA9IGNvbW1lbnQ7XG4gICAgLy8gVGhlIHBsYXRmb3JtIFwiZ2VuZXJhdGluZ1wiIHRoZSB6aXAgZmlsZS5cbiAgICB0aGlzLnppcFBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgLy8gdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBmaWxlIG5hbWVzIGFuZCBjb21tZW50cy5cbiAgICB0aGlzLmVuY29kZUZpbGVOYW1lID0gZW5jb2RlRmlsZU5hbWU7XG4gICAgLy8gU2hvdWxkIHdlIHN0cmVhbSB0aGUgY29udGVudCBvZiB0aGUgZmlsZXMgP1xuICAgIHRoaXMuc3RyZWFtRmlsZXMgPSBzdHJlYW1GaWxlcztcbiAgICAvLyBJZiBgc3RyZWFtRmlsZXNgIGlzIGZhbHNlLCB3ZSB3aWxsIG5lZWQgdG8gYWNjdW11bGF0ZSB0aGUgY29udGVudCBvZiB0aGVcbiAgICAvLyBmaWxlcyB0byBjYWxjdWxhdGUgc2l6ZXMgLyBjcmMzMiAoYW5kIHdyaXRlIHRoZW0gKmJlZm9yZSogdGhlIGNvbnRlbnQpLlxuICAgIC8vIFRoaXMgYm9vbGVhbiBpbmRpY2F0ZXMgaWYgd2UgYXJlIGFjY3VtdWxhdGluZyBjaHVua3MgKGl0IHdpbGwgY2hhbmdlIGEgbG90XG4gICAgLy8gZHVyaW5nIHRoZSBsaWZldGltZSBvZiB0aGlzIHdvcmtlcikuXG4gICAgdGhpcy5hY2N1bXVsYXRlID0gZmFsc2U7XG4gICAgLy8gVGhlIGJ1ZmZlciByZWNlaXZpbmcgY2h1bmtzIHdoZW4gYWNjdW11bGF0aW5nIGNvbnRlbnQuXG4gICAgdGhpcy5jb250ZW50QnVmZmVyID0gW107XG4gICAgLy8gVGhlIGxpc3Qgb2YgZ2VuZXJhdGVkIGRpcmVjdG9yeSByZWNvcmRzLlxuICAgIHRoaXMuZGlyUmVjb3JkcyA9IFtdO1xuICAgIC8vIFRoZSBvZmZzZXQgKGluIGJ5dGVzKSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHppcCBmaWxlIGZvciB0aGUgY3VycmVudCBzb3VyY2UuXG4gICAgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0ID0gMDtcbiAgICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyB6aXAgZmlsZS5cbiAgICB0aGlzLmVudHJpZXNDb3VudCA9IDA7XG4gICAgLy8gdGhlIG5hbWUgb2YgdGhlIGZpbGUgY3VycmVudGx5IGJlaW5nIGFkZGVkLCBudWxsIHdoZW4gaGFuZGxpbmcgdGhlIGVuZCBvZiB0aGUgemlwIGZpbGUuXG4gICAgLy8gVXNlZCBmb3IgdGhlIGVtaXR0ZWQgbWV0YWRhdGEuXG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IG51bGw7XG5cblxuXG4gICAgdGhpcy5fc291cmNlcyA9IFtdO1xufVxudXRpbHMuaW5oZXJpdHMoWmlwRmlsZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnB1c2hcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaykge1xuXG4gICAgdmFyIGN1cnJlbnRGaWxlUGVyY2VudCA9IGNodW5rLm1ldGEucGVyY2VudCB8fCAwO1xuICAgIHZhciBlbnRyaWVzQ291bnQgPSB0aGlzLmVudHJpZXNDb3VudDtcbiAgICB2YXIgcmVtYWluaW5nRmlsZXMgPSB0aGlzLl9zb3VyY2VzLmxlbmd0aDtcblxuICAgIGlmKHRoaXMuYWNjdW11bGF0ZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnRCdWZmZXIucHVzaChjaHVuayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ieXRlc1dyaXR0ZW4gKz0gY2h1bmsuZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGRhdGEgOiBjaHVuay5kYXRhLFxuICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RmlsZSA6IHRoaXMuY3VycmVudEZpbGUsXG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IGVudHJpZXNDb3VudCA/IChjdXJyZW50RmlsZVBlcmNlbnQgKyAxMDAgKiAoZW50cmllc0NvdW50IC0gcmVtYWluaW5nRmlsZXMgLSAxKSkgLyBlbnRyaWVzQ291bnQgOiAxMDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIHN0YXJ0ZWQgYSBuZXcgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIG5ldyBzb3VyY2UuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLm9wZW5lZFNvdXJjZSA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0ID0gdGhpcy5ieXRlc1dyaXR0ZW47XG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IHN0cmVhbUluZm9bXCJmaWxlXCJdLm5hbWU7XG5cbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1tcImZpbGVcIl0uZGlyO1xuXG4gICAgLy8gZG9uJ3Qgc3RyZWFtIGZvbGRlcnMgKGJlY2F1c2UgdGhleSBkb24ndCBoYXZlIGFueSBjb250ZW50KVxuICAgIGlmKHN0cmVhbWVkQ29udGVudCkge1xuICAgICAgICB2YXIgcmVjb3JkID0gZ2VuZXJhdGVaaXBQYXJ0cyhzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIGZhbHNlLCB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQsIHRoaXMuemlwUGxhdGZvcm0sIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IHJlY29yZC5maWxlUmVjb3JkLFxuICAgICAgICAgICAgbWV0YSA6IHtwZXJjZW50OjB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIHdob2xlIGZpbGUgYmVmb3JlIHB1c2hpbmcgYW55dGhpbmdcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRlID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSB3b3JrZXIgZmluaXNoZWQgYSBzb3VyY2UgKGFuIG90aGVyIHdvcmtlcikuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgc3RyZWFtSW5mbyBvYmplY3QgZnJvbSB0aGUgZmluaXNoZWQgc291cmNlLlxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5jbG9zZWRTb3VyY2UgPSBmdW5jdGlvbiAoc3RyZWFtSW5mbykge1xuICAgIHRoaXMuYWNjdW11bGF0ZSA9IGZhbHNlO1xuICAgIHZhciBzdHJlYW1lZENvbnRlbnQgPSB0aGlzLnN0cmVhbUZpbGVzICYmICFzdHJlYW1JbmZvW1wiZmlsZVwiXS5kaXI7XG4gICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCB0cnVlLCB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQsIHRoaXMuemlwUGxhdGZvcm0sIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuXG4gICAgdGhpcy5kaXJSZWNvcmRzLnB1c2gocmVjb3JkLmRpclJlY29yZCk7XG4gICAgaWYoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIC8vIGFmdGVyIHRoZSBzdHJlYW1lZCBmaWxlLCB3ZSBwdXQgZGF0YSBkZXNjcmlwdG9yc1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGdlbmVyYXRlRGF0YURlc2NyaXB0b3JzKHN0cmVhbUluZm8pLFxuICAgICAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlIGNvbnRlbnQgd2Fzbid0IHN0cmVhbWVkLCB3ZSBuZWVkIHRvIHB1c2ggZXZlcnl0aGluZyBub3dcbiAgICAgICAgLy8gZmlyc3QgdGhlIGZpbGUgcmVjb3JkLCB0aGVuIHRoZSBjb250ZW50XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogcmVjb3JkLmZpbGVSZWNvcmQsXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlKHRoaXMuY29udGVudEJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmNvbnRlbnRCdWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5mbHVzaFxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBsb2NhbERpckxlbmd0aCA9IHRoaXMuYnl0ZXNXcml0dGVuO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRpclJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiB0aGlzLmRpclJlY29yZHNbaV0sXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGNlbnRyYWxEaXJMZW5ndGggPSB0aGlzLmJ5dGVzV3JpdHRlbiAtIGxvY2FsRGlyTGVuZ3RoO1xuXG4gICAgdmFyIGRpckVuZCA9IGdlbmVyYXRlQ2VudHJhbERpcmVjdG9yeUVuZCh0aGlzLmRpclJlY29yZHMubGVuZ3RoLCBjZW50cmFsRGlyTGVuZ3RoLCBsb2NhbERpckxlbmd0aCwgdGhpcy56aXBDb21tZW50LCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcblxuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiBkaXJFbmQsXG4gICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFByZXBhcmUgdGhlIG5leHQgc291cmNlIHRvIGJlIHJlYWQuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnByZXBhcmVOZXh0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJldmlvdXMgPSB0aGlzLl9zb3VyY2VzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuZWRTb3VyY2UodGhpcy5wcmV2aW91cy5zdHJlYW1JbmZvKTtcbiAgICBpZiAodGhpcy5pc1BhdXNlZCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzLnBhdXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cy5yZXN1bWUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5yZWdpc3RlclByZXZpb3VzXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnJlZ2lzdGVyUHJldmlvdXMgPSBmdW5jdGlvbiAocHJldmlvdXMpIHtcbiAgICB0aGlzLl9zb3VyY2VzLnB1c2gocHJldmlvdXMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHByZXZpb3VzLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgIH0pO1xuICAgIHByZXZpb3VzLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5jbG9zZWRTb3VyY2Uoc2VsZi5wcmV2aW91cy5zdHJlYW1JbmZvKTtcbiAgICAgICAgaWYoc2VsZi5fc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNlbGYucHJlcGFyZU5leHRTb3VyY2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBwcmV2aW91cy5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5yZXN1bWVcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByZXZpb3VzICYmIHRoaXMuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZU5leHRTb3VyY2UoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghdGhpcy5wcmV2aW91cyAmJiAhdGhpcy5fc291cmNlcy5sZW5ndGggJiYgIXRoaXMuZ2VuZXJhdGVkRXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZXJyb3JcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzb3VyY2VzID0gdGhpcy5fc291cmNlcztcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzb3VyY2VzW2ldLmVycm9yKGUpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIC8vIHRoZSBgZXJyb3JgIGV4cGxvZGVkLCBub3RoaW5nIHRvIGRvXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5sb2NrXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUubG9jay5jYWxsKHRoaXMpO1xuICAgIHZhciBzb3VyY2VzID0gdGhpcy5fc291cmNlcztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzb3VyY2VzW2ldLmxvY2soKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFppcEZpbGVXb3JrZXI7XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiR2VuZXJpY1dvcmtlciIsInV0ZjgiLCJjcmMzMiIsInNpZ25hdHVyZSIsImRlY1RvSGV4IiwiZGVjIiwiYnl0ZXMiLCJoZXgiLCJpIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0ciIsInVuaXhQZXJtaXNzaW9ucyIsImlzRGlyIiwicmVzdWx0IiwiZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyIiwiZG9zUGVybWlzc2lvbnMiLCJnZW5lcmF0ZVppcFBhcnRzIiwic3RyZWFtSW5mbyIsInN0cmVhbWVkQ29udGVudCIsInN0cmVhbWluZ0VuZGVkIiwib2Zmc2V0IiwicGxhdGZvcm0iLCJlbmNvZGVGaWxlTmFtZSIsImZpbGUiLCJjb21wcmVzc2lvbiIsInVzZUN1c3RvbUVuY29kaW5nIiwidXRmOGVuY29kZSIsImVuY29kZWRGaWxlTmFtZSIsInRyYW5zZm9ybVRvIiwibmFtZSIsInV0ZkVuY29kZWRGaWxlTmFtZSIsImNvbW1lbnQiLCJlbmNvZGVkQ29tbWVudCIsInV0ZkVuY29kZWRDb21tZW50IiwidXNlVVRGOEZvckZpbGVOYW1lIiwibGVuZ3RoIiwidXNlVVRGOEZvckNvbW1lbnQiLCJkb3NUaW1lIiwiZG9zRGF0ZSIsImV4dHJhRmllbGRzIiwidW5pY29kZVBhdGhFeHRyYUZpZWxkIiwidW5pY29kZUNvbW1lbnRFeHRyYUZpZWxkIiwiZGlyIiwiZGF0ZSIsImRhdGFJbmZvIiwiY29tcHJlc3NlZFNpemUiLCJ1bmNvbXByZXNzZWRTaXplIiwiYml0ZmxhZyIsImV4dEZpbGVBdHRyIiwidmVyc2lvbk1hZGVCeSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImhlYWRlciIsIm1hZ2ljIiwiZmlsZVJlY29yZCIsIkxPQ0FMX0ZJTEVfSEVBREVSIiwiZGlyUmVjb3JkIiwiQ0VOVFJBTF9GSUxFX0hFQURFUiIsImdlbmVyYXRlQ2VudHJhbERpcmVjdG9yeUVuZCIsImVudHJpZXNDb3VudCIsImNlbnRyYWxEaXJMZW5ndGgiLCJsb2NhbERpckxlbmd0aCIsImRpckVuZCIsIkNFTlRSQUxfRElSRUNUT1JZX0VORCIsImdlbmVyYXRlRGF0YURlc2NyaXB0b3JzIiwiZGVzY3JpcHRvciIsIkRBVEFfREVTQ1JJUFRPUiIsIlppcEZpbGVXb3JrZXIiLCJzdHJlYW1GaWxlcyIsImNhbGwiLCJieXRlc1dyaXR0ZW4iLCJ6aXBDb21tZW50IiwiemlwUGxhdGZvcm0iLCJhY2N1bXVsYXRlIiwiY29udGVudEJ1ZmZlciIsImRpclJlY29yZHMiLCJjdXJyZW50U291cmNlT2Zmc2V0IiwiY3VycmVudEZpbGUiLCJfc291cmNlcyIsImluaGVyaXRzIiwicHJvdG90eXBlIiwicHVzaCIsImNodW5rIiwiY3VycmVudEZpbGVQZXJjZW50IiwibWV0YSIsInBlcmNlbnQiLCJyZW1haW5pbmdGaWxlcyIsImRhdGEiLCJvcGVuZWRTb3VyY2UiLCJyZWNvcmQiLCJjbG9zZWRTb3VyY2UiLCJzaGlmdCIsImZsdXNoIiwicHJlcGFyZU5leHRTb3VyY2UiLCJwcmV2aW91cyIsImlzUGF1c2VkIiwicGF1c2UiLCJyZXN1bWUiLCJyZWdpc3RlclByZXZpb3VzIiwic2VsZiIsIm9uIiwicHJvY2Vzc0NodW5rIiwiZW5kIiwiZSIsImVycm9yIiwiZ2VuZXJhdGVkRXJyb3IiLCJzb3VyY2VzIiwibG9jayIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/generate/ZipFileWorker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/generate/index.js":
/*!**************************************************!*\
  !*** ./node_modules/jszip/lib/generate/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar compressions = __webpack_require__(/*! ../compressions */ \"(ssr)/./node_modules/jszip/lib/compressions.js\");\nvar ZipFileWorker = __webpack_require__(/*! ./ZipFileWorker */ \"(ssr)/./node_modules/jszip/lib/generate/ZipFileWorker.js\");\n/**\n * Find the compression to use.\n * @param {String} fileCompression the compression defined at the file level, if any.\n * @param {String} zipCompression the compression defined at the load() level.\n * @return {Object} the compression object to use.\n */ var getCompression = function(fileCompression, zipCompression) {\n    var compressionName = fileCompression || zipCompression;\n    var compression = compressions[compressionName];\n    if (!compression) {\n        throw new Error(compressionName + \" is not a valid compression method !\");\n    }\n    return compression;\n};\n/**\n * Create a worker to generate a zip file.\n * @param {JSZip} zip the JSZip instance at the right root level.\n * @param {Object} options to generate the zip file.\n * @param {String} comment the comment to use.\n */ exports.generateWorker = function(zip, options, comment) {\n    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\n    var entriesCount = 0;\n    try {\n        zip.forEach(function(relativePath, file) {\n            entriesCount++;\n            var compression = getCompression(file.options.compression, options.compression);\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n            var dir = file.dir, date = file.date;\n            file._compressWorker(compression, compressionOptions).withStreamInfo(\"file\", {\n                name: relativePath,\n                dir: dir,\n                date: date,\n                comment: file.comment || \"\",\n                unixPermissions: file.unixPermissions,\n                dosPermissions: file.dosPermissions\n            }).pipe(zipFileWorker);\n        });\n        zipFileWorker.entriesCount = entriesCount;\n    } catch (e) {\n        zipFileWorker.error(e);\n    }\n    return zipFileWorker;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsZUFBZUMsbUJBQU9BLENBQUMsdUVBQWlCO0FBQzVDLElBQUlDLGdCQUFnQkQsbUJBQU9BLENBQUMsaUZBQWlCO0FBRTdDOzs7OztDQUtDLEdBQ0QsSUFBSUUsaUJBQWlCLFNBQVVDLGVBQWUsRUFBRUMsY0FBYztJQUUxRCxJQUFJQyxrQkFBa0JGLG1CQUFtQkM7SUFDekMsSUFBSUUsY0FBY1AsWUFBWSxDQUFDTSxnQkFBZ0I7SUFDL0MsSUFBSSxDQUFDQyxhQUFhO1FBQ2QsTUFBTSxJQUFJQyxNQUFNRixrQkFBa0I7SUFDdEM7SUFDQSxPQUFPQztBQUNYO0FBRUE7Ozs7O0NBS0MsR0FDREUsc0JBQXNCLEdBQUcsU0FBVUUsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFFcEQsSUFBSUMsZ0JBQWdCLElBQUlaLGNBQWNVLFFBQVFHLFdBQVcsRUFBRUYsU0FBU0QsUUFBUUksUUFBUSxFQUFFSixRQUFRSyxjQUFjO0lBQzVHLElBQUlDLGVBQWU7SUFDbkIsSUFBSTtRQUVBUCxJQUFJUSxPQUFPLENBQUMsU0FBVUMsWUFBWSxFQUFFQyxJQUFJO1lBQ3BDSDtZQUNBLElBQUlYLGNBQWNKLGVBQWVrQixLQUFLVCxPQUFPLENBQUNMLFdBQVcsRUFBRUssUUFBUUwsV0FBVztZQUM5RSxJQUFJZSxxQkFBcUJELEtBQUtULE9BQU8sQ0FBQ1Usa0JBQWtCLElBQUlWLFFBQVFVLGtCQUFrQixJQUFJLENBQUM7WUFDM0YsSUFBSUMsTUFBTUYsS0FBS0UsR0FBRyxFQUFFQyxPQUFPSCxLQUFLRyxJQUFJO1lBRXBDSCxLQUFLSSxlQUFlLENBQUNsQixhQUFhZSxvQkFDN0JJLGNBQWMsQ0FBQyxRQUFRO2dCQUNwQkMsTUFBT1A7Z0JBQ1BHLEtBQU1BO2dCQUNOQyxNQUFPQTtnQkFDUFgsU0FBVVEsS0FBS1IsT0FBTyxJQUFJO2dCQUMxQmUsaUJBQWtCUCxLQUFLTyxlQUFlO2dCQUN0Q0MsZ0JBQWlCUixLQUFLUSxjQUFjO1lBQ3hDLEdBQ0NDLElBQUksQ0FBQ2hCO1FBQ2Q7UUFDQUEsY0FBY0ksWUFBWSxHQUFHQTtJQUNqQyxFQUFFLE9BQU9hLEdBQUc7UUFDUmpCLGNBQWNrQixLQUFLLENBQUNEO0lBQ3hCO0lBRUEsT0FBT2pCO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcHR4LW9wdGltaXplci8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvZ2VuZXJhdGUvaW5kZXguanM/NzUyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoXCIuLi9jb21wcmVzc2lvbnNcIik7XG52YXIgWmlwRmlsZVdvcmtlciA9IHJlcXVpcmUoXCIuL1ppcEZpbGVXb3JrZXJcIik7XG5cbi8qKlxuICogRmluZCB0aGUgY29tcHJlc3Npb24gdG8gdXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVDb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gZGVmaW5lZCBhdCB0aGUgZmlsZSBsZXZlbCwgaWYgYW55LlxuICogQHBhcmFtIHtTdHJpbmd9IHppcENvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBkZWZpbmVkIGF0IHRoZSBsb2FkKCkgbGV2ZWwuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBjb21wcmVzc2lvbiBvYmplY3QgdG8gdXNlLlxuICovXG52YXIgZ2V0Q29tcHJlc3Npb24gPSBmdW5jdGlvbiAoZmlsZUNvbXByZXNzaW9uLCB6aXBDb21wcmVzc2lvbikge1xuXG4gICAgdmFyIGNvbXByZXNzaW9uTmFtZSA9IGZpbGVDb21wcmVzc2lvbiB8fCB6aXBDb21wcmVzc2lvbjtcbiAgICB2YXIgY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbnNbY29tcHJlc3Npb25OYW1lXTtcbiAgICBpZiAoIWNvbXByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjb21wcmVzc2lvbk5hbWUgKyBcIiBpcyBub3QgYSB2YWxpZCBjb21wcmVzc2lvbiBtZXRob2QgIVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXByZXNzaW9uO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB3b3JrZXIgdG8gZ2VuZXJhdGUgYSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7SlNaaXB9IHppcCB0aGUgSlNaaXAgaW5zdGFuY2UgYXQgdGhlIHJpZ2h0IHJvb3QgbGV2ZWwuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29tbWVudCB0aGUgY29tbWVudCB0byB1c2UuXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVXb3JrZXIgPSBmdW5jdGlvbiAoemlwLCBvcHRpb25zLCBjb21tZW50KSB7XG5cbiAgICB2YXIgemlwRmlsZVdvcmtlciA9IG5ldyBaaXBGaWxlV29ya2VyKG9wdGlvbnMuc3RyZWFtRmlsZXMsIGNvbW1lbnQsIG9wdGlvbnMucGxhdGZvcm0sIG9wdGlvbnMuZW5jb2RlRmlsZU5hbWUpO1xuICAgIHZhciBlbnRyaWVzQ291bnQgPSAwO1xuICAgIHRyeSB7XG5cbiAgICAgICAgemlwLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgZW50cmllc0NvdW50Kys7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBnZXRDb21wcmVzc2lvbihmaWxlLm9wdGlvbnMuY29tcHJlc3Npb24sIG9wdGlvbnMuY29tcHJlc3Npb24pO1xuICAgICAgICAgICAgdmFyIGNvbXByZXNzaW9uT3B0aW9ucyA9IGZpbGUub3B0aW9ucy5jb21wcmVzc2lvbk9wdGlvbnMgfHwgb3B0aW9ucy5jb21wcmVzc2lvbk9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgZGlyID0gZmlsZS5kaXIsIGRhdGUgPSBmaWxlLmRhdGU7XG5cbiAgICAgICAgICAgIGZpbGUuX2NvbXByZXNzV29ya2VyKGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiZmlsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgOiByZWxhdGl2ZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRpciA6IGRpcixcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA6IGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgOiBmaWxlLmNvbW1lbnQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgdW5peFBlcm1pc3Npb25zIDogZmlsZS51bml4UGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgICAgIGRvc1Blcm1pc3Npb25zIDogZmlsZS5kb3NQZXJtaXNzaW9uc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnBpcGUoemlwRmlsZVdvcmtlcik7XG4gICAgICAgIH0pO1xuICAgICAgICB6aXBGaWxlV29ya2VyLmVudHJpZXNDb3VudCA9IGVudHJpZXNDb3VudDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHppcEZpbGVXb3JrZXIuZXJyb3IoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHppcEZpbGVXb3JrZXI7XG59O1xuIl0sIm5hbWVzIjpbImNvbXByZXNzaW9ucyIsInJlcXVpcmUiLCJaaXBGaWxlV29ya2VyIiwiZ2V0Q29tcHJlc3Npb24iLCJmaWxlQ29tcHJlc3Npb24iLCJ6aXBDb21wcmVzc2lvbiIsImNvbXByZXNzaW9uTmFtZSIsImNvbXByZXNzaW9uIiwiRXJyb3IiLCJleHBvcnRzIiwiZ2VuZXJhdGVXb3JrZXIiLCJ6aXAiLCJvcHRpb25zIiwiY29tbWVudCIsInppcEZpbGVXb3JrZXIiLCJzdHJlYW1GaWxlcyIsInBsYXRmb3JtIiwiZW5jb2RlRmlsZU5hbWUiLCJlbnRyaWVzQ291bnQiLCJmb3JFYWNoIiwicmVsYXRpdmVQYXRoIiwiZmlsZSIsImNvbXByZXNzaW9uT3B0aW9ucyIsImRpciIsImRhdGUiLCJfY29tcHJlc3NXb3JrZXIiLCJ3aXRoU3RyZWFtSW5mbyIsIm5hbWUiLCJ1bml4UGVybWlzc2lvbnMiLCJkb3NQZXJtaXNzaW9ucyIsInBpcGUiLCJlIiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/generate/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Representation a of zip file in js\n * @constructor\n */ function JSZip() {\n    // if this constructor is used without `new`, it adds `new` before itself:\n    if (!(this instanceof JSZip)) {\n        return new JSZip();\n    }\n    if (arguments.length) {\n        throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");\n    }\n    // object containing the files :\n    // {\n    //   \"folder/\" : {...},\n    //   \"folder/data.txt\" : {...}\n    // }\n    // NOTE: we use a null prototype because we do not\n    // want filenames like \"toString\" coming from a zip file\n    // to overwrite methods and attributes in a normal Object.\n    this.files = Object.create(null);\n    this.comment = null;\n    // Where we are in the hierarchy\n    this.root = \"\";\n    this.clone = function() {\n        var newObj = new JSZip();\n        for(var i in this){\n            if (typeof this[i] !== \"function\") {\n                newObj[i] = this[i];\n            }\n        }\n        return newObj;\n    };\n}\nJSZip.prototype = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/jszip/lib/object.js\");\nJSZip.prototype.loadAsync = __webpack_require__(/*! ./load */ \"(ssr)/./node_modules/jszip/lib/load.js\");\nJSZip.support = __webpack_require__(/*! ./support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\nJSZip.defaults = __webpack_require__(/*! ./defaults */ \"(ssr)/./node_modules/jszip/lib/defaults.js\");\n// TODO find a better way to handle this version,\n// a require('package.json').version doesn't work with webpack, see #327\nJSZip.version = \"3.10.1\";\nJSZip.loadAsync = function(content, options) {\n    return new JSZip().loadAsync(content, options);\n};\nJSZip.external = __webpack_require__(/*! ./external */ \"(ssr)/./node_modules/jszip/lib/external.js\");\nmodule.exports = JSZip;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWI7OztDQUdDLEdBQ0QsU0FBU0E7SUFDTCwwRUFBMEU7SUFDMUUsSUFBRyxDQUFFLEtBQUksWUFBWUEsS0FBSSxHQUFJO1FBQ3pCLE9BQU8sSUFBSUE7SUFDZjtJQUVBLElBQUdDLFVBQVVDLE1BQU0sRUFBRTtRQUNqQixNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFFQSxnQ0FBZ0M7SUFDaEMsSUFBSTtJQUNKLHVCQUF1QjtJQUN2Qiw4QkFBOEI7SUFDOUIsSUFBSTtJQUNKLGtEQUFrRDtJQUNsRCx3REFBd0Q7SUFDeEQsMERBQTBEO0lBQzFELElBQUksQ0FBQ0MsS0FBSyxHQUFHQyxPQUFPQyxNQUFNLENBQUM7SUFFM0IsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFFZixnQ0FBZ0M7SUFDaEMsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDWixJQUFJLENBQUNDLEtBQUssR0FBRztRQUNULElBQUlDLFNBQVMsSUFBSVY7UUFDakIsSUFBSyxJQUFJVyxLQUFLLElBQUksQ0FBRTtZQUNoQixJQUFJLE9BQU8sSUFBSSxDQUFDQSxFQUFFLEtBQUssWUFBWTtnQkFDL0JELE1BQU0sQ0FBQ0MsRUFBRSxHQUFHLElBQUksQ0FBQ0EsRUFBRTtZQUN2QjtRQUNKO1FBQ0EsT0FBT0Q7SUFDWDtBQUNKO0FBQ0FWLE1BQU1ZLFNBQVMsR0FBR0MsbUJBQU9BLENBQUMsMERBQVU7QUFDcENiLE1BQU1ZLFNBQVMsQ0FBQ0UsU0FBUyxHQUFHRCxtQkFBT0EsQ0FBQyxzREFBUTtBQUM1Q2IsTUFBTWUsT0FBTyxHQUFHRixtQkFBT0EsQ0FBQyw0REFBVztBQUNuQ2IsTUFBTWdCLFFBQVEsR0FBR0gsbUJBQU9BLENBQUMsOERBQVk7QUFFckMsaURBQWlEO0FBQ2pELHdFQUF3RTtBQUN4RWIsTUFBTWlCLE9BQU8sR0FBRztBQUVoQmpCLE1BQU1jLFNBQVMsR0FBRyxTQUFVSSxPQUFPLEVBQUVDLE9BQU87SUFDeEMsT0FBTyxJQUFJbkIsUUFBUWMsU0FBUyxDQUFDSSxTQUFTQztBQUMxQztBQUVBbkIsTUFBTW9CLFFBQVEsR0FBR1AsbUJBQU9BLENBQUMsOERBQVk7QUFDckNRLE9BQU9DLE9BQU8sR0FBR3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1vcHRpbWl6ZXIvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2luZGV4LmpzPzRlZjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gYSBvZiB6aXAgZmlsZSBpbiBqc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEpTWmlwKCkge1xuICAgIC8vIGlmIHRoaXMgY29uc3RydWN0b3IgaXMgdXNlZCB3aXRob3V0IGBuZXdgLCBpdCBhZGRzIGBuZXdgIGJlZm9yZSBpdHNlbGY6XG4gICAgaWYoISh0aGlzIGluc3RhbmNlb2YgSlNaaXApKSB7XG4gICAgICAgIHJldHVybiBuZXcgSlNaaXAoKTtcbiAgICB9XG5cbiAgICBpZihhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjb25zdHJ1Y3RvciB3aXRoIHBhcmFtZXRlcnMgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS5cIik7XG4gICAgfVxuXG4gICAgLy8gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZpbGVzIDpcbiAgICAvLyB7XG4gICAgLy8gICBcImZvbGRlci9cIiA6IHsuLi59LFxuICAgIC8vICAgXCJmb2xkZXIvZGF0YS50eHRcIiA6IHsuLi59XG4gICAgLy8gfVxuICAgIC8vIE5PVEU6IHdlIHVzZSBhIG51bGwgcHJvdG90eXBlIGJlY2F1c2Ugd2UgZG8gbm90XG4gICAgLy8gd2FudCBmaWxlbmFtZXMgbGlrZSBcInRvU3RyaW5nXCIgY29taW5nIGZyb20gYSB6aXAgZmlsZVxuICAgIC8vIHRvIG92ZXJ3cml0ZSBtZXRob2RzIGFuZCBhdHRyaWJ1dGVzIGluIGEgbm9ybWFsIE9iamVjdC5cbiAgICB0aGlzLmZpbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHRoaXMuY29tbWVudCA9IG51bGw7XG5cbiAgICAvLyBXaGVyZSB3ZSBhcmUgaW4gdGhlIGhpZXJhcmNoeVxuICAgIHRoaXMucm9vdCA9IFwiXCI7XG4gICAgdGhpcy5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbmV3T2JqID0gbmV3IEpTWmlwKCk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2ldICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBuZXdPYmpbaV0gPSB0aGlzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfTtcbn1cbkpTWmlwLnByb3RvdHlwZSA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbkpTWmlwLnByb3RvdHlwZS5sb2FkQXN5bmMgPSByZXF1aXJlKFwiLi9sb2FkXCIpO1xuSlNaaXAuc3VwcG9ydCA9IHJlcXVpcmUoXCIuL3N1cHBvcnRcIik7XG5KU1ppcC5kZWZhdWx0cyA9IHJlcXVpcmUoXCIuL2RlZmF1bHRzXCIpO1xuXG4vLyBUT0RPIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzIHZlcnNpb24sXG4vLyBhIHJlcXVpcmUoJ3BhY2thZ2UuanNvbicpLnZlcnNpb24gZG9lc24ndCB3b3JrIHdpdGggd2VicGFjaywgc2VlICMzMjdcbkpTWmlwLnZlcnNpb24gPSBcIjMuMTAuMVwiO1xuXG5KU1ppcC5sb2FkQXN5bmMgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgSlNaaXAoKS5sb2FkQXN5bmMoY29udGVudCwgb3B0aW9ucyk7XG59O1xuXG5KU1ppcC5leHRlcm5hbCA9IHJlcXVpcmUoXCIuL2V4dGVybmFsXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBKU1ppcDtcbiJdLCJuYW1lcyI6WyJKU1ppcCIsImFyZ3VtZW50cyIsImxlbmd0aCIsIkVycm9yIiwiZmlsZXMiLCJPYmplY3QiLCJjcmVhdGUiLCJjb21tZW50Iiwicm9vdCIsImNsb25lIiwibmV3T2JqIiwiaSIsInByb3RvdHlwZSIsInJlcXVpcmUiLCJsb2FkQXN5bmMiLCJzdXBwb3J0IiwiZGVmYXVsdHMiLCJ2ZXJzaW9uIiwiY29udGVudCIsIm9wdGlvbnMiLCJleHRlcm5hbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/load.js":
/*!****************************************!*\
  !*** ./node_modules/jszip/lib/load.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar external = __webpack_require__(/*! ./external */ \"(ssr)/./node_modules/jszip/lib/external.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"(ssr)/./node_modules/jszip/lib/utf8.js\");\nvar ZipEntries = __webpack_require__(/*! ./zipEntries */ \"(ssr)/./node_modules/jszip/lib/zipEntries.js\");\nvar Crc32Probe = __webpack_require__(/*! ./stream/Crc32Probe */ \"(ssr)/./node_modules/jszip/lib/stream/Crc32Probe.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"(ssr)/./node_modules/jszip/lib/nodejsUtils.js\");\n/**\n * Check the CRC32 of an entry.\n * @param {ZipEntry} zipEntry the zip entry to check.\n * @return {Promise} the result.\n */ function checkEntryCRC32(zipEntry) {\n    return new external.Promise(function(resolve, reject) {\n        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());\n        worker.on(\"error\", function(e) {\n            reject(e);\n        }).on(\"end\", function() {\n            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {\n                reject(new Error(\"Corrupted zip : CRC32 mismatch\"));\n            } else {\n                resolve();\n            }\n        }).resume();\n    });\n}\nmodule.exports = function(data, options) {\n    var zip = this;\n    options = utils.extend(options || {}, {\n        base64: false,\n        checkCRC32: false,\n        optimizedBinaryString: false,\n        createFolders: false,\n        decodeFileName: utf8.utf8decode\n    });\n    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        return external.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\"));\n    }\n    return utils.prepareContent(\"the loaded zip file\", data, true, options.optimizedBinaryString, options.base64).then(function(data) {\n        var zipEntries = new ZipEntries(options);\n        zipEntries.load(data);\n        return zipEntries;\n    }).then(function checkCRC32(zipEntries) {\n        var promises = [\n            external.Promise.resolve(zipEntries)\n        ];\n        var files = zipEntries.files;\n        if (options.checkCRC32) {\n            for(var i = 0; i < files.length; i++){\n                promises.push(checkEntryCRC32(files[i]));\n            }\n        }\n        return external.Promise.all(promises);\n    }).then(function addFiles(results) {\n        var zipEntries = results.shift();\n        var files = zipEntries.files;\n        for(var i = 0; i < files.length; i++){\n            var input = files[i];\n            var unsafeName = input.fileNameStr;\n            var safeName = utils.resolve(input.fileNameStr);\n            zip.file(safeName, input.decompressed, {\n                binary: true,\n                optimizedBinaryString: true,\n                date: input.date,\n                dir: input.dir,\n                comment: input.fileCommentStr.length ? input.fileCommentStr : null,\n                unixPermissions: input.unixPermissions,\n                dosPermissions: input.dosPermissions,\n                createFolders: options.createFolders\n            });\n            if (!input.dir) {\n                zip.file(safeName).unsafeOriginalName = unsafeName;\n            }\n        }\n        if (zipEntries.zipComment.length) {\n            zip.comment = zipEntries.zipComment;\n        }\n        return zip;\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0JBQ3ZCeUIsTUFBTU4sTUFBTU0sSUFBSTtnQkFDaEJDLEtBQUtQLE1BQU1PLEdBQUc7Z0JBQ2RDLFNBQVNSLE1BQU1TLGNBQWMsQ0FBQ2YsTUFBTSxHQUFHTSxNQUFNUyxjQUFjLEdBQUc7Z0JBQzlEQyxpQkFBaUJWLE1BQU1VLGVBQWU7Z0JBQ3RDQyxnQkFBZ0JYLE1BQU1XLGNBQWM7Z0JBQ3BDN0IsZUFBZU4sUUFBUU0sYUFBYTtZQUN4QztZQUNBLElBQUksQ0FBQ2tCLE1BQU1PLEdBQUcsRUFBRTtnQkFDWjlCLElBQUkyQixJQUFJLENBQUNELFVBQVVTLGtCQUFrQixHQUFHWDtZQUM1QztRQUNKO1FBQ0EsSUFBSVosV0FBV3dCLFVBQVUsQ0FBQ25CLE1BQU0sRUFBRTtZQUM5QmpCLElBQUkrQixPQUFPLEdBQUduQixXQUFXd0IsVUFBVTtRQUN2QztRQUVBLE9BQU9wQztJQUNYO0FBQ1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcHR4LW9wdGltaXplci8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvbG9hZC5qcz9jOTllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciB1dGY4ID0gcmVxdWlyZShcIi4vdXRmOFwiKTtcbnZhciBaaXBFbnRyaWVzID0gcmVxdWlyZShcIi4vemlwRW50cmllc1wiKTtcbnZhciBDcmMzMlByb2JlID0gcmVxdWlyZShcIi4vc3RyZWFtL0NyYzMyUHJvYmVcIik7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKFwiLi9ub2RlanNVdGlsc1wiKTtcblxuLyoqXG4gKiBDaGVjayB0aGUgQ1JDMzIgb2YgYW4gZW50cnkuXG4gKiBAcGFyYW0ge1ppcEVudHJ5fSB6aXBFbnRyeSB0aGUgemlwIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybiB7UHJvbWlzZX0gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tFbnRyeUNSQzMyKHppcEVudHJ5KSB7XG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IHppcEVudHJ5LmRlY29tcHJlc3NlZC5nZXRDb250ZW50V29ya2VyKCkucGlwZShuZXcgQ3JjMzJQcm9iZSgpKTtcbiAgICAgICAgd29ya2VyLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtlci5zdHJlYW1JbmZvLmNyYzMyICE9PSB6aXBFbnRyeS5kZWNvbXByZXNzZWQuY3JjMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBDUkMzMiBtaXNtYXRjaFwiKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdW1lKCk7XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgemlwID0gdGhpcztcbiAgICBvcHRpb25zID0gdXRpbHMuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgYmFzZTY0OiBmYWxzZSxcbiAgICAgICAgY2hlY2tDUkMzMjogZmFsc2UsXG4gICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogZmFsc2UsXG4gICAgICAgIGNyZWF0ZUZvbGRlcnM6IGZhbHNlLFxuICAgICAgICBkZWNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZGVjb2RlXG4gICAgfSk7XG5cbiAgICBpZiAobm9kZWpzVXRpbHMuaXNOb2RlICYmIG5vZGVqc1V0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJKU1ppcCBjYW4ndCBhY2NlcHQgYSBzdHJlYW0gd2hlbiBsb2FkaW5nIGEgemlwIGZpbGUuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMucHJlcGFyZUNvbnRlbnQoXCJ0aGUgbG9hZGVkIHppcCBmaWxlXCIsIGRhdGEsIHRydWUsIG9wdGlvbnMub3B0aW1pemVkQmluYXJ5U3RyaW5nLCBvcHRpb25zLmJhc2U2NClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciB6aXBFbnRyaWVzID0gbmV3IFppcEVudHJpZXMob3B0aW9ucyk7XG4gICAgICAgICAgICB6aXBFbnRyaWVzLmxvYWQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gemlwRW50cmllcztcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiBjaGVja0NSQzMyKHppcEVudHJpZXMpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoemlwRW50cmllcyldO1xuICAgICAgICAgICAgdmFyIGZpbGVzID0gemlwRW50cmllcy5maWxlcztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNoZWNrQ1JDMzIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goY2hlY2tFbnRyeUNSQzMyKGZpbGVzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVybmFsLlByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiBhZGRGaWxlcyhyZXN1bHRzKSB7XG4gICAgICAgICAgICB2YXIgemlwRW50cmllcyA9IHJlc3VsdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBmaWxlcyA9IHppcEVudHJpZXMuZmlsZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gZmlsZXNbaV07XG5cbiAgICAgICAgICAgICAgICB2YXIgdW5zYWZlTmFtZSA9IGlucHV0LmZpbGVOYW1lU3RyO1xuICAgICAgICAgICAgICAgIHZhciBzYWZlTmFtZSA9IHV0aWxzLnJlc29sdmUoaW5wdXQuZmlsZU5hbWVTdHIpO1xuXG4gICAgICAgICAgICAgICAgemlwLmZpbGUoc2FmZU5hbWUsIGlucHV0LmRlY29tcHJlc3NlZCwge1xuICAgICAgICAgICAgICAgICAgICBiaW5hcnk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogaW5wdXQuZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZGlyOiBpbnB1dC5kaXIsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQ6IGlucHV0LmZpbGVDb21tZW50U3RyLmxlbmd0aCA/IGlucHV0LmZpbGVDb21tZW50U3RyIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdW5peFBlcm1pc3Npb25zOiBpbnB1dC51bml4UGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgICAgIGRvc1Blcm1pc3Npb25zOiBpbnB1dC5kb3NQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRm9sZGVyczogb3B0aW9ucy5jcmVhdGVGb2xkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgemlwLmZpbGUoc2FmZU5hbWUpLnVuc2FmZU9yaWdpbmFsTmFtZSA9IHVuc2FmZU5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHppcEVudHJpZXMuemlwQ29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB6aXAuY29tbWVudCA9IHppcEVudHJpZXMuemlwQ29tbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHppcDtcbiAgICAgICAgfSk7XG59O1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsImV4dGVybmFsIiwidXRmOCIsIlppcEVudHJpZXMiLCJDcmMzMlByb2JlIiwibm9kZWpzVXRpbHMiLCJjaGVja0VudHJ5Q1JDMzIiLCJ6aXBFbnRyeSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwid29ya2VyIiwiZGVjb21wcmVzc2VkIiwiZ2V0Q29udGVudFdvcmtlciIsInBpcGUiLCJvbiIsImUiLCJzdHJlYW1JbmZvIiwiY3JjMzIiLCJFcnJvciIsInJlc3VtZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkYXRhIiwib3B0aW9ucyIsInppcCIsImV4dGVuZCIsImJhc2U2NCIsImNoZWNrQ1JDMzIiLCJvcHRpbWl6ZWRCaW5hcnlTdHJpbmciLCJjcmVhdGVGb2xkZXJzIiwiZGVjb2RlRmlsZU5hbWUiLCJ1dGY4ZGVjb2RlIiwiaXNOb2RlIiwiaXNTdHJlYW0iLCJwcmVwYXJlQ29udGVudCIsInRoZW4iLCJ6aXBFbnRyaWVzIiwibG9hZCIsInByb21pc2VzIiwiZmlsZXMiLCJpIiwibGVuZ3RoIiwicHVzaCIsImFsbCIsImFkZEZpbGVzIiwicmVzdWx0cyIsInNoaWZ0IiwiaW5wdXQiLCJ1bnNhZmVOYW1lIiwiZmlsZU5hbWVTdHIiLCJzYWZlTmFtZSIsImZpbGUiLCJiaW5hcnkiLCJkYXRlIiwiZGlyIiwiY29tbWVudCIsImZpbGVDb21tZW50U3RyIiwidW5peFBlcm1pc3Npb25zIiwiZG9zUGVybWlzc2lvbnMiLCJ1bnNhZmVPcmlnaW5hbE5hbWUiLCJ6aXBDb21tZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/load.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/nodejsUtils.js":
/*!***********************************************!*\
  !*** ./node_modules/jszip/lib/nodejsUtils.js ***!
  \***********************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    /**\n     * True if this is running in Nodejs, will be undefined in a browser.\n     * In a browser, browserify won't include this file and the whole module\n     * will be resolved an empty object.\n     */ isNode: typeof Buffer !== \"undefined\",\n    /**\n     * Create a new nodejs Buffer from an existing content.\n     * @param {Object} data the data to pass to the constructor.\n     * @param {String} encoding the encoding to use.\n     * @return {Buffer} a new Buffer.\n     */ newBufferFrom: function(data, encoding) {\n        if (Buffer.from && Buffer.from !== Uint8Array.from) {\n            return Buffer.from(data, encoding);\n        } else {\n            if (typeof data === \"number\") {\n                // Safeguard for old Node.js versions. On newer versions,\n                // Buffer.from(number) / Buffer(number, encoding) already throw.\n                throw new Error('The \"data\" argument must not be a number');\n            }\n            return new Buffer(data, encoding);\n        }\n    },\n    /**\n     * Create a new nodejs Buffer with the specified size.\n     * @param {Integer} size the size of the buffer.\n     * @return {Buffer} a new Buffer.\n     */ allocBuffer: function(size) {\n        if (Buffer.alloc) {\n            return Buffer.alloc(size);\n        } else {\n            var buf = new Buffer(size);\n            buf.fill(0);\n            return buf;\n        }\n    },\n    /**\n     * Find out if an object is a Buffer.\n     * @param {Object} b the object to test.\n     * @return {Boolean} true if the object is a Buffer, false otherwise.\n     */ isBuffer: function(b) {\n        return Buffer.isBuffer(b);\n    },\n    isStream: function(obj) {\n        return obj && typeof obj.on === \"function\" && typeof obj.pause === \"function\" && typeof obj.resume === \"function\";\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqc1V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLE9BQU9DLE9BQU8sR0FBRztJQUNiOzs7O0tBSUMsR0FDREMsUUFBUyxPQUFPQyxXQUFXO0lBQzNCOzs7OztLQUtDLEdBQ0RDLGVBQWUsU0FBU0MsSUFBSSxFQUFFQyxRQUFRO1FBQ2xDLElBQUlILE9BQU9JLElBQUksSUFBSUosT0FBT0ksSUFBSSxLQUFLQyxXQUFXRCxJQUFJLEVBQUU7WUFDaEQsT0FBT0osT0FBT0ksSUFBSSxDQUFDRixNQUFNQztRQUM3QixPQUFPO1lBQ0gsSUFBSSxPQUFPRCxTQUFTLFVBQVU7Z0JBQzFCLHlEQUF5RDtnQkFDekQsZ0VBQWdFO2dCQUNoRSxNQUFNLElBQUlJLE1BQU07WUFDcEI7WUFDQSxPQUFPLElBQUlOLE9BQU9FLE1BQU1DO1FBQzVCO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0RJLGFBQWEsU0FBVUMsSUFBSTtRQUN2QixJQUFJUixPQUFPUyxLQUFLLEVBQUU7WUFDZCxPQUFPVCxPQUFPUyxLQUFLLENBQUNEO1FBQ3hCLE9BQU87WUFDSCxJQUFJRSxNQUFNLElBQUlWLE9BQU9RO1lBQ3JCRSxJQUFJQyxJQUFJLENBQUM7WUFDVCxPQUFPRDtRQUNYO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0RFLFVBQVcsU0FBU0MsQ0FBQztRQUNqQixPQUFPYixPQUFPWSxRQUFRLENBQUNDO0lBQzNCO0lBRUFDLFVBQVcsU0FBVUMsR0FBRztRQUNwQixPQUFPQSxPQUNILE9BQU9BLElBQUlDLEVBQUUsS0FBSyxjQUNsQixPQUFPRCxJQUFJRSxLQUFLLEtBQUssY0FDckIsT0FBT0YsSUFBSUcsTUFBTSxLQUFLO0lBQzlCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcHR4LW9wdGltaXplci8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzVXRpbHMuanM/NGY3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGlzIGlzIHJ1bm5pbmcgaW4gTm9kZWpzLCB3aWxsIGJlIHVuZGVmaW5lZCBpbiBhIGJyb3dzZXIuXG4gICAgICogSW4gYSBicm93c2VyLCBicm93c2VyaWZ5IHdvbid0IGluY2x1ZGUgdGhpcyBmaWxlIGFuZCB0aGUgd2hvbGUgbW9kdWxlXG4gICAgICogd2lsbCBiZSByZXNvbHZlZCBhbiBlbXB0eSBvYmplY3QuXG4gICAgICovXG4gICAgaXNOb2RlIDogdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZWpzIEJ1ZmZlciBmcm9tIGFuIGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgdGhlIGRhdGEgdG8gcGFzcyB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UuXG4gICAgICogQHJldHVybiB7QnVmZmVyfSBhIG5ldyBCdWZmZXIuXG4gICAgICovXG4gICAgbmV3QnVmZmVyRnJvbTogZnVuY3Rpb24oZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20pIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBTYWZlZ3VhcmQgZm9yIG9sZCBOb2RlLmpzIHZlcnNpb25zLiBPbiBuZXdlciB2ZXJzaW9ucyxcbiAgICAgICAgICAgICAgICAvLyBCdWZmZXIuZnJvbShudW1iZXIpIC8gQnVmZmVyKG51bWJlciwgZW5jb2RpbmcpIGFscmVhZHkgdGhyb3cuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIFxcXCJkYXRhXFxcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vZGVqcyBCdWZmZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBzaXplIHRoZSBzaXplIG9mIHRoZSBidWZmZXIuXG4gICAgICogQHJldHVybiB7QnVmZmVyfSBhIG5ldyBCdWZmZXIuXG4gICAgICovXG4gICAgYWxsb2NCdWZmZXI6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmIChCdWZmZXIuYWxsb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICAgICAgICAgIGJ1Zi5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmluZCBvdXQgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBCdWZmZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0J1ZmZlciA6IGZ1bmN0aW9uKGIpe1xuICAgICAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGIpO1xuICAgIH0sXG5cbiAgICBpc1N0cmVhbSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5vbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLnBhdXNlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoucmVzdW1lID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiaXNOb2RlIiwiQnVmZmVyIiwibmV3QnVmZmVyRnJvbSIsImRhdGEiLCJlbmNvZGluZyIsImZyb20iLCJVaW50OEFycmF5IiwiRXJyb3IiLCJhbGxvY0J1ZmZlciIsInNpemUiLCJhbGxvYyIsImJ1ZiIsImZpbGwiLCJpc0J1ZmZlciIsImIiLCJpc1N0cmVhbSIsIm9iaiIsIm9uIiwicGF1c2UiLCJyZXN1bWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/nodejsUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ../stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\n/**\n * A worker that use a nodejs stream as source.\n * @constructor\n * @param {String} filename the name of the file entry for this stream.\n * @param {Readable} stream the nodejs stream.\n */ function NodejsStreamInputAdapter(filename, stream) {\n    GenericWorker.call(this, \"Nodejs stream input adapter for \" + filename);\n    this._upstreamEnded = false;\n    this._bindStream(stream);\n}\nutils.inherits(NodejsStreamInputAdapter, GenericWorker);\n/**\n * Prepare the stream and bind the callbacks on it.\n * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.\n * @param {Stream} stream the nodejs stream to use.\n */ NodejsStreamInputAdapter.prototype._bindStream = function(stream) {\n    var self = this;\n    this._stream = stream;\n    stream.pause();\n    stream.on(\"data\", function(chunk) {\n        self.push({\n            data: chunk,\n            meta: {\n                percent: 0\n            }\n        });\n    }).on(\"error\", function(e) {\n        if (self.isPaused) {\n            this.generatedError = e;\n        } else {\n            self.error(e);\n        }\n    }).on(\"end\", function() {\n        if (self.isPaused) {\n            self._upstreamEnded = true;\n        } else {\n            self.end();\n        }\n    });\n};\nNodejsStreamInputAdapter.prototype.pause = function() {\n    if (!GenericWorker.prototype.pause.call(this)) {\n        return false;\n    }\n    this._stream.pause();\n    return true;\n};\nNodejsStreamInputAdapter.prototype.resume = function() {\n    if (!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n    if (this._upstreamEnded) {\n        this.end();\n    } else {\n        this._stream.resume();\n    }\n    return true;\n};\nmodule.exports = NodejsStreamInputAdapter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQyx5REFBVTtBQUM5QixJQUFJQyxnQkFBZ0JELG1CQUFPQSxDQUFDLHVGQUF5QjtBQUVyRDs7Ozs7Q0FLQyxHQUNELFNBQVNFLHlCQUF5QkMsUUFBUSxFQUFFQyxNQUFNO0lBQzlDSCxjQUFjSSxJQUFJLENBQUMsSUFBSSxFQUFFLHFDQUFxQ0Y7SUFDOUQsSUFBSSxDQUFDRyxjQUFjLEdBQUc7SUFDdEIsSUFBSSxDQUFDQyxXQUFXLENBQUNIO0FBQ3JCO0FBRUFMLE1BQU1TLFFBQVEsQ0FBQ04sMEJBQTBCRDtBQUV6Qzs7OztDQUlDLEdBQ0RDLHlCQUF5Qk8sU0FBUyxDQUFDRixXQUFXLEdBQUcsU0FBVUgsTUFBTTtJQUM3RCxJQUFJTSxPQUFPLElBQUk7SUFDZixJQUFJLENBQUNDLE9BQU8sR0FBR1A7SUFDZkEsT0FBT1EsS0FBSztJQUNaUixPQUNLUyxFQUFFLENBQUMsUUFBUSxTQUFVQyxLQUFLO1FBQ3ZCSixLQUFLSyxJQUFJLENBQUM7WUFDTkMsTUFBTUY7WUFDTkcsTUFBTztnQkFDSEMsU0FBVTtZQUNkO1FBQ0o7SUFDSixHQUNDTCxFQUFFLENBQUMsU0FBUyxTQUFVTSxDQUFDO1FBQ3BCLElBQUdULEtBQUtVLFFBQVEsRUFBRTtZQUNkLElBQUksQ0FBQ0MsY0FBYyxHQUFHRjtRQUMxQixPQUFPO1lBQ0hULEtBQUtZLEtBQUssQ0FBQ0g7UUFDZjtJQUNKLEdBQ0NOLEVBQUUsQ0FBQyxPQUFPO1FBQ1AsSUFBR0gsS0FBS1UsUUFBUSxFQUFFO1lBQ2RWLEtBQUtKLGNBQWMsR0FBRztRQUMxQixPQUFPO1lBQ0hJLEtBQUthLEdBQUc7UUFDWjtJQUNKO0FBQ1I7QUFDQXJCLHlCQUF5Qk8sU0FBUyxDQUFDRyxLQUFLLEdBQUc7SUFDdkMsSUFBRyxDQUFDWCxjQUFjUSxTQUFTLENBQUNHLEtBQUssQ0FBQ1AsSUFBSSxDQUFDLElBQUksR0FBRztRQUMxQyxPQUFPO0lBQ1g7SUFDQSxJQUFJLENBQUNNLE9BQU8sQ0FBQ0MsS0FBSztJQUNsQixPQUFPO0FBQ1g7QUFDQVYseUJBQXlCTyxTQUFTLENBQUNlLE1BQU0sR0FBRztJQUN4QyxJQUFHLENBQUN2QixjQUFjUSxTQUFTLENBQUNlLE1BQU0sQ0FBQ25CLElBQUksQ0FBQyxJQUFJLEdBQUc7UUFDM0MsT0FBTztJQUNYO0lBRUEsSUFBRyxJQUFJLENBQUNDLGNBQWMsRUFBRTtRQUNwQixJQUFJLENBQUNpQixHQUFHO0lBQ1osT0FBTztRQUNILElBQUksQ0FBQ1osT0FBTyxDQUFDYSxNQUFNO0lBQ3ZCO0lBRUEsT0FBTztBQUNYO0FBRUFDLE9BQU9DLE9BQU8sR0FBR3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1vcHRpbWl6ZXIvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIuanM/ODE3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCB1c2UgYSBub2RlanMgc3RyZWFtIGFzIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGVudHJ5IGZvciB0aGlzIHN0cmVhbS5cbiAqIEBwYXJhbSB7UmVhZGFibGV9IHN0cmVhbSB0aGUgbm9kZWpzIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyKGZpbGVuYW1lLCBzdHJlYW0pIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJOb2RlanMgc3RyZWFtIGlucHV0IGFkYXB0ZXIgZm9yIFwiICsgZmlsZW5hbWUpO1xuICAgIHRoaXMuX3Vwc3RyZWFtRW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9iaW5kU3RyZWFtKHN0cmVhbSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgc3RyZWFtIGFuZCBiaW5kIHRoZSBjYWxsYmFja3Mgb24gaXQuXG4gKiBEbyB0aGlzIEFTQVAgb24gbm9kZSAwLjEwICEgQSBsYXp5IGJpbmRpbmcgZG9lc24ndCBhbHdheXMgd29yay5cbiAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0gdG8gdXNlLlxuICovXG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLl9iaW5kU3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgc3RyZWFtXG4gICAgICAgIC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBzZWxmLnB1c2goe1xuICAgICAgICAgICAgICAgIGRhdGE6IGNodW5rLFxuICAgICAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnQgOiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZihzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZihzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fdXBzdHJlYW1FbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufTtcbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnBhdXNlLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9zdHJlYW0ucGF1c2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX3Vwc3RyZWFtRW5kZWQpIHtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcjtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJHZW5lcmljV29ya2VyIiwiTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyIiwiZmlsZW5hbWUiLCJzdHJlYW0iLCJjYWxsIiwiX3Vwc3RyZWFtRW5kZWQiLCJfYmluZFN0cmVhbSIsImluaGVyaXRzIiwicHJvdG90eXBlIiwic2VsZiIsIl9zdHJlYW0iLCJwYXVzZSIsIm9uIiwiY2h1bmsiLCJwdXNoIiwiZGF0YSIsIm1ldGEiLCJwZXJjZW50IiwiZSIsImlzUGF1c2VkIiwiZ2VuZXJhdGVkRXJyb3IiLCJlcnJvciIsImVuZCIsInJlc3VtZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js":
/*!********************************************************************!*\
  !*** ./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Readable = (__webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/readable-stream/readable.js\").Readable);\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nutils.inherits(NodejsStreamOutputAdapter, Readable);\n/**\n* A nodejs stream using a worker as source.\n* @see the SourceWrapper in http://nodejs.org/api/stream.html\n* @constructor\n* @param {StreamHelper} helper the helper wrapping the worker\n* @param {Object} options the nodejs stream options\n* @param {Function} updateCb the update callback.\n*/ function NodejsStreamOutputAdapter(helper, options, updateCb) {\n    Readable.call(this, options);\n    this._helper = helper;\n    var self = this;\n    helper.on(\"data\", function(data, meta) {\n        if (!self.push(data)) {\n            self._helper.pause();\n        }\n        if (updateCb) {\n            updateCb(meta);\n        }\n    }).on(\"error\", function(e) {\n        self.emit(\"error\", e);\n    }).on(\"end\", function() {\n        self.push(null);\n    });\n}\nNodejsStreamOutputAdapter.prototype._read = function() {\n    this._helper.resume();\n};\nmodule.exports = NodejsStreamOutputAdapter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqcy9Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsV0FBV0MseUdBQW1DO0FBRWxELElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLHlEQUFVO0FBQzlCQyxNQUFNQyxRQUFRLENBQUNDLDJCQUEyQko7QUFFMUM7Ozs7Ozs7QUFPQSxHQUNBLFNBQVNJLDBCQUEwQkMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFFBQVE7SUFDeERQLFNBQVNRLElBQUksQ0FBQyxJQUFJLEVBQUVGO0lBQ3BCLElBQUksQ0FBQ0csT0FBTyxHQUFHSjtJQUVmLElBQUlLLE9BQU8sSUFBSTtJQUNmTCxPQUFPTSxFQUFFLENBQUMsUUFBUSxTQUFVQyxJQUFJLEVBQUVDLElBQUk7UUFDbEMsSUFBSSxDQUFDSCxLQUFLSSxJQUFJLENBQUNGLE9BQU87WUFDbEJGLEtBQUtELE9BQU8sQ0FBQ00sS0FBSztRQUN0QjtRQUNBLElBQUdSLFVBQVU7WUFDVEEsU0FBU007UUFDYjtJQUNKLEdBQ0tGLEVBQUUsQ0FBQyxTQUFTLFNBQVNLLENBQUM7UUFDbkJOLEtBQUtPLElBQUksQ0FBQyxTQUFTRDtJQUN2QixHQUNDTCxFQUFFLENBQUMsT0FBTztRQUNQRCxLQUFLSSxJQUFJLENBQUM7SUFDZDtBQUNSO0FBR0FWLDBCQUEwQmMsU0FBUyxDQUFDQyxLQUFLLEdBQUc7SUFDeEMsSUFBSSxDQUFDVixPQUFPLENBQUNXLE1BQU07QUFDdkI7QUFFQUMsT0FBT0MsT0FBTyxHQUFHbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcHR4LW9wdGltaXplci8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIuanM/OTgwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZShcInJlYWRhYmxlLXN0cmVhbVwiKS5SZWFkYWJsZTtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudXRpbHMuaW5oZXJpdHMoTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlciwgUmVhZGFibGUpO1xuXG4vKipcbiogQSBub2RlanMgc3RyZWFtIHVzaW5nIGEgd29ya2VyIGFzIHNvdXJjZS5cbiogQHNlZSB0aGUgU291cmNlV3JhcHBlciBpbiBodHRwOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWxcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7U3RyZWFtSGVscGVyfSBoZWxwZXIgdGhlIGhlbHBlciB3cmFwcGluZyB0aGUgd29ya2VyXG4qIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBub2RlanMgc3RyZWFtIG9wdGlvbnNcbiogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2IgdGhlIHVwZGF0ZSBjYWxsYmFjay5cbiovXG5mdW5jdGlvbiBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyKGhlbHBlciwgb3B0aW9ucywgdXBkYXRlQ2IpIHtcbiAgICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2hlbHBlciA9IGhlbHBlcjtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBoZWxwZXIub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChkYXRhLCBtZXRhKSB7XG4gICAgICAgIGlmICghc2VsZi5wdXNoKGRhdGEpKSB7XG4gICAgICAgICAgICBzZWxmLl9oZWxwZXIucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZih1cGRhdGVDYikge1xuICAgICAgICAgICAgdXBkYXRlQ2IobWV0YSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICAgICAgfSk7XG59XG5cblxuTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9oZWxwZXIucmVzdW1lKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXI7XG4iXSwibmFtZXMiOlsiUmVhZGFibGUiLCJyZXF1aXJlIiwidXRpbHMiLCJpbmhlcml0cyIsIk5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIiLCJoZWxwZXIiLCJvcHRpb25zIiwidXBkYXRlQ2IiLCJjYWxsIiwiX2hlbHBlciIsInNlbGYiLCJvbiIsImRhdGEiLCJtZXRhIiwicHVzaCIsInBhdXNlIiwiZSIsImVtaXQiLCJwcm90b3R5cGUiLCJfcmVhZCIsInJlc3VtZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/object.js":
/*!******************************************!*\
  !*** ./node_modules/jszip/lib/object.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"(ssr)/./node_modules/jszip/lib/utf8.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nvar StreamHelper = __webpack_require__(/*! ./stream/StreamHelper */ \"(ssr)/./node_modules/jszip/lib/stream/StreamHelper.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"(ssr)/./node_modules/jszip/lib/defaults.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"(ssr)/./node_modules/jszip/lib/compressedObject.js\");\nvar ZipObject = __webpack_require__(/*! ./zipObject */ \"(ssr)/./node_modules/jszip/lib/zipObject.js\");\nvar generate = __webpack_require__(/*! ./generate */ \"(ssr)/./node_modules/jszip/lib/generate/index.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"(ssr)/./node_modules/jszip/lib/nodejsUtils.js\");\nvar NodejsStreamInputAdapter = __webpack_require__(/*! ./nodejs/NodejsStreamInputAdapter */ \"(ssr)/./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js\");\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} originalOptions the options of the file\n * @return {Object} the new file.\n */ var fileAdd = function(name, data, originalOptions) {\n    // be sure sub folders exist\n    var dataType = utils.getTypeOf(data), parent;\n    /*\n     * Correct options.\n     */ var o = utils.extend(originalOptions || {}, defaults);\n    o.date = o.date || new Date();\n    if (o.compression !== null) {\n        o.compression = o.compression.toUpperCase();\n    }\n    if (typeof o.unixPermissions === \"string\") {\n        o.unixPermissions = parseInt(o.unixPermissions, 8);\n    }\n    // UNX_IFDIR  0040000 see zipinfo.c\n    if (o.unixPermissions && o.unixPermissions & 0x4000) {\n        o.dir = true;\n    }\n    // Bit 4    Directory\n    if (o.dosPermissions && o.dosPermissions & 0x0010) {\n        o.dir = true;\n    }\n    if (o.dir) {\n        name = forceTrailingSlash(name);\n    }\n    if (o.createFolders && (parent = parentFolder(name))) {\n        folderAdd.call(this, parent, true);\n    }\n    var isUnicodeString = dataType === \"string\" && o.binary === false && o.base64 === false;\n    if (!originalOptions || typeof originalOptions.binary === \"undefined\") {\n        o.binary = !isUnicodeString;\n    }\n    var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;\n    if (isCompressedEmpty || o.dir || !data || data.length === 0) {\n        o.base64 = false;\n        o.binary = true;\n        data = \"\";\n        o.compression = \"STORE\";\n        dataType = \"string\";\n    }\n    /*\n     * Convert content to fit.\n     */ var zipObjectContent = null;\n    if (data instanceof CompressedObject || data instanceof GenericWorker) {\n        zipObjectContent = data;\n    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        zipObjectContent = new NodejsStreamInputAdapter(name, data);\n    } else {\n        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);\n    }\n    var object = new ZipObject(name, zipObjectContent, o);\n    this.files[name] = object;\n/*\n    TODO: we can't throw an exception because we have async promises\n    (we can have a promise of a Date() for example) but returning a\n    promise is useless because file(name, data) returns the JSZip\n    object for chaining. Should we break that to allow the user\n    to catch the error ?\n\n    return external.Promise.resolve(zipObjectContent)\n    .then(function () {\n        return object;\n    });\n    */ };\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */ var parentFolder = function(path) {\n    if (path.slice(-1) === \"/\") {\n        path = path.substring(0, path.length - 1);\n    }\n    var lastSlash = path.lastIndexOf(\"/\");\n    return lastSlash > 0 ? path.substring(0, lastSlash) : \"\";\n};\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */ var forceTrailingSlash = function(path) {\n    // Check the name ends with a /\n    if (path.slice(-1) !== \"/\") {\n        path += \"/\"; // IE doesn't like substr(-1)\n    }\n    return path;\n};\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */ var folderAdd = function(name, createFolders) {\n    createFolders = typeof createFolders !== \"undefined\" ? createFolders : defaults.createFolders;\n    name = forceTrailingSlash(name);\n    // Does this folder already exist?\n    if (!this.files[name]) {\n        fileAdd.call(this, name, null, {\n            dir: true,\n            createFolders: createFolders\n        });\n    }\n    return this.files[name];\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/ function isRegExp(object) {\n    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n}\n// return the actual prototype of JSZip\nvar out = {\n    /**\n     * @see loadAsync\n     */ load: function() {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n    /**\n     * Call a callback function for each entry at this folder level.\n     * @param {Function} cb the callback function:\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     */ forEach: function(cb) {\n        var filename, relativePath, file;\n        // ignore warning about unwanted properties because this.files is a null prototype object\n        /* eslint-disable-next-line guard-for-in */ for(filename in this.files){\n            file = this.files[filename];\n            relativePath = filename.slice(this.root.length, filename.length);\n            if (relativePath && filename.slice(0, this.root.length) === this.root) {\n                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...\n            }\n        }\n    },\n    /**\n     * Filter nested files/folders with the specified function.\n     * @param {Function} search the predicate to use :\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     * @return {Array} An array of matching elements.\n     */ filter: function(search) {\n        var result = [];\n        this.forEach(function(relativePath, entry) {\n            if (search(relativePath, entry)) {\n                result.push(entry);\n            }\n        });\n        return result;\n    },\n    /**\n     * Add a file to the zip file, or search a file.\n     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n     * the name of the file to find (if no data) or a regex to match files.\n     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n     * @param   {Object} o     File options\n     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n     * a file (when searching by string) or an array of files (when searching by regex).\n     */ file: function(name, data, o) {\n        if (arguments.length === 1) {\n            if (isRegExp(name)) {\n                var regexp = name;\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && regexp.test(relativePath);\n                });\n            } else {\n                var obj = this.files[this.root + name];\n                if (obj && !obj.dir) {\n                    return obj;\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            name = this.root + name;\n            fileAdd.call(this, name, data, o);\n        }\n        return this;\n    },\n    /**\n     * Add a directory to the zip file, or search.\n     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n     */ folder: function(arg) {\n        if (!arg) {\n            return this;\n        }\n        if (isRegExp(arg)) {\n            return this.filter(function(relativePath, file) {\n                return file.dir && arg.test(relativePath);\n            });\n        }\n        // else, name is a new folder\n        var name = this.root + arg;\n        var newFolder = folderAdd.call(this, name);\n        // Allow chaining by returning a new object with this folder as the root\n        var ret = this.clone();\n        ret.root = newFolder.name;\n        return ret;\n    },\n    /**\n     * Delete a file, or a directory and all sub-files, from the zip\n     * @param {string} name the name of the file to delete\n     * @return {JSZip} this JSZip object\n     */ remove: function(name) {\n        name = this.root + name;\n        var file = this.files[name];\n        if (!file) {\n            // Look for any folders\n            if (name.slice(-1) !== \"/\") {\n                name += \"/\";\n            }\n            file = this.files[name];\n        }\n        if (file && !file.dir) {\n            // file\n            delete this.files[name];\n        } else {\n            // maybe a folder, delete recursively\n            var kids = this.filter(function(relativePath, file) {\n                return file.name.slice(0, name.length) === name;\n            });\n            for(var i = 0; i < kids.length; i++){\n                delete this.files[kids[i].name];\n            }\n        }\n        return this;\n    },\n    /**\n     * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.\n     */ generate: function() {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n    /**\n     * Generate the complete zip file as an internal stream.\n     * @param {Object} options the options to generate the zip file :\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {StreamHelper} the streamed zip file.\n     */ generateInternalStream: function(options) {\n        var worker, opts = {};\n        try {\n            opts = utils.extend(options || {}, {\n                streamFiles: false,\n                compression: \"STORE\",\n                compressionOptions: null,\n                type: \"\",\n                platform: \"DOS\",\n                comment: null,\n                mimeType: \"application/zip\",\n                encodeFileName: utf8.utf8encode\n            });\n            opts.type = opts.type.toLowerCase();\n            opts.compression = opts.compression.toUpperCase();\n            // \"binarystring\" is preferred but the internals use \"string\".\n            if (opts.type === \"binarystring\") {\n                opts.type = \"string\";\n            }\n            if (!opts.type) {\n                throw new Error(\"No output type specified.\");\n            }\n            utils.checkSupport(opts.type);\n            // accept nodejs `process.platform`\n            if (opts.platform === \"darwin\" || opts.platform === \"freebsd\" || opts.platform === \"linux\" || opts.platform === \"sunos\") {\n                opts.platform = \"UNIX\";\n            }\n            if (opts.platform === \"win32\") {\n                opts.platform = \"DOS\";\n            }\n            var comment = opts.comment || this.comment || \"\";\n            worker = generate.generateWorker(this, opts, comment);\n        } catch (e) {\n            worker = new GenericWorker(\"error\");\n            worker.error(e);\n        }\n        return new StreamHelper(worker, opts.type || \"string\", opts.mimeType);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */ generateAsync: function(options, onUpdate) {\n        return this.generateInternalStream(options).accumulate(onUpdate);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */ generateNodeStream: function(options, onUpdate) {\n        options = options || {};\n        if (!options.type) {\n            options.type = \"nodebuffer\";\n        }\n        return this.generateInternalStream(options).toNodejsStream(onUpdate);\n    }\n};\nmodule.exports = out;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL29iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLE9BQU9DLG1CQUFPQSxDQUFDLHNEQUFRO0FBQzNCLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLHdEQUFTO0FBQzdCLElBQUlFLGdCQUFnQkYsbUJBQU9BLENBQUMsc0ZBQXdCO0FBQ3BELElBQUlHLGVBQWVILG1CQUFPQSxDQUFDLG9GQUF1QjtBQUNsRCxJQUFJSSxXQUFXSixtQkFBT0EsQ0FBQyw4REFBWTtBQUNuQyxJQUFJSyxtQkFBbUJMLG1CQUFPQSxDQUFDLDhFQUFvQjtBQUNuRCxJQUFJTSxZQUFZTixtQkFBT0EsQ0FBQyxnRUFBYTtBQUNyQyxJQUFJTyxXQUFXUCxtQkFBT0EsQ0FBQyxvRUFBWTtBQUNuQyxJQUFJUSxjQUFjUixtQkFBT0EsQ0FBQyxvRUFBZTtBQUN6QyxJQUFJUywyQkFBMkJULG1CQUFPQSxDQUFDLDRHQUFtQztBQUcxRTs7Ozs7OztDQU9DLEdBQ0QsSUFBSVUsVUFBVSxTQUFTQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsZUFBZTtJQUM5Qyw0QkFBNEI7SUFDNUIsSUFBSUMsV0FBV2IsTUFBTWMsU0FBUyxDQUFDSCxPQUMzQkk7SUFHSjs7S0FFQyxHQUVELElBQUlDLElBQUloQixNQUFNaUIsTUFBTSxDQUFDTCxtQkFBbUIsQ0FBQyxHQUFHVDtJQUM1Q2EsRUFBRUUsSUFBSSxHQUFHRixFQUFFRSxJQUFJLElBQUksSUFBSUM7SUFDdkIsSUFBSUgsRUFBRUksV0FBVyxLQUFLLE1BQU07UUFDeEJKLEVBQUVJLFdBQVcsR0FBR0osRUFBRUksV0FBVyxDQUFDQyxXQUFXO0lBQzdDO0lBRUEsSUFBSSxPQUFPTCxFQUFFTSxlQUFlLEtBQUssVUFBVTtRQUN2Q04sRUFBRU0sZUFBZSxHQUFHQyxTQUFTUCxFQUFFTSxlQUFlLEVBQUU7SUFDcEQ7SUFFQSxtQ0FBbUM7SUFDbkMsSUFBSU4sRUFBRU0sZUFBZSxJQUFLTixFQUFF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QUNBLFFBQVFLLElBQUksRUFBRTtZQUNmTCxRQUFRSyxJQUFJLEdBQUc7UUFDbkI7UUFDQSxPQUFPLElBQUksQ0FBQ04sc0JBQXNCLENBQUNDLFNBQVNvQixjQUFjLENBQUNIO0lBQy9EO0FBQ0o7QUFDQUksT0FBT0MsT0FBTyxHQUFHakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcHR4LW9wdGltaXplci8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvb2JqZWN0LmpzP2RhNGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRmOCA9IHJlcXVpcmUoXCIuL3V0ZjhcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG52YXIgU3RyZWFtSGVscGVyID0gcmVxdWlyZShcIi4vc3RyZWFtL1N0cmVhbUhlbHBlclwiKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoXCIuL2RlZmF1bHRzXCIpO1xudmFyIENvbXByZXNzZWRPYmplY3QgPSByZXF1aXJlKFwiLi9jb21wcmVzc2VkT2JqZWN0XCIpO1xudmFyIFppcE9iamVjdCA9IHJlcXVpcmUoXCIuL3ppcE9iamVjdFwiKTtcbnZhciBnZW5lcmF0ZSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlXCIpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG52YXIgTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyID0gcmVxdWlyZShcIi4vbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlclwiKTtcblxuXG4vKipcbiAqIEFkZCBhIGZpbGUgaW4gdGhlIGN1cnJlbnQgZm9sZGVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgZGF0YSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsT3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbmV3IGZpbGUuXG4gKi9cbnZhciBmaWxlQWRkID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3JpZ2luYWxPcHRpb25zKSB7XG4gICAgLy8gYmUgc3VyZSBzdWIgZm9sZGVycyBleGlzdFxuICAgIHZhciBkYXRhVHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKSxcbiAgICAgICAgcGFyZW50O1xuXG5cbiAgICAvKlxuICAgICAqIENvcnJlY3Qgb3B0aW9ucy5cbiAgICAgKi9cblxuICAgIHZhciBvID0gdXRpbHMuZXh0ZW5kKG9yaWdpbmFsT3B0aW9ucyB8fCB7fSwgZGVmYXVsdHMpO1xuICAgIG8uZGF0ZSA9IG8uZGF0ZSB8fCBuZXcgRGF0ZSgpO1xuICAgIGlmIChvLmNvbXByZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgIG8uY29tcHJlc3Npb24gPSBvLmNvbXByZXNzaW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvLnVuaXhQZXJtaXNzaW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvLnVuaXhQZXJtaXNzaW9ucyA9IHBhcnNlSW50KG8udW5peFBlcm1pc3Npb25zLCA4KTtcbiAgICB9XG5cbiAgICAvLyBVTlhfSUZESVIgIDAwNDAwMDAgc2VlIHppcGluZm8uY1xuICAgIGlmIChvLnVuaXhQZXJtaXNzaW9ucyAmJiAoby51bml4UGVybWlzc2lvbnMgJiAweDQwMDApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gQml0IDQgICAgRGlyZWN0b3J5XG4gICAgaWYgKG8uZG9zUGVybWlzc2lvbnMgJiYgKG8uZG9zUGVybWlzc2lvbnMgJiAweDAwMTApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoby5kaXIpIHtcbiAgICAgICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcbiAgICB9XG4gICAgaWYgKG8uY3JlYXRlRm9sZGVycyAmJiAocGFyZW50ID0gcGFyZW50Rm9sZGVyKG5hbWUpKSkge1xuICAgICAgICBmb2xkZXJBZGQuY2FsbCh0aGlzLCBwYXJlbnQsIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBpc1VuaWNvZGVTdHJpbmcgPSBkYXRhVHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBvLmJpbmFyeSA9PT0gZmFsc2UgJiYgby5iYXNlNjQgPT09IGZhbHNlO1xuICAgIGlmICghb3JpZ2luYWxPcHRpb25zIHx8IHR5cGVvZiBvcmlnaW5hbE9wdGlvbnMuYmluYXJ5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG8uYmluYXJ5ID0gIWlzVW5pY29kZVN0cmluZztcbiAgICB9XG5cblxuICAgIHZhciBpc0NvbXByZXNzZWRFbXB0eSA9IChkYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCkgJiYgZGF0YS51bmNvbXByZXNzZWRTaXplID09PSAwO1xuXG4gICAgaWYgKGlzQ29tcHJlc3NlZEVtcHR5IHx8IG8uZGlyIHx8ICFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG8uYmFzZTY0ID0gZmFsc2U7XG4gICAgICAgIG8uYmluYXJ5ID0gdHJ1ZTtcbiAgICAgICAgZGF0YSA9IFwiXCI7XG4gICAgICAgIG8uY29tcHJlc3Npb24gPSBcIlNUT1JFXCI7XG4gICAgICAgIGRhdGFUeXBlID0gXCJzdHJpbmdcIjtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvbnZlcnQgY29udGVudCB0byBmaXQuXG4gICAgICovXG5cbiAgICB2YXIgemlwT2JqZWN0Q29udGVudCA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0IHx8IGRhdGEgaW5zdGFuY2VvZiBHZW5lcmljV29ya2VyKSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAobm9kZWpzVXRpbHMuaXNOb2RlICYmIG5vZGVqc1V0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSBuZXcgTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyKG5hbWUsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSB1dGlscy5wcmVwYXJlQ29udGVudChuYW1lLCBkYXRhLCBvLmJpbmFyeSwgby5vcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIG8uYmFzZTY0KTtcbiAgICB9XG5cbiAgICB2YXIgb2JqZWN0ID0gbmV3IFppcE9iamVjdChuYW1lLCB6aXBPYmplY3RDb250ZW50LCBvKTtcbiAgICB0aGlzLmZpbGVzW25hbWVdID0gb2JqZWN0O1xuICAgIC8qXG4gICAgVE9ETzogd2UgY2FuJ3QgdGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugd2UgaGF2ZSBhc3luYyBwcm9taXNlc1xuICAgICh3ZSBjYW4gaGF2ZSBhIHByb21pc2Ugb2YgYSBEYXRlKCkgZm9yIGV4YW1wbGUpIGJ1dCByZXR1cm5pbmcgYVxuICAgIHByb21pc2UgaXMgdXNlbGVzcyBiZWNhdXNlIGZpbGUobmFtZSwgZGF0YSkgcmV0dXJucyB0aGUgSlNaaXBcbiAgICBvYmplY3QgZm9yIGNoYWluaW5nLiBTaG91bGQgd2UgYnJlYWsgdGhhdCB0byBhbGxvdyB0aGUgdXNlclxuICAgIHRvIGNhdGNoIHRoZSBlcnJvciA/XG5cbiAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHppcE9iamVjdENvbnRlbnQpXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuICAgICovXG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIHBhcmVudCBmb2xkZXIgb2YgdGhlIHBhdGguXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gdXNlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBwYXJlbnQgZm9sZGVyLCBvciBcIlwiXG4gKi9cbnZhciBwYXJlbnRGb2xkZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChwYXRoLnNsaWNlKC0xKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHBhdGgubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIHZhciBsYXN0U2xhc2ggPSBwYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICByZXR1cm4gKGxhc3RTbGFzaCA+IDApID8gcGF0aC5zdWJzdHJpbmcoMCwgbGFzdFNsYXNoKSA6IFwiXCI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhdGggd2l0aCBhIHNsYXNoIGF0IHRoZSBlbmQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBwYXRoIHdpdGggYSB0cmFpbGluZyBzbGFzaC5cbiAqL1xudmFyIGZvcmNlVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAvLyBDaGVjayB0aGUgbmFtZSBlbmRzIHdpdGggYSAvXG4gICAgaWYgKHBhdGguc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoICs9IFwiL1wiOyAvLyBJRSBkb2Vzbid0IGxpa2Ugc3Vic3RyKC0xKVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn07XG5cbi8qKlxuICogQWRkIGEgKHN1YikgZm9sZGVyIGluIHRoZSBjdXJyZW50IGZvbGRlci5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgZm9sZGVyJ3MgbmFtZVxuICogQHBhcmFtIHtib29sZWFuPX0gW2NyZWF0ZUZvbGRlcnNdIElmIHRydWUsIGF1dG9tYXRpY2FsbHkgY3JlYXRlIHN1YlxuICogIGZvbGRlcnMuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbmV3IGZvbGRlci5cbiAqL1xudmFyIGZvbGRlckFkZCA9IGZ1bmN0aW9uKG5hbWUsIGNyZWF0ZUZvbGRlcnMpIHtcbiAgICBjcmVhdGVGb2xkZXJzID0gKHR5cGVvZiBjcmVhdGVGb2xkZXJzICE9PSBcInVuZGVmaW5lZFwiKSA/IGNyZWF0ZUZvbGRlcnMgOiBkZWZhdWx0cy5jcmVhdGVGb2xkZXJzO1xuXG4gICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcblxuICAgIC8vIERvZXMgdGhpcyBmb2xkZXIgYWxyZWFkeSBleGlzdD9cbiAgICBpZiAoIXRoaXMuZmlsZXNbbmFtZV0pIHtcbiAgICAgICAgZmlsZUFkZC5jYWxsKHRoaXMsIG5hbWUsIG51bGwsIHtcbiAgICAgICAgICAgIGRpcjogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IGNyZWF0ZUZvbGRlcnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbGVzW25hbWVdO1xufTtcblxuLyoqXG4qIENyb3NzLXdpbmRvdywgY3Jvc3MtTm9kZS1jb250ZXh0IHJlZ3VsYXIgZXhwcmVzc2lvbiBkZXRlY3Rpb25cbiogQHBhcmFtICB7T2JqZWN0fSAgb2JqZWN0IEFueXRoaW5nXG4qIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sXG4qIGZhbHNlIG90aGVyd2lzZVxuKi9cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbn1cblxuLy8gcmV0dXJuIHRoZSBhY3R1YWwgcHJvdG90eXBlIG9mIEpTWmlwXG52YXIgb3V0ID0ge1xuICAgIC8qKlxuICAgICAqIEBzZWUgbG9hZEFzeW5jXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBlbnRyeSBhdCB0aGlzIGZvbGRlciBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiB0aGUgY2FsbGJhY2sgZnVuY3Rpb246XG4gICAgICogZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkgey4uLn1cbiAgICAgKiBJdCB0YWtlcyAyIGFyZ3VtZW50cyA6IHRoZSByZWxhdGl2ZSBwYXRoIGFuZCB0aGUgZmlsZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoOiBmdW5jdGlvbihjYikge1xuICAgICAgICB2YXIgZmlsZW5hbWUsIHJlbGF0aXZlUGF0aCwgZmlsZTtcbiAgICAgICAgLy8gaWdub3JlIHdhcm5pbmcgYWJvdXQgdW53YW50ZWQgcHJvcGVydGllcyBiZWNhdXNlIHRoaXMuZmlsZXMgaXMgYSBudWxsIHByb3RvdHlwZSBvYmplY3RcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pbiAqL1xuICAgICAgICBmb3IgKGZpbGVuYW1lIGluIHRoaXMuZmlsZXMpIHtcbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLmZpbGVzW2ZpbGVuYW1lXTtcbiAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IGZpbGVuYW1lLnNsaWNlKHRoaXMucm9vdC5sZW5ndGgsIGZpbGVuYW1lLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmVQYXRoICYmIGZpbGVuYW1lLnNsaWNlKDAsIHRoaXMucm9vdC5sZW5ndGgpID09PSB0aGlzLnJvb3QpIHsgLy8gdGhlIGZpbGUgaXMgaW4gdGhlIGN1cnJlbnQgcm9vdFxuICAgICAgICAgICAgICAgIGNiKHJlbGF0aXZlUGF0aCwgZmlsZSk7IC8vIFRPRE8gcmV2ZXJzZSB0aGUgcGFyYW1ldGVycyA/IG5lZWQgdG8gYmUgY2xlYW4gQU5EIGNvbnNpc3RlbnQgd2l0aCB0aGUgZmlsdGVyIHNlYXJjaCBmbi4uLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBuZXN0ZWQgZmlsZXMvZm9sZGVycyB3aXRoIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VhcmNoIHRoZSBwcmVkaWNhdGUgdG8gdXNlIDpcbiAgICAgKiBmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBmaWxlKSB7Li4ufVxuICAgICAqIEl0IHRha2VzIDIgYXJndW1lbnRzIDogdGhlIHJlbGF0aXZlIHBhdGggYW5kIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBtYXRjaGluZyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHNlYXJjaCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBlbnRyeSkge1xuICAgICAgICAgICAgaWYgKHNlYXJjaChyZWxhdGl2ZVBhdGgsIGVudHJ5KSkgeyAvLyB0aGUgZmlsZSBtYXRjaGVzIHRoZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZmlsZSB0byB0aGUgemlwIGZpbGUsIG9yIHNlYXJjaCBhIGZpbGUuXG4gICAgICogQHBhcmFtICAge3N0cmluZ3xSZWdFeHB9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYWRkIChpZiBkYXRhIGlzIGRlZmluZWQpLFxuICAgICAqIHRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGZpbmQgKGlmIG5vIGRhdGEpIG9yIGEgcmVnZXggdG8gbWF0Y2ggZmlsZXMuXG4gICAgICogQHBhcmFtICAge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSAgVGhlIGZpbGUgZGF0YSwgZWl0aGVyIHJhdyBvciBiYXNlNjQgZW5jb2RlZFxuICAgICAqIEBwYXJhbSAgIHtPYmplY3R9IG8gICAgIEZpbGUgb3B0aW9uc1xuICAgICAqIEByZXR1cm4gIHtKU1ppcHxPYmplY3R8QXJyYXl9IHRoaXMgSlNaaXAgb2JqZWN0ICh3aGVuIGFkZGluZyBhIGZpbGUpLFxuICAgICAqIGEgZmlsZSAod2hlbiBzZWFyY2hpbmcgYnkgc3RyaW5nKSBvciBhbiBhcnJheSBvZiBmaWxlcyAod2hlbiBzZWFyY2hpbmcgYnkgcmVnZXgpLlxuICAgICAqL1xuICAgIGZpbGU6IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG8pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChpc1JlZ0V4cChuYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciByZWdleHAgPSBuYW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFmaWxlLmRpciAmJiByZWdleHAudGVzdChyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIHRleHRcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5maWxlc1t0aGlzLnJvb3QgKyBuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAob2JqICYmICFvYmouZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IDogd2UgaGF2ZSBkYXRhICFcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLnJvb3QgKyBuYW1lO1xuICAgICAgICAgICAgZmlsZUFkZC5jYWxsKHRoaXMsIG5hbWUsIGRhdGEsIG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBkaXJlY3RvcnkgdG8gdGhlIHppcCBmaWxlLCBvciBzZWFyY2guXG4gICAgICogQHBhcmFtICAge1N0cmluZ3xSZWdFeHB9IGFyZyBUaGUgbmFtZSBvZiB0aGUgZGlyZWN0b3J5IHRvIGFkZCwgb3IgYSByZWdleCB0byBzZWFyY2ggZm9sZGVycy5cbiAgICAgKiBAcmV0dXJuICB7SlNaaXB9IGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgZGlyZWN0b3J5IGFzIHRoZSByb290LCBvciBhbiBhcnJheSBjb250YWluaW5nIG1hdGNoaW5nIGZvbGRlcnMuXG4gICAgICovXG4gICAgZm9sZGVyOiBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgaWYgKCFhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUmVnRXhwKGFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5kaXIgJiYgYXJnLnRlc3QocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZWxzZSwgbmFtZSBpcyBhIG5ldyBmb2xkZXJcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnJvb3QgKyBhcmc7XG4gICAgICAgIHZhciBuZXdGb2xkZXIgPSBmb2xkZXJBZGQuY2FsbCh0aGlzLCBuYW1lKTtcblxuICAgICAgICAvLyBBbGxvdyBjaGFpbmluZyBieSByZXR1cm5pbmcgYSBuZXcgb2JqZWN0IHdpdGggdGhpcyBmb2xkZXIgYXMgdGhlIHJvb3RcbiAgICAgICAgdmFyIHJldCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmV0LnJvb3QgPSBuZXdGb2xkZXIubmFtZTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgZmlsZSwgb3IgYSBkaXJlY3RvcnkgYW5kIGFsbCBzdWItZmlsZXMsIGZyb20gdGhlIHppcFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGRlbGV0ZVxuICAgICAqIEByZXR1cm4ge0pTWmlwfSB0aGlzIEpTWmlwIG9iamVjdFxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBuYW1lID0gdGhpcy5yb290ICsgbmFtZTtcbiAgICAgICAgdmFyIGZpbGUgPSB0aGlzLmZpbGVzW25hbWVdO1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIGFueSBmb2xkZXJzXG4gICAgICAgICAgICBpZiAobmFtZS5zbGljZSgtMSkgIT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgbmFtZSArPSBcIi9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLmZpbGVzW25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbGUgJiYgIWZpbGUuZGlyKSB7XG4gICAgICAgICAgICAvLyBmaWxlXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1heWJlIGEgZm9sZGVyLCBkZWxldGUgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgIHZhciBraWRzID0gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGUubmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCkgPT09IG5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2lkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzW2tpZHNbaV0ubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGUgYXMgYW4gaW50ZXJuYWwgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZSA6XG4gICAgICogLSBjb21wcmVzc2lvbiwgXCJTVE9SRVwiIGJ5IGRlZmF1bHQuXG4gICAgICogLSB0eXBlLCBcImJhc2U2NFwiIGJ5IGRlZmF1bHQuIFZhbHVlcyBhcmUgOiBzdHJpbmcsIGJhc2U2NCwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIGJsb2IuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgc3RyZWFtZWQgemlwIGZpbGUuXG4gICAgICovXG4gICAgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgd29ya2VyLCBvcHRzID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvcHRzID0gdXRpbHMuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1GaWxlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29tcHJlc3Npb246IFwiU1RPUkVcIixcbiAgICAgICAgICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBudWxsLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiXCIsXG4gICAgICAgICAgICAgICAgcGxhdGZvcm06IFwiRE9TXCIsXG4gICAgICAgICAgICAgICAgY29tbWVudDogbnVsbCxcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi96aXBcIixcbiAgICAgICAgICAgICAgICBlbmNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZW5jb2RlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgb3B0cy50eXBlID0gb3B0cy50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBvcHRzLmNvbXByZXNzaW9uID0gb3B0cy5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICAvLyBcImJpbmFyeXN0cmluZ1wiIGlzIHByZWZlcnJlZCBidXQgdGhlIGludGVybmFscyB1c2UgXCJzdHJpbmdcIi5cbiAgICAgICAgICAgIGlmKG9wdHMudHlwZSA9PT0gXCJiaW5hcnlzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIG9wdHMudHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3B0cy50eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KG9wdHMudHlwZSk7XG5cbiAgICAgICAgICAgIC8vIGFjY2VwdCBub2RlanMgYHByb2Nlc3MucGxhdGZvcm1gXG4gICAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID09PSBcImRhcndpblwiIHx8XG4gICAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gXCJmcmVlYnNkXCIgfHxcbiAgICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID09PSBcImxpbnV4XCIgfHxcbiAgICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID09PSBcInN1bm9zXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPSBcIlVOSVhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID0gXCJET1NcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBvcHRzLmNvbW1lbnQgfHwgdGhpcy5jb21tZW50IHx8IFwiXCI7XG4gICAgICAgICAgICB3b3JrZXIgPSBnZW5lcmF0ZS5nZW5lcmF0ZVdvcmtlcih0aGlzLCBvcHRzLCBjb21tZW50KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgd29ya2VyID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgICAgIHdvcmtlci5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcih3b3JrZXIsIG9wdHMudHlwZSB8fCBcInN0cmluZ1wiLCBvcHRzLm1pbWVUeXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhc3luY2hyb25vdXNseS5cbiAgICAgKiBAc2VlIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUFzeW5jOiBmdW5jdGlvbihvcHRpb25zLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLmFjY3VtdWxhdGUob25VcGRhdGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBzZWUgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbVxuICAgICAqL1xuICAgIGdlbmVyYXRlTm9kZVN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucywgb25VcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPSBcIm5vZGVidWZmZXJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBvdXQ7XG4iXSwibmFtZXMiOlsidXRmOCIsInJlcXVpcmUiLCJ1dGlscyIsIkdlbmVyaWNXb3JrZXIiLCJTdHJlYW1IZWxwZXIiLCJkZWZhdWx0cyIsIkNvbXByZXNzZWRPYmplY3QiLCJaaXBPYmplY3QiLCJnZW5lcmF0ZSIsIm5vZGVqc1V0aWxzIiwiTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyIiwiZmlsZUFkZCIsIm5hbWUiLCJkYXRhIiwib3JpZ2luYWxPcHRpb25zIiwiZGF0YVR5cGUiLCJnZXRUeXBlT2YiLCJwYXJlbnQiLCJvIiwiZXh0ZW5kIiwiZGF0ZSIsIkRhdGUiLCJjb21wcmVzc2lvbiIsInRvVXBwZXJDYXNlIiwidW5peFBlcm1pc3Npb25zIiwicGFyc2VJbnQiLCJkaXIiLCJkb3NQZXJtaXNzaW9ucyIsImZvcmNlVHJhaWxpbmdTbGFzaCIsImNyZWF0ZUZvbGRlcnMiLCJwYXJlbnRGb2xkZXIiLCJmb2xkZXJBZGQiLCJjYWxsIiwiaXNVbmljb2RlU3RyaW5nIiwiYmluYXJ5IiwiYmFzZTY0IiwiaXNDb21wcmVzc2VkRW1wdHkiLCJ1bmNvbXByZXNzZWRTaXplIiwibGVuZ3RoIiwiemlwT2JqZWN0Q29udGVudCIsImlzTm9kZSIsImlzU3RyZWFtIiwicHJlcGFyZUNvbnRlbnQiLCJvcHRpbWl6ZWRCaW5hcnlTdHJpbmciLCJvYmplY3QiLCJmaWxlcyIsInBhdGgiLCJzbGljZSIsInN1YnN0cmluZyIsImxhc3RTbGFzaCIsImxhc3RJbmRleE9mIiwiaXNSZWdFeHAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsIm91dCIsImxvYWQiLCJFcnJvciIsImZvckVhY2giLCJjYiIsImZpbGVuYW1lIiwicmVsYXRpdmVQYXRoIiwiZmlsZSIsInJvb3QiLCJmaWx0ZXIiLCJzZWFyY2giLCJyZXN1bHQiLCJlbnRyeSIsInB1c2giLCJhcmd1bWVudHMiLCJyZWdleHAiLCJ0ZXN0Iiwib2JqIiwiZm9sZGVyIiwiYXJnIiwibmV3Rm9sZGVyIiwicmV0IiwiY2xvbmUiLCJyZW1vdmUiLCJraWRzIiwiaSIsImdlbmVyYXRlSW50ZXJuYWxTdHJlYW0iLCJvcHRpb25zIiwid29ya2VyIiwib3B0cyIsInN0cmVhbUZpbGVzIiwiY29tcHJlc3Npb25PcHRpb25zIiwidHlwZSIsInBsYXRmb3JtIiwiY29tbWVudCIsIm1pbWVUeXBlIiwiZW5jb2RlRmlsZU5hbWUiLCJ1dGY4ZW5jb2RlIiwidG9Mb3dlckNhc2UiLCJjaGVja1N1cHBvcnQiLCJnZW5lcmF0ZVdvcmtlciIsImUiLCJlcnJvciIsImdlbmVyYXRlQXN5bmMiLCJvblVwZGF0ZSIsImFjY3VtdWxhdGUiLCJnZW5lcmF0ZU5vZGVTdHJlYW0iLCJ0b05vZGVqc1N0cmVhbSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/object.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/reader/ArrayReader.js":
/*!******************************************************!*\
  !*** ./node_modules/jszip/lib/reader/ArrayReader.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar DataReader = __webpack_require__(/*! ./DataReader */ \"(ssr)/./node_modules/jszip/lib/reader/DataReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nfunction ArrayReader(data) {\n    DataReader.call(this, data);\n    for(var i = 0; i < this.data.length; i++){\n        data[i] = data[i] & 0xFF;\n    }\n}\nutils.inherits(ArrayReader, DataReader);\n/**\n * @see DataReader.byteAt\n */ ArrayReader.prototype.byteAt = function(i) {\n    return this.data[this.zero + i];\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */ ArrayReader.prototype.lastIndexOfSignature = function(sig) {\n    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);\n    for(var i = this.length - 4; i >= 0; --i){\n        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {\n            return i - this.zero;\n        }\n    }\n    return -1;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */ ArrayReader.prototype.readAndCheckSignature = function(sig) {\n    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);\n    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];\n};\n/**\n * @see DataReader.readData\n */ ArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if (size === 0) {\n        return [];\n    }\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = ArrayReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9BcnJheVJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGFBQWFDLG1CQUFPQSxDQUFDLHlFQUFjO0FBQ3ZDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLHlEQUFVO0FBRTlCLFNBQVNFLFlBQVlDLElBQUk7SUFDckJKLFdBQVdLLElBQUksQ0FBQyxJQUFJLEVBQUVEO0lBQ3RCLElBQUksSUFBSUUsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ0YsSUFBSSxDQUFDRyxNQUFNLEVBQUVELElBQUs7UUFDdENGLElBQUksQ0FBQ0UsRUFBRSxHQUFHRixJQUFJLENBQUNFLEVBQUUsR0FBRztJQUN4QjtBQUNKO0FBQ0FKLE1BQU1NLFFBQVEsQ0FBQ0wsYUFBYUg7QUFDNUI7O0NBRUMsR0FDREcsWUFBWU0sU0FBUyxDQUFDQyxNQUFNLEdBQUcsU0FBU0osQ0FBQztJQUNyQyxPQUFPLElBQUksQ0FBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQ08sSUFBSSxHQUFHTCxFQUFFO0FBQ25DO0FBQ0E7O0NBRUMsR0FDREgsWUFBWU0sU0FBUyxDQUFDRyxvQkFBb0IsR0FBRyxTQUFTQyxHQUFHO0lBQ3JELElBQUlDLE9BQU9ELElBQUlFLFVBQVUsQ0FBQyxJQUN0QkMsT0FBT0gsSUFBSUUsVUFBVSxDQUFDLElBQ3RCRSxPQUFPSixJQUFJRSxVQUFVLENBQUMsSUFDdEJHLE9BQU9MLElBQUlFLFVBQVUsQ0FBQztJQUMxQixJQUFLLElBQUlULElBQUksSUFBSSxDQUFDQyxNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHLEVBQUVBLEVBQUc7UUFDdkMsSUFBSSxJQUFJLENBQUNGLElBQUksQ0FBQ0UsRUFBRSxLQUFLUSxRQUFRLElBQUksQ0FBQ1YsSUFBSSxDQUFDRSxJQUFJLEVBQUUsS0FBS1UsUUFBUSxJQUFJLENBQUNaLElBQUksQ0FBQ0UsSUFBSSxFQUFFLEtBQUtXLFFBQVEsSUFBSSxDQUFDYixJQUFJLENBQUNFLElBQUksRUFBRSxLQUFLWSxNQUFNO1lBQzlHLE9BQU9aLElBQUksSUFBSSxDQUFDSyxJQUFJO1FBQ3hCO0lBQ0o7SUFFQSxPQUFPLENBQUM7QUFDWjtBQUNBOztDQUVDLEdBQ0RSLFlBQVlNLFNBQVMsQ0FBQ1UscUJBQXFCLEdBQUcsU0FBVU4sR0FBRztJQUN2RCxJQUFJQyxPQUFPRCxJQUFJRSxVQUFVLENBQUMsSUFDdEJDLE9BQU9ILElBQUlFLFVBQVUsQ0FBQyxJQUN0QkUsT0FBT0osSUFBSUUsVUFBVSxDQUFDLElBQ3RCRyxPQUFPTCxJQUFJRSxVQUFVLENBQUMsSUFDdEJYLE9BQU8sSUFBSSxDQUFDZ0IsUUFBUSxDQUFDO0lBQ3pCLE9BQU9OLFNBQVNWLElBQUksQ0FBQyxFQUFFLElBQUlZLFNBQVNaLElBQUksQ0FBQyxFQUFFLElBQUlhLFNBQVNiLElBQUksQ0FBQyxFQUFFLElBQUljLFNBQVNkLElBQUksQ0FBQyxFQUFFO0FBQ3ZGO0FBQ0E7O0NBRUMsR0FDREQsWUFBWU0sU0FBUyxDQUFDVyxRQUFRLEdBQUcsU0FBU0MsSUFBSTtJQUMxQyxJQUFJLENBQUNDLFdBQVcsQ0FBQ0Q7SUFDakIsSUFBR0EsU0FBUyxHQUFHO1FBQ1gsT0FBTyxFQUFFO0lBQ2I7SUFDQSxJQUFJRSxTQUFTLElBQUksQ0FBQ25CLElBQUksQ0FBQ29CLEtBQUssQ0FBQyxJQUFJLENBQUNiLElBQUksR0FBRyxJQUFJLENBQUNjLEtBQUssRUFBRSxJQUFJLENBQUNkLElBQUksR0FBRyxJQUFJLENBQUNjLEtBQUssR0FBR0o7SUFDOUUsSUFBSSxDQUFDSSxLQUFLLElBQUlKO0lBQ2QsT0FBT0U7QUFDWDtBQUNBRyxPQUFPQyxPQUFPLEdBQUd4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BwdHgtb3B0aW1pemVyLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvQXJyYXlSZWFkZXIuanM/ZjNmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBEYXRhUmVhZGVyID0gcmVxdWlyZShcIi4vRGF0YVJlYWRlclwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcblxuZnVuY3Rpb24gQXJyYXlSZWFkZXIoZGF0YSkge1xuICAgIERhdGFSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSBkYXRhW2ldICYgMHhGRjtcbiAgICB9XG59XG51dGlscy5pbmhlcml0cyhBcnJheVJlYWRlciwgRGF0YVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5ieXRlQXRcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLmJ5dGVBdCA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuemVybyArIGldO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlXG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHZhciBzaWcwID0gc2lnLmNoYXJDb2RlQXQoMCksXG4gICAgICAgIHNpZzEgPSBzaWcuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgc2lnMiA9IHNpZy5jaGFyQ29kZUF0KDIpLFxuICAgICAgICBzaWczID0gc2lnLmNoYXJDb2RlQXQoMyk7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gNDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PT0gc2lnMCAmJiB0aGlzLmRhdGFbaSArIDFdID09PSBzaWcxICYmIHRoaXMuZGF0YVtpICsgMl0gPT09IHNpZzIgJiYgdGhpcy5kYXRhW2kgKyAzXSA9PT0gc2lnMykge1xuICAgICAgICAgICAgcmV0dXJuIGkgLSB0aGlzLnplcm87XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlXG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkQW5kQ2hlY2tTaWduYXR1cmUgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgdmFyIHNpZzAgPSBzaWcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgc2lnMSA9IHNpZy5jaGFyQ29kZUF0KDEpLFxuICAgICAgICBzaWcyID0gc2lnLmNoYXJDb2RlQXQoMiksXG4gICAgICAgIHNpZzMgPSBzaWcuY2hhckNvZGVBdCgzKSxcbiAgICAgICAgZGF0YSA9IHRoaXMucmVhZERhdGEoNCk7XG4gICAgcmV0dXJuIHNpZzAgPT09IGRhdGFbMF0gJiYgc2lnMSA9PT0gZGF0YVsxXSAmJiBzaWcyID09PSBkYXRhWzJdICYmIHNpZzMgPT09IGRhdGFbM107XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgaWYoc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXlSZWFkZXI7XG4iXSwibmFtZXMiOlsiRGF0YVJlYWRlciIsInJlcXVpcmUiLCJ1dGlscyIsIkFycmF5UmVhZGVyIiwiZGF0YSIsImNhbGwiLCJpIiwibGVuZ3RoIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJieXRlQXQiLCJ6ZXJvIiwibGFzdEluZGV4T2ZTaWduYXR1cmUiLCJzaWciLCJzaWcwIiwiY2hhckNvZGVBdCIsInNpZzEiLCJzaWcyIiwic2lnMyIsInJlYWRBbmRDaGVja1NpZ25hdHVyZSIsInJlYWREYXRhIiwic2l6ZSIsImNoZWNrT2Zmc2V0IiwicmVzdWx0Iiwic2xpY2UiLCJpbmRleCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/reader/ArrayReader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/reader/DataReader.js":
/*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/reader/DataReader.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nfunction DataReader(data) {\n    this.data = data; // type : see implementation\n    this.length = data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */ checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specified index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */ checkIndex: function(newIndex) {\n        if (this.length < this.zero + newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + newIndex + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */ setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */ skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */ byteAt: function() {\n    // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */ readInt: function(size) {\n        var result = 0, i;\n        this.checkOffset(size);\n        for(i = this.index + size - 1; i >= this.index; i--){\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */ readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */ readData: function() {\n    // see implementations\n    },\n    /**\n     * Find the last occurrence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurrence, -1 if not found.\n     */ lastIndexOfSignature: function() {\n    // see implementations\n    },\n    /**\n     * Read the signature (4 bytes) at the current position and compare it with sig.\n     * @param {string} sig the expected signature\n     * @return {boolean} true if the signature matches, false otherwise.\n     */ readAndCheckSignature: function() {\n    // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */ readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, (dostime >> 21 & 0x0f) - 1, dostime >> 16 & 0x1f, dostime >> 11 & 0x1f, dostime >> 5 & 0x3f, (dostime & 0x1f) << 1)); // second\n    }\n};\nmodule.exports = DataReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9EYXRhUmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMseURBQVU7QUFFOUIsU0FBU0MsV0FBV0MsSUFBSTtJQUNwQixJQUFJLENBQUNBLElBQUksR0FBR0EsTUFBTSw0QkFBNEI7SUFDOUMsSUFBSSxDQUFDQyxNQUFNLEdBQUdELEtBQUtDLE1BQU07SUFDekIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLElBQUksR0FBRztBQUNoQjtBQUNBSixXQUFXSyxTQUFTLEdBQUc7SUFDbkI7Ozs7S0FJQyxHQUNEQyxhQUFhLFNBQVNDLE1BQU07UUFDeEIsSUFBSSxDQUFDQyxVQUFVLENBQUMsSUFBSSxDQUFDTCxLQUFLLEdBQUdJO0lBQ2pDO0lBQ0E7Ozs7S0FJQyxHQUNEQyxZQUFZLFNBQVNDLFFBQVE7UUFDekIsSUFBSSxJQUFJLENBQUNQLE1BQU0sR0FBRyxJQUFJLENBQUNFLElBQUksR0FBR0ssWUFBWUEsV0FBVyxHQUFHO1lBQ3BELE1BQU0sSUFBSUMsTUFBTSx3Q0FBd0MsSUFBSSxDQUFDUixNQUFNLEdBQUcscUJBQXNCTyxXQUFZO1FBQzVHO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0RFLFVBQVUsU0FBU0YsUUFBUTtRQUN2QixJQUFJLENBQUNELFVBQVUsQ0FBQ0M7UUFDaEIsSUFBSSxDQUFDTixLQUFLLEdBQUdNO0lBQ2pCO0lBQ0E7Ozs7S0FJQyxHQUNERyxNQUFNLFNBQVNDLENBQUM7UUFDWixJQUFJLENBQUNGLFFBQVEsQ0FBQyxJQUFJLENBQUNSLEtBQUssR0FBR1U7SUFDL0I7SUFDQTs7OztLQUlDLEdBQ0RDLFFBQVE7SUFDSixzQkFBc0I7SUFDMUI7SUFDQTs7OztLQUlDLEdBQ0RDLFNBQVMsU0FBU0MsSUFBSTtRQUNsQixJQUFJQyxTQUFTLEdBQ1RDO1FBQ0osSUFBSSxDQUFDWixXQUFXLENBQUNVO1FBQ2pCLElBQUtFLElBQUksSUFBSSxDQUFDZixLQUFLLEdBQUdhLE9BQU8sR0FBR0UsS0FBSyxJQUFJLENBQUNmLEtBQUssRUFBRWUsSUFBSztZQUNsREQsU0FBUyxDQUFDQSxVQUFVLEtBQUssSUFBSSxDQUFDSCxNQUFNLENBQUNJO1FBQ3pDO1FBQ0EsSUFBSSxDQUFDZixLQUFLLElBQUlhO1FBQ2QsT0FBT0M7SUFDWDtJQUNBOzs7O0tBSUMsR0FDREUsWUFBWSxTQUFTSCxJQUFJO1FBQ3JCLE9BQU9sQixNQUFNc0IsV0FBVyxDQUFDLFVBQVUsSUFBSSxDQUFDQyxRQUFRLENBQUNMO0lBQ3JEO0lBQ0E7Ozs7S0FJQyxHQUNESyxVQUFVO0lBQ04sc0JBQXNCO0lBQzFCO0lBQ0E7Ozs7S0FJQyxHQUNEQyxzQkFBc0I7SUFDbEIsc0JBQXNCO0lBQzFCO0lBQ0E7Ozs7S0FJQyxHQUNEQyx1QkFBdUI7SUFDbkIsc0JBQXNCO0lBQzFCO0lBQ0E7OztLQUdDLEdBQ0RDLFVBQVU7UUFDTixJQUFJQyxVQUFVLElBQUksQ0FBQ1YsT0FBTyxDQUFDO1FBQzNCLE9BQU8sSUFBSVcsS0FBS0EsS0FBS0MsR0FBRyxDQUNwQixDQUFDLFdBQVksS0FBTSxJQUFHLElBQUssTUFDM0IsQ0FBQyxXQUFZLEtBQU0sSUFBRyxJQUFLLEdBQzNCLFdBQVksS0FBTSxNQUNsQixXQUFZLEtBQU0sTUFDbEIsV0FBWSxJQUFLLE1BQ2pCLENBQUNGLFVBQVUsSUFBRyxLQUFNLEtBQUssU0FBUztJQUMxQztBQUNKO0FBQ0FHLE9BQU9DLE9BQU8sR0FBRzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1vcHRpbWl6ZXIvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9EYXRhUmVhZGVyLmpzP2NiZWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5cbmZ1bmN0aW9uIERhdGFSZWFkZXIoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7IC8vIHR5cGUgOiBzZWUgaW1wbGVtZW50YXRpb25cbiAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMuemVybyA9IDA7XG59XG5EYXRhUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBvZmZzZXQgd2lsbCBub3QgZ28gdG9vIGZhci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2Zmc2V0IHRoZSBhZGRpdGlvbmFsIG9mZnNldCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIGNoZWNrT2Zmc2V0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5jaGVja0luZGV4KHRoaXMuaW5kZXggKyBvZmZzZXQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgc3BlY2lmaWVkIGluZGV4IHdpbGwgbm90IGJlIHRvbyBmYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0luZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMuXG4gICAgICovXG4gICAgY2hlY2tJbmRleDogZnVuY3Rpb24obmV3SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgdGhpcy56ZXJvICsgbmV3SW5kZXggfHwgbmV3SW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmQgb2YgZGF0YSByZWFjaGVkIChkYXRhIGxlbmd0aCA9IFwiICsgdGhpcy5sZW5ndGggKyBcIiwgYXNrZWQgaW5kZXggPSBcIiArIChuZXdJbmRleCkgKyBcIikuIENvcnJ1cHRlZCB6aXAgP1wiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SW5kZXggVGhlIG5ldyBpbmRleC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG5ldyBpbmRleCBpcyBvdXQgb2YgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc2V0SW5kZXg6IGZ1bmN0aW9uKG5ld0luZGV4KSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbmRleChuZXdJbmRleCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXdJbmRleDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNraXAgdGhlIG5leHQgbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBuZXcgaW5kZXggaXMgb3V0IG9mIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHNraXA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy5zZXRJbmRleCh0aGlzLmluZGV4ICsgbik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaSB0aGUgaW5kZXggdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gYSBieXRlLlxuICAgICAqL1xuICAgIGJ5dGVBdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCBudW1iZXIgd2l0aCBhIGdpdmVuIGJ5dGUgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgY29ycmVzcG9uZGluZyBudW1iZXIuXG4gICAgICovXG4gICAgcmVhZEludDogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgICAgIGZvciAoaSA9IHRoaXMuaW5kZXggKyBzaXplIC0gMTsgaSA+PSB0aGlzLmluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgOCkgKyB0aGlzLmJ5dGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgc3RyaW5nIHdpdGggYSBnaXZlbiBieXRlIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGNvcnJlc3BvbmRpbmcgc3RyaW5nLlxuICAgICAqL1xuICAgIHJlYWRTdHJpbmc6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHRoaXMucmVhZERhdGEoc2l6ZSkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHJhdyBkYXRhIHdpdGhvdXQgY29udmVyc2lvbiwgPHNpemU+IGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSByYXcgZGF0YSwgaW1wbGVtZW50YXRpb24gc3BlY2lmaWMuXG4gICAgICovXG4gICAgcmVhZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYSB6aXAgc2lnbmF0dXJlICg0IGJ5dGVzKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnIHRoZSBzaWduYXR1cmUgdG8gZmluZC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlLCAtMSBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgbGFzdEluZGV4T2ZTaWduYXR1cmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBzaWduYXR1cmUgKDQgYnl0ZXMpIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBjb21wYXJlIGl0IHdpdGggc2lnLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWcgdGhlIGV4cGVjdGVkIHNpZ25hdHVyZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHNpZ25hdHVyZSBtYXRjaGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVhZEFuZENoZWNrU2lnbmF0dXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IGRhdGUuXG4gICAgICogQHJldHVybiB7RGF0ZX0gdGhlIGRhdGUuXG4gICAgICovXG4gICAgcmVhZERhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZG9zdGltZSA9IHRoaXMucmVhZEludCg0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKFxuICAgICAgICAgICAgKChkb3N0aW1lID4+IDI1KSAmIDB4N2YpICsgMTk4MCwgLy8geWVhclxuICAgICAgICAgICAgKChkb3N0aW1lID4+IDIxKSAmIDB4MGYpIC0gMSwgLy8gbW9udGhcbiAgICAgICAgICAgIChkb3N0aW1lID4+IDE2KSAmIDB4MWYsIC8vIGRheVxuICAgICAgICAgICAgKGRvc3RpbWUgPj4gMTEpICYgMHgxZiwgLy8gaG91clxuICAgICAgICAgICAgKGRvc3RpbWUgPj4gNSkgJiAweDNmLCAvLyBtaW51dGVcbiAgICAgICAgICAgIChkb3N0aW1lICYgMHgxZikgPDwgMSkpOyAvLyBzZWNvbmRcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBEYXRhUmVhZGVyO1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIkRhdGFSZWFkZXIiLCJkYXRhIiwibGVuZ3RoIiwiaW5kZXgiLCJ6ZXJvIiwicHJvdG90eXBlIiwiY2hlY2tPZmZzZXQiLCJvZmZzZXQiLCJjaGVja0luZGV4IiwibmV3SW5kZXgiLCJFcnJvciIsInNldEluZGV4Iiwic2tpcCIsIm4iLCJieXRlQXQiLCJyZWFkSW50Iiwic2l6ZSIsInJlc3VsdCIsImkiLCJyZWFkU3RyaW5nIiwidHJhbnNmb3JtVG8iLCJyZWFkRGF0YSIsImxhc3RJbmRleE9mU2lnbmF0dXJlIiwicmVhZEFuZENoZWNrU2lnbmF0dXJlIiwicmVhZERhdGUiLCJkb3N0aW1lIiwiRGF0ZSIsIlVUQyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/reader/DataReader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/reader/NodeBufferReader.js":
/*!***********************************************************!*\
  !*** ./node_modules/jszip/lib/reader/NodeBufferReader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Uint8ArrayReader = __webpack_require__(/*! ./Uint8ArrayReader */ \"(ssr)/./node_modules/jszip/lib/reader/Uint8ArrayReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nfunction NodeBufferReader(data) {\n    Uint8ArrayReader.call(this, data);\n}\nutils.inherits(NodeBufferReader, Uint8ArrayReader);\n/**\n * @see DataReader.readData\n */ NodeBufferReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = NodeBufferReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9Ob2RlQnVmZmVyUmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsbUJBQW1CQyxtQkFBT0EsQ0FBQyxxRkFBb0I7QUFDbkQsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUMseURBQVU7QUFFOUIsU0FBU0UsaUJBQWlCQyxJQUFJO0lBQzFCSixpQkFBaUJLLElBQUksQ0FBQyxJQUFJLEVBQUVEO0FBQ2hDO0FBQ0FGLE1BQU1JLFFBQVEsQ0FBQ0gsa0JBQWtCSDtBQUVqQzs7Q0FFQyxHQUNERyxpQkFBaUJJLFNBQVMsQ0FBQ0MsUUFBUSxHQUFHLFNBQVNDLElBQUk7SUFDL0MsSUFBSSxDQUFDQyxXQUFXLENBQUNEO0lBQ2pCLElBQUlFLFNBQVMsSUFBSSxDQUFDUCxJQUFJLENBQUNRLEtBQUssQ0FBQyxJQUFJLENBQUNDLElBQUksR0FBRyxJQUFJLENBQUNDLEtBQUssRUFBRSxJQUFJLENBQUNELElBQUksR0FBRyxJQUFJLENBQUNDLEtBQUssR0FBR0w7SUFDOUUsSUFBSSxDQUFDSyxLQUFLLElBQUlMO0lBQ2QsT0FBT0U7QUFDWDtBQUNBSSxPQUFPQyxPQUFPLEdBQUdiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1vcHRpbWl6ZXIvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9Ob2RlQnVmZmVyUmVhZGVyLmpzPzUzNjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoXCIuL1VpbnQ4QXJyYXlSZWFkZXJcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5cbmZ1bmN0aW9uIE5vZGVCdWZmZXJSZWFkZXIoZGF0YSkge1xuICAgIFVpbnQ4QXJyYXlSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbn1cbnV0aWxzLmluaGVyaXRzKE5vZGVCdWZmZXJSZWFkZXIsIFVpbnQ4QXJyYXlSZWFkZXIpO1xuXG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5Ob2RlQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gTm9kZUJ1ZmZlclJlYWRlcjtcbiJdLCJuYW1lcyI6WyJVaW50OEFycmF5UmVhZGVyIiwicmVxdWlyZSIsInV0aWxzIiwiTm9kZUJ1ZmZlclJlYWRlciIsImRhdGEiLCJjYWxsIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJyZWFkRGF0YSIsInNpemUiLCJjaGVja09mZnNldCIsInJlc3VsdCIsInNsaWNlIiwiemVybyIsImluZGV4IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/reader/NodeBufferReader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/reader/StringReader.js":
/*!*******************************************************!*\
  !*** ./node_modules/jszip/lib/reader/StringReader.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar DataReader = __webpack_require__(/*! ./DataReader */ \"(ssr)/./node_modules/jszip/lib/reader/DataReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nfunction StringReader(data) {\n    DataReader.call(this, data);\n}\nutils.inherits(StringReader, DataReader);\n/**\n * @see DataReader.byteAt\n */ StringReader.prototype.byteAt = function(i) {\n    return this.data.charCodeAt(this.zero + i);\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */ StringReader.prototype.lastIndexOfSignature = function(sig) {\n    return this.data.lastIndexOf(sig) - this.zero;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */ StringReader.prototype.readAndCheckSignature = function(sig) {\n    var data = this.readData(4);\n    return sig === data;\n};\n/**\n * @see DataReader.readData\n */ StringReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    // this will work because the constructor applied the \"& 0xff\" mask.\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = StringReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9TdHJpbmdSZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxhQUFhQyxtQkFBT0EsQ0FBQyx5RUFBYztBQUN2QyxJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQyx5REFBVTtBQUU5QixTQUFTRSxhQUFhQyxJQUFJO0lBQ3RCSixXQUFXSyxJQUFJLENBQUMsSUFBSSxFQUFFRDtBQUMxQjtBQUNBRixNQUFNSSxRQUFRLENBQUNILGNBQWNIO0FBQzdCOztDQUVDLEdBQ0RHLGFBQWFJLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHLFNBQVNDLENBQUM7SUFDdEMsT0FBTyxJQUFJLENBQUNMLElBQUksQ0FBQ00sVUFBVSxDQUFDLElBQUksQ0FBQ0MsSUFBSSxHQUFHRjtBQUM1QztBQUNBOztDQUVDLEdBQ0ROLGFBQWFJLFNBQVMsQ0FBQ0ssb0JBQW9CLEdBQUcsU0FBU0MsR0FBRztJQUN0RCxPQUFPLElBQUksQ0FBQ1QsSUFBSSxDQUFDVSxXQUFXLENBQUNELE9BQU8sSUFBSSxDQUFDRixJQUFJO0FBQ2pEO0FBQ0E7O0NBRUMsR0FDRFIsYUFBYUksU0FBUyxDQUFDUSxxQkFBcUIsR0FBRyxTQUFVRixHQUFHO0lBQ3hELElBQUlULE9BQU8sSUFBSSxDQUFDWSxRQUFRLENBQUM7SUFDekIsT0FBT0gsUUFBUVQ7QUFDbkI7QUFDQTs7Q0FFQyxHQUNERCxhQUFhSSxTQUFTLENBQUNTLFFBQVEsR0FBRyxTQUFTQyxJQUFJO0lBQzNDLElBQUksQ0FBQ0MsV0FBVyxDQUFDRDtJQUNqQixvRUFBb0U7SUFDcEUsSUFBSUUsU0FBUyxJQUFJLENBQUNmLElBQUksQ0FBQ2dCLEtBQUssQ0FBQyxJQUFJLENBQUNULElBQUksR0FBRyxJQUFJLENBQUNVLEtBQUssRUFBRSxJQUFJLENBQUNWLElBQUksR0FBRyxJQUFJLENBQUNVLEtBQUssR0FBR0o7SUFDOUUsSUFBSSxDQUFDSSxLQUFLLElBQUlKO0lBQ2QsT0FBT0U7QUFDWDtBQUNBRyxPQUFPQyxPQUFPLEdBQUdwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BwdHgtb3B0aW1pemVyLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvU3RyaW5nUmVhZGVyLmpzPzQwMGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRGF0YVJlYWRlciA9IHJlcXVpcmUoXCIuL0RhdGFSZWFkZXJcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5cbmZ1bmN0aW9uIFN0cmluZ1JlYWRlcihkYXRhKSB7XG4gICAgRGF0YVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoU3RyaW5nUmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLmJ5dGVBdCA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy56ZXJvICsgaSk7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHJldHVybiB0aGlzLmRhdGEubGFzdEluZGV4T2Yoc2lnKSAtIHRoaXMuemVybztcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkQW5kQ2hlY2tTaWduYXR1cmUgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlYWREYXRhKDQpO1xuICAgIHJldHVybiBzaWcgPT09IGRhdGE7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIC8vIHRoaXMgd2lsbCB3b3JrIGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIGFwcGxpZWQgdGhlIFwiJiAweGZmXCIgbWFzay5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZ1JlYWRlcjtcbiJdLCJuYW1lcyI6WyJEYXRhUmVhZGVyIiwicmVxdWlyZSIsInV0aWxzIiwiU3RyaW5nUmVhZGVyIiwiZGF0YSIsImNhbGwiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsImJ5dGVBdCIsImkiLCJjaGFyQ29kZUF0IiwiemVybyIsImxhc3RJbmRleE9mU2lnbmF0dXJlIiwic2lnIiwibGFzdEluZGV4T2YiLCJyZWFkQW5kQ2hlY2tTaWduYXR1cmUiLCJyZWFkRGF0YSIsInNpemUiLCJjaGVja09mZnNldCIsInJlc3VsdCIsInNsaWNlIiwiaW5kZXgiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/reader/StringReader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/reader/Uint8ArrayReader.js":
/*!***********************************************************!*\
  !*** ./node_modules/jszip/lib/reader/Uint8ArrayReader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar ArrayReader = __webpack_require__(/*! ./ArrayReader */ \"(ssr)/./node_modules/jszip/lib/reader/ArrayReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nfunction Uint8ArrayReader(data) {\n    ArrayReader.call(this, data);\n}\nutils.inherits(Uint8ArrayReader, ArrayReader);\n/**\n * @see DataReader.readData\n */ Uint8ArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if (size === 0) {\n        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].\n        return new Uint8Array(0);\n    }\n    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = Uint8ArrayReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9VaW50OEFycmF5UmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsY0FBY0MsbUJBQU9BLENBQUMsMkVBQWU7QUFDekMsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUMseURBQVU7QUFFOUIsU0FBU0UsaUJBQWlCQyxJQUFJO0lBQzFCSixZQUFZSyxJQUFJLENBQUMsSUFBSSxFQUFFRDtBQUMzQjtBQUNBRixNQUFNSSxRQUFRLENBQUNILGtCQUFrQkg7QUFDakM7O0NBRUMsR0FDREcsaUJBQWlCSSxTQUFTLENBQUNDLFFBQVEsR0FBRyxTQUFTQyxJQUFJO0lBQy9DLElBQUksQ0FBQ0MsV0FBVyxDQUFDRDtJQUNqQixJQUFHQSxTQUFTLEdBQUc7UUFDWCxpRkFBaUY7UUFDakYsT0FBTyxJQUFJRSxXQUFXO0lBQzFCO0lBQ0EsSUFBSUMsU0FBUyxJQUFJLENBQUNSLElBQUksQ0FBQ1MsUUFBUSxDQUFDLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUksQ0FBQ0MsS0FBSyxFQUFFLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUksQ0FBQ0MsS0FBSyxHQUFHTjtJQUNqRixJQUFJLENBQUNNLEtBQUssSUFBSU47SUFDZCxPQUFPRztBQUNYO0FBQ0FJLE9BQU9DLE9BQU8sR0FBR2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcHR4LW9wdGltaXplci8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL1VpbnQ4QXJyYXlSZWFkZXIuanM/NTQ5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBBcnJheVJlYWRlciA9IHJlcXVpcmUoXCIuL0FycmF5UmVhZGVyXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBVaW50OEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBBcnJheVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoVWludDhBcnJheVJlYWRlciwgQXJyYXlSZWFkZXIpO1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuVWludDhBcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIC8vIGluIElFMTAsIHdoZW4gdXNpbmcgc3ViYXJyYXkoaWR4LCBpZHgpLCB3ZSBnZXQgdGhlIGFycmF5IFsweDAwXSBpbnN0ZWFkIG9mIFtdLlxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheVJlYWRlcjtcbiJdLCJuYW1lcyI6WyJBcnJheVJlYWRlciIsInJlcXVpcmUiLCJ1dGlscyIsIlVpbnQ4QXJyYXlSZWFkZXIiLCJkYXRhIiwiY2FsbCIsImluaGVyaXRzIiwicHJvdG90eXBlIiwicmVhZERhdGEiLCJzaXplIiwiY2hlY2tPZmZzZXQiLCJVaW50OEFycmF5IiwicmVzdWx0Iiwic3ViYXJyYXkiLCJ6ZXJvIiwiaW5kZXgiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/reader/Uint8ArrayReader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/reader/readerFor.js":
/*!****************************************************!*\
  !*** ./node_modules/jszip/lib/reader/readerFor.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ../support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\nvar ArrayReader = __webpack_require__(/*! ./ArrayReader */ \"(ssr)/./node_modules/jszip/lib/reader/ArrayReader.js\");\nvar StringReader = __webpack_require__(/*! ./StringReader */ \"(ssr)/./node_modules/jszip/lib/reader/StringReader.js\");\nvar NodeBufferReader = __webpack_require__(/*! ./NodeBufferReader */ \"(ssr)/./node_modules/jszip/lib/reader/NodeBufferReader.js\");\nvar Uint8ArrayReader = __webpack_require__(/*! ./Uint8ArrayReader */ \"(ssr)/./node_modules/jszip/lib/reader/Uint8ArrayReader.js\");\n/**\n * Create a reader adapted to the data.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.\n * @return {DataReader} the data reader.\n */ module.exports = function(data) {\n    var type = utils.getTypeOf(data);\n    utils.checkSupport(type);\n    if (type === \"string\" && !support.uint8array) {\n        return new StringReader(data);\n    }\n    if (type === \"nodebuffer\") {\n        return new NodeBufferReader(data);\n    }\n    if (support.uint8array) {\n        return new Uint8ArrayReader(utils.transformTo(\"uint8array\", data));\n    }\n    return new ArrayReader(utils.transformTo(\"array\", data));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9yZWFkZXJGb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQyx5REFBVTtBQUM5QixJQUFJQyxVQUFVRCxtQkFBT0EsQ0FBQyw2REFBWTtBQUNsQyxJQUFJRSxjQUFjRixtQkFBT0EsQ0FBQywyRUFBZTtBQUN6QyxJQUFJRyxlQUFlSCxtQkFBT0EsQ0FBQyw2RUFBZ0I7QUFDM0MsSUFBSUksbUJBQW1CSixtQkFBT0EsQ0FBQyxxRkFBb0I7QUFDbkQsSUFBSUssbUJBQW1CTCxtQkFBT0EsQ0FBQyxxRkFBb0I7QUFFbkQ7Ozs7Q0FJQyxHQUNETSxPQUFPQyxPQUFPLEdBQUcsU0FBVUMsSUFBSTtJQUMzQixJQUFJQyxPQUFPVixNQUFNVyxTQUFTLENBQUNGO0lBQzNCVCxNQUFNWSxZQUFZLENBQUNGO0lBQ25CLElBQUlBLFNBQVMsWUFBWSxDQUFDUixRQUFRVyxVQUFVLEVBQUU7UUFDMUMsT0FBTyxJQUFJVCxhQUFhSztJQUM1QjtJQUNBLElBQUlDLFNBQVMsY0FBYztRQUN2QixPQUFPLElBQUlMLGlCQUFpQkk7SUFDaEM7SUFDQSxJQUFJUCxRQUFRVyxVQUFVLEVBQUU7UUFDcEIsT0FBTyxJQUFJUCxpQkFBaUJOLE1BQU1jLFdBQVcsQ0FBQyxjQUFjTDtJQUNoRTtJQUNBLE9BQU8sSUFBSU4sWUFBWUgsTUFBTWMsV0FBVyxDQUFDLFNBQVNMO0FBQ3REIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1vcHRpbWl6ZXIvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9yZWFkZXJGb3IuanM/OTVjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi4vc3VwcG9ydFwiKTtcbnZhciBBcnJheVJlYWRlciA9IHJlcXVpcmUoXCIuL0FycmF5UmVhZGVyXCIpO1xudmFyIFN0cmluZ1JlYWRlciA9IHJlcXVpcmUoXCIuL1N0cmluZ1JlYWRlclwiKTtcbnZhciBOb2RlQnVmZmVyUmVhZGVyID0gcmVxdWlyZShcIi4vTm9kZUJ1ZmZlclJlYWRlclwiKTtcbnZhciBVaW50OEFycmF5UmVhZGVyID0gcmVxdWlyZShcIi4vVWludDhBcnJheVJlYWRlclwiKTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWFkZXIgYWRhcHRlZCB0byB0aGUgZGF0YS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhIHRvIHJlYWQuXG4gKiBAcmV0dXJuIHtEYXRhUmVhZGVyfSB0aGUgZGF0YSByZWFkZXIuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKTtcbiAgICB1dGlscy5jaGVja1N1cHBvcnQodHlwZSk7XG4gICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgIXN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1JlYWRlcihkYXRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZUJ1ZmZlclJlYWRlcihkYXRhKTtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXlSZWFkZXIodXRpbHMudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGRhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheVJlYWRlcih1dGlscy50cmFuc2Zvcm1UbyhcImFycmF5XCIsIGRhdGEpKTtcbn07XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwic3VwcG9ydCIsIkFycmF5UmVhZGVyIiwiU3RyaW5nUmVhZGVyIiwiTm9kZUJ1ZmZlclJlYWRlciIsIlVpbnQ4QXJyYXlSZWFkZXIiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGF0YSIsInR5cGUiLCJnZXRUeXBlT2YiLCJjaGVja1N1cHBvcnQiLCJ1aW50OGFycmF5IiwidHJhbnNmb3JtVG8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/reader/readerFor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/signature.js":
/*!*********************************************!*\
  !*** ./node_modules/jszip/lib/signature.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nexports.LOCAL_FILE_HEADER = \"PK\\x03\\x04\";\nexports.CENTRAL_FILE_HEADER = \"PK\\x01\\x02\";\nexports.CENTRAL_DIRECTORY_END = \"PK\\x05\\x06\";\nexports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\\x06\\x07\";\nexports.ZIP64_CENTRAL_DIRECTORY_END = \"PK\\x06\\x06\";\nexports.DATA_DESCRIPTOR = \"PK\\x07\\b\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSx5QkFBeUIsR0FBRztBQUM1QkEsMkJBQTJCLEdBQUc7QUFDOUJBLDZCQUE2QixHQUFHO0FBQ2hDQSx1Q0FBdUMsR0FBRztBQUMxQ0EsbUNBQW1DLEdBQUc7QUFDdENBLHVCQUF1QixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1vcHRpbWl6ZXIvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3NpZ25hdHVyZS5qcz8wMmNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5MT0NBTF9GSUxFX0hFQURFUiA9IFwiUEtcXHgwM1xceDA0XCI7XG5leHBvcnRzLkNFTlRSQUxfRklMRV9IRUFERVIgPSBcIlBLXFx4MDFcXHgwMlwiO1xuZXhwb3J0cy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQgPSBcIlBLXFx4MDVcXHgwNlwiO1xuZXhwb3J0cy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SID0gXCJQS1xceDA2XFx4MDdcIjtcbmV4cG9ydHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EID0gXCJQS1xceDA2XFx4MDZcIjtcbmV4cG9ydHMuREFUQV9ERVNDUklQVE9SID0gXCJQS1xceDA3XFx4MDhcIjtcbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwiTE9DQUxfRklMRV9IRUFERVIiLCJDRU5UUkFMX0ZJTEVfSEVBREVSIiwiQ0VOVFJBTF9ESVJFQ1RPUllfRU5EIiwiWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiIsIlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCIsIkRBVEFfREVTQ1JJUFRPUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/stream/ConvertWorker.js":
/*!********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/ConvertWorker.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\n/**\n * A worker which convert chunks to a specified type.\n * @constructor\n * @param {String} destType the destination type.\n */ function ConvertWorker(destType) {\n    GenericWorker.call(this, \"ConvertWorker to \" + destType);\n    this.destType = destType;\n}\nutils.inherits(ConvertWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ ConvertWorker.prototype.processChunk = function(chunk) {\n    this.push({\n        data: utils.transformTo(this.destType, chunk.data),\n        meta: chunk.meta\n    });\n};\nmodule.exports = ConvertWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9Db252ZXJ0V29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsZ0JBQWdCQyxtQkFBT0EsQ0FBQywrRUFBaUI7QUFDN0MsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUMseURBQVU7QUFFOUI7Ozs7Q0FJQyxHQUNELFNBQVNFLGNBQWNDLFFBQVE7SUFDM0JKLGNBQWNLLElBQUksQ0FBQyxJQUFJLEVBQUUsc0JBQXNCRDtJQUMvQyxJQUFJLENBQUNBLFFBQVEsR0FBR0E7QUFDcEI7QUFDQUYsTUFBTUksUUFBUSxDQUFDSCxlQUFlSDtBQUU5Qjs7Q0FFQyxHQUNERyxjQUFjSSxTQUFTLENBQUNDLFlBQVksR0FBRyxTQUFVQyxLQUFLO0lBQ2xELElBQUksQ0FBQ0MsSUFBSSxDQUFDO1FBQ05DLE1BQU9ULE1BQU1VLFdBQVcsQ0FBQyxJQUFJLENBQUNSLFFBQVEsRUFBRUssTUFBTUUsSUFBSTtRQUNsREUsTUFBT0osTUFBTUksSUFBSTtJQUNyQjtBQUNKO0FBQ0FDLE9BQU9DLE9BQU8sR0FBR1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcHR4LW9wdGltaXplci8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0NvbnZlcnRXb3JrZXIuanM/MGFjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9HZW5lcmljV29ya2VyXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNvbnZlcnQgY2h1bmtzIHRvIGEgc3BlY2lmaWVkIHR5cGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0VHlwZSB0aGUgZGVzdGluYXRpb24gdHlwZS5cbiAqL1xuZnVuY3Rpb24gQ29udmVydFdvcmtlcihkZXN0VHlwZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkNvbnZlcnRXb3JrZXIgdG8gXCIgKyBkZXN0VHlwZSk7XG4gICAgdGhpcy5kZXN0VHlwZSA9IGRlc3RUeXBlO1xufVxudXRpbHMuaW5oZXJpdHMoQ29udmVydFdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5Db252ZXJ0V29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogdXRpbHMudHJhbnNmb3JtVG8odGhpcy5kZXN0VHlwZSwgY2h1bmsuZGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb252ZXJ0V29ya2VyO1xuIl0sIm5hbWVzIjpbIkdlbmVyaWNXb3JrZXIiLCJyZXF1aXJlIiwidXRpbHMiLCJDb252ZXJ0V29ya2VyIiwiZGVzdFR5cGUiLCJjYWxsIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJwcm9jZXNzQ2h1bmsiLCJjaHVuayIsInB1c2giLCJkYXRhIiwidHJhbnNmb3JtVG8iLCJtZXRhIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/stream/ConvertWorker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/stream/Crc32Probe.js":
/*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/stream/Crc32Probe.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nvar crc32 = __webpack_require__(/*! ../crc32 */ \"(ssr)/./node_modules/jszip/lib/crc32.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\n/**\n * A worker which calculate the crc32 of the data flowing through.\n * @constructor\n */ function Crc32Probe() {\n    GenericWorker.call(this, \"Crc32Probe\");\n    this.withStreamInfo(\"crc32\", 0);\n}\nutils.inherits(Crc32Probe, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ Crc32Probe.prototype.processChunk = function(chunk) {\n    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);\n    this.push(chunk);\n};\nmodule.exports = Crc32Probe;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9DcmMzMlByb2JlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsZ0JBQWdCQyxtQkFBT0EsQ0FBQywrRUFBaUI7QUFDN0MsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUMseURBQVU7QUFDOUIsSUFBSUUsUUFBUUYsbUJBQU9BLENBQUMseURBQVU7QUFFOUI7OztDQUdDLEdBQ0QsU0FBU0c7SUFDTEosY0FBY0ssSUFBSSxDQUFDLElBQUksRUFBRTtJQUN6QixJQUFJLENBQUNDLGNBQWMsQ0FBQyxTQUFTO0FBQ2pDO0FBQ0FILE1BQU1JLFFBQVEsQ0FBQ0gsWUFBWUo7QUFFM0I7O0NBRUMsR0FDREksV0FBV0ksU0FBUyxDQUFDQyxZQUFZLEdBQUcsU0FBVUMsS0FBSztJQUMvQyxJQUFJLENBQUNDLFVBQVUsQ0FBQ1QsS0FBSyxHQUFHQSxNQUFNUSxNQUFNRSxJQUFJLEVBQUUsSUFBSSxDQUFDRCxVQUFVLENBQUNULEtBQUssSUFBSTtJQUNuRSxJQUFJLENBQUNXLElBQUksQ0FBQ0g7QUFDZDtBQUNBSSxPQUFPQyxPQUFPLEdBQUdYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1vcHRpbWl6ZXIvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9DcmMzMlByb2JlLmpzPzIxODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vR2VuZXJpY1dvcmtlclwiKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoXCIuLi9jcmMzMlwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjYWxjdWxhdGUgdGhlIGNyYzMyIG9mIHRoZSBkYXRhIGZsb3dpbmcgdGhyb3VnaC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDcmMzMlByb2JlKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkNyYzMyUHJvYmVcIik7XG4gICAgdGhpcy53aXRoU3RyZWFtSW5mbyhcImNyYzMyXCIsIDApO1xufVxudXRpbHMuaW5oZXJpdHMoQ3JjMzJQcm9iZSwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5DcmMzMlByb2JlLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnN0cmVhbUluZm8uY3JjMzIgPSBjcmMzMihjaHVuay5kYXRhLCB0aGlzLnN0cmVhbUluZm8uY3JjMzIgfHwgMCk7XG4gICAgdGhpcy5wdXNoKGNodW5rKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IENyYzMyUHJvYmU7XG4iXSwibmFtZXMiOlsiR2VuZXJpY1dvcmtlciIsInJlcXVpcmUiLCJjcmMzMiIsInV0aWxzIiwiQ3JjMzJQcm9iZSIsImNhbGwiLCJ3aXRoU3RyZWFtSW5mbyIsImluaGVyaXRzIiwicHJvdG90eXBlIiwicHJvY2Vzc0NodW5rIiwiY2h1bmsiLCJzdHJlYW1JbmZvIiwiZGF0YSIsInB1c2giLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/stream/Crc32Probe.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/stream/DataLengthProbe.js":
/*!**********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/DataLengthProbe.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\n/**\n * A worker which calculate the total length of the data flowing through.\n * @constructor\n * @param {String} propName the name used to expose the length\n */ function DataLengthProbe(propName) {\n    GenericWorker.call(this, \"DataLengthProbe for \" + propName);\n    this.propName = propName;\n    this.withStreamInfo(propName, 0);\n}\nutils.inherits(DataLengthProbe, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ DataLengthProbe.prototype.processChunk = function(chunk) {\n    if (chunk) {\n        var length = this.streamInfo[this.propName] || 0;\n        this.streamInfo[this.propName] = length + chunk.data.length;\n    }\n    GenericWorker.prototype.processChunk.call(this, chunk);\n};\nmodule.exports = DataLengthProbe;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQyx5REFBVTtBQUM5QixJQUFJQyxnQkFBZ0JELG1CQUFPQSxDQUFDLCtFQUFpQjtBQUU3Qzs7OztDQUlDLEdBQ0QsU0FBU0UsZ0JBQWdCQyxRQUFRO0lBQzdCRixjQUFjRyxJQUFJLENBQUMsSUFBSSxFQUFFLHlCQUF5QkQ7SUFDbEQsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO0lBQ2hCLElBQUksQ0FBQ0UsY0FBYyxDQUFDRixVQUFVO0FBQ2xDO0FBQ0FKLE1BQU1PLFFBQVEsQ0FBQ0osaUJBQWlCRDtBQUVoQzs7Q0FFQyxHQUNEQyxnQkFBZ0JLLFNBQVMsQ0FBQ0MsWUFBWSxHQUFHLFNBQVVDLEtBQUs7SUFDcEQsSUFBR0EsT0FBTztRQUNOLElBQUlDLFNBQVMsSUFBSSxDQUFDQyxVQUFVLENBQUMsSUFBSSxDQUFDUixRQUFRLENBQUMsSUFBSTtRQUMvQyxJQUFJLENBQUNRLFVBQVUsQ0FBQyxJQUFJLENBQUNSLFFBQVEsQ0FBQyxHQUFHTyxTQUFTRCxNQUFNRyxJQUFJLENBQUNGLE1BQU07SUFDL0Q7SUFDQVQsY0FBY00sU0FBUyxDQUFDQyxZQUFZLENBQUNKLElBQUksQ0FBQyxJQUFJLEVBQUVLO0FBQ3BEO0FBQ0FJLE9BQU9DLE9BQU8sR0FBR1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcHR4LW9wdGltaXplci8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0RhdGFMZW5ndGhQcm9iZS5qcz8wOTllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL0dlbmVyaWNXb3JrZXJcIik7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY2FsY3VsYXRlIHRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGRhdGEgZmxvd2luZyB0aHJvdWdoLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWUgdGhlIG5hbWUgdXNlZCB0byBleHBvc2UgdGhlIGxlbmd0aFxuICovXG5mdW5jdGlvbiBEYXRhTGVuZ3RoUHJvYmUocHJvcE5hbWUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJEYXRhTGVuZ3RoUHJvYmUgZm9yIFwiICsgcHJvcE5hbWUpO1xuICAgIHRoaXMucHJvcE5hbWUgPSBwcm9wTmFtZTtcbiAgICB0aGlzLndpdGhTdHJlYW1JbmZvKHByb3BOYW1lLCAwKTtcbn1cbnV0aWxzLmluaGVyaXRzKERhdGFMZW5ndGhQcm9iZSwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5EYXRhTGVuZ3RoUHJvYmUucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmKGNodW5rKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gfHwgMDtcbiAgICAgICAgdGhpcy5zdHJlYW1JbmZvW3RoaXMucHJvcE5hbWVdID0gbGVuZ3RoICsgY2h1bmsuZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuay5jYWxsKHRoaXMsIGNodW5rKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERhdGFMZW5ndGhQcm9iZTtcblxuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIkdlbmVyaWNXb3JrZXIiLCJEYXRhTGVuZ3RoUHJvYmUiLCJwcm9wTmFtZSIsImNhbGwiLCJ3aXRoU3RyZWFtSW5mbyIsImluaGVyaXRzIiwicHJvdG90eXBlIiwicHJvY2Vzc0NodW5rIiwiY2h1bmsiLCJsZW5ndGgiLCJzdHJlYW1JbmZvIiwiZGF0YSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/stream/DataLengthProbe.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/stream/DataWorker.js":
/*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/stream/DataWorker.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\n// the size of the generated chunks\n// TODO expose this as a public variable\nvar DEFAULT_BLOCK_SIZE = 16 * 1024;\n/**\n * A worker that reads a content and emits chunks.\n * @constructor\n * @param {Promise} dataP the promise of the data to split\n */ function DataWorker(dataP) {\n    GenericWorker.call(this, \"DataWorker\");\n    var self = this;\n    this.dataIsReady = false;\n    this.index = 0;\n    this.max = 0;\n    this.data = null;\n    this.type = \"\";\n    this._tickScheduled = false;\n    dataP.then(function(data) {\n        self.dataIsReady = true;\n        self.data = data;\n        self.max = data && data.length || 0;\n        self.type = utils.getTypeOf(data);\n        if (!self.isPaused) {\n            self._tickAndRepeat();\n        }\n    }, function(e) {\n        self.error(e);\n    });\n}\nutils.inherits(DataWorker, GenericWorker);\n/**\n * @see GenericWorker.cleanUp\n */ DataWorker.prototype.cleanUp = function() {\n    GenericWorker.prototype.cleanUp.call(this);\n    this.data = null;\n};\n/**\n * @see GenericWorker.resume\n */ DataWorker.prototype.resume = function() {\n    if (!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n    if (!this._tickScheduled && this.dataIsReady) {\n        this._tickScheduled = true;\n        utils.delay(this._tickAndRepeat, [], this);\n    }\n    return true;\n};\n/**\n * Trigger a tick a schedule an other call to this function.\n */ DataWorker.prototype._tickAndRepeat = function() {\n    this._tickScheduled = false;\n    if (this.isPaused || this.isFinished) {\n        return;\n    }\n    this._tick();\n    if (!this.isFinished) {\n        utils.delay(this._tickAndRepeat, [], this);\n        this._tickScheduled = true;\n    }\n};\n/**\n * Read and push a chunk.\n */ DataWorker.prototype._tick = function() {\n    if (this.isPaused || this.isFinished) {\n        return false;\n    }\n    var size = DEFAULT_BLOCK_SIZE;\n    var data = null, nextIndex = Math.min(this.max, this.index + size);\n    if (this.index >= this.max) {\n        // EOF\n        return this.end();\n    } else {\n        switch(this.type){\n            case \"string\":\n                data = this.data.substring(this.index, nextIndex);\n                break;\n            case \"uint8array\":\n                data = this.data.subarray(this.index, nextIndex);\n                break;\n            case \"array\":\n            case \"nodebuffer\":\n                data = this.data.slice(this.index, nextIndex);\n                break;\n        }\n        this.index = nextIndex;\n        return this.push({\n            data: data,\n            meta: {\n                percent: this.max ? this.index / this.max * 100 : 0\n            }\n        });\n    }\n};\nmodule.exports = DataWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9EYXRhV29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMseURBQVU7QUFDOUIsSUFBSUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQywrRUFBaUI7QUFFN0MsbUNBQW1DO0FBQ25DLHdDQUF3QztBQUN4QyxJQUFJRSxxQkFBcUIsS0FBSztBQUU5Qjs7OztDQUlDLEdBQ0QsU0FBU0MsV0FBV0MsS0FBSztJQUNyQkgsY0FBY0ksSUFBSSxDQUFDLElBQUksRUFBRTtJQUN6QixJQUFJQyxPQUFPLElBQUk7SUFDZixJQUFJLENBQUNDLFdBQVcsR0FBRztJQUNuQixJQUFJLENBQUNDLEtBQUssR0FBRztJQUNiLElBQUksQ0FBQ0MsR0FBRyxHQUFHO0lBQ1gsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDWixJQUFJLENBQUNDLElBQUksR0FBRztJQUVaLElBQUksQ0FBQ0MsY0FBYyxHQUFHO0lBRXRCUixNQUFNUyxJQUFJLENBQUMsU0FBVUgsSUFBSTtRQUNyQkosS0FBS0MsV0FBVyxHQUFHO1FBQ25CRCxLQUFLSSxJQUFJLEdBQUdBO1FBQ1pKLEtBQUtHLEdBQUcsR0FBR0MsUUFBUUEsS0FBS0ksTUFBTSxJQUFJO1FBQ2xDUixLQUFLSyxJQUFJLEdBQUdaLE1BQU1nQixTQUFTLENBQUNMO1FBQzVCLElBQUcsQ0FBQ0osS0FBS1UsUUFBUSxFQUFFO1lBQ2ZWLEtBQUtXLGNBQWM7UUFDdkI7SUFDSixHQUFHLFNBQVVDLENBQUM7UUFDVlosS0FBS2EsS0FBSyxDQUFDRDtJQUNmO0FBQ0o7QUFFQW5CLE1BQU1xQixRQUFRLENBQUNqQixZQUFZRjtBQUUzQjs7Q0FFQyxHQUNERSxXQUFXa0IsU0FBUyxDQUFDQyxPQUFPLEdBQUc7SUFDM0JyQixjQUFjb0IsU0FBUyxDQUFDQyxPQUFPLENBQUNqQixJQUFJLENBQUMsSUFBSTtJQUN6QyxJQUFJLENBQUNLLElBQUksR0FBRztBQUNoQjtBQUVBOztDQUVDLEdBQ0RQLFdBQVdrQixTQUFTLENBQUNFLE1BQU0sR0FBRztJQUMxQixJQUFHLENBQUN0QixjQUFjb0IsU0FBUyxDQUFDRSxNQUFNLENBQUNsQixJQUFJLENBQUMsSUFBSSxHQUFHO1FBQzNDLE9BQU87SUFDWDtJQUVBLElBQUksQ0FBQyxJQUFJLENBQUNPLGNBQWMsSUFBSSxJQUFJLENBQUNMLFdBQVcsRUFBRTtRQUMxQyxJQUFJLENBQUNLLGNBQWMsR0FBRztRQUN0QmIsTUFBTXlCLEtBQUssQ0FBQyxJQUFJLENBQUNQLGNBQWMsRUFBRSxFQUFFLEVBQUUsSUFBSTtJQUM3QztJQUNBLE9BQU87QUFDWDtBQUVBOztDQUVDLEdBQ0RkLFdBQVdrQixTQUFTLENBQUNKLGNBQWMsR0FBRztJQUNsQyxJQUFJLENBQUNMLGNBQWMsR0FBRztJQUN0QixJQUFHLElBQUksQ0FBQ0ksUUFBUSxJQUFJLElBQUksQ0FBQ1MsVUFBVSxFQUFFO1FBQ2pDO0lBQ0o7SUFDQSxJQUFJLENBQUNDLEtBQUs7SUFDVixJQUFHLENBQUMsSUFBSSxDQUFDRCxVQUFVLEVBQUU7UUFDakIxQixNQUFNeUIsS0FBSyxDQUFDLElBQUksQ0FBQ1AsY0FBYyxFQUFFLEVBQUUsRUFBRSxJQUFJO1FBQ3pDLElBQUksQ0FBQ0wsY0FBYyxHQUFHO0lBQzFCO0FBQ0o7QUFFQTs7Q0FFQyxHQUNEVCxXQUFXa0IsU0FBUyxDQUFDSyxLQUFLLEdBQUc7SUFFekIsSUFBRyxJQUFJLENBQUNWLFFBQVEsSUFBSSxJQUFJLENBQUNTLFVBQVUsRUFBRTtRQUNqQyxPQUFPO0lBQ1g7SUFFQSxJQUFJRSxPQUFPekI7SUFDWCxJQUFJUSxPQUFPLE1BQU1rQixZQUFZQyxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDckIsR0FBRyxFQUFFLElBQUksQ0FBQ0QsS0FBSyxHQUFHbUI7SUFDN0QsSUFBSSxJQUFJLENBQUNuQixLQUFLLElBQUksSUFBSSxDQUFDQyxHQUFHLEVBQUU7UUFDeEIsTUFBTTtRQUNOLE9BQU8sSUFBSSxDQUFDc0IsR0FBRztJQUNuQixPQUFPO1FBQ0gsT0FBTyxJQUFJLENBQUNwQixJQUFJO1lBQ2hCLEtBQUs7Z0JBQ0RELE9BQU8sSUFBSSxDQUFDQSxJQUFJLENBQUNzQixTQUFTLENBQUMsSUFBSSxDQUFDeEIsS0FBSyxFQUFFb0I7Z0JBQ3ZDO1lBQ0osS0FBSztnQkFDRGxCLE9BQU8sSUFBSSxDQUFDQSxJQUFJLENBQUN1QixRQUFRLENBQUMsSUFBSSxDQUFDekIsS0FBSyxFQUFFb0I7Z0JBQ3RDO1lBQ0osS0FBSztZQUNMLEtBQUs7Z0JBQ0RsQixPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDd0IsS0FBSyxDQUFDLElBQUksQ0FBQzFCLEtBQUssRUFBRW9CO2dCQUNuQztRQUNKO1FBQ0EsSUFBSSxDQUFDcEIsS0FBSyxHQUFHb0I7UUFDYixPQUFPLElBQUksQ0FBQ08sSUFBSSxDQUFDO1lBQ2J6QixNQUFPQTtZQUNQMEIsTUFBTztnQkFDSEMsU0FBVSxJQUFJLENBQUM1QixHQUFHLEdBQUcsSUFBSSxDQUFDRCxLQUFLLEdBQUcsSUFBSSxDQUFDQyxHQUFHLEdBQUcsTUFBTTtZQUN2RDtRQUNKO0lBQ0o7QUFDSjtBQUVBNkIsT0FBT0MsT0FBTyxHQUFHcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcHR4LW9wdGltaXplci8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0RhdGFXb3JrZXIuanM/NDZhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9HZW5lcmljV29ya2VyXCIpO1xuXG4vLyB0aGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGNodW5rc1xuLy8gVE9ETyBleHBvc2UgdGhpcyBhcyBhIHB1YmxpYyB2YXJpYWJsZVxudmFyIERFRkFVTFRfQkxPQ0tfU0laRSA9IDE2ICogMTAyNDtcblxuLyoqXG4gKiBBIHdvcmtlciB0aGF0IHJlYWRzIGEgY29udGVudCBhbmQgZW1pdHMgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1Byb21pc2V9IGRhdGFQIHRoZSBwcm9taXNlIG9mIHRoZSBkYXRhIHRvIHNwbGl0XG4gKi9cbmZ1bmN0aW9uIERhdGFXb3JrZXIoZGF0YVApIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJEYXRhV29ya2VyXCIpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmRhdGFJc1JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5tYXggPSAwO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcblxuICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIGRhdGFQLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi5kYXRhSXNSZWFkeSA9IHRydWU7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYubWF4ID0gZGF0YSAmJiBkYXRhLmxlbmd0aCB8fCAwO1xuICAgICAgICBzZWxmLnR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSk7XG4gICAgICAgIGlmKCFzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBzZWxmLl90aWNrQW5kUmVwZWF0KCk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgIH0pO1xufVxuXG51dGlscy5pbmhlcml0cyhEYXRhV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuY2xlYW5VcFxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucmVzdW1lXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdGlja1NjaGVkdWxlZCAmJiB0aGlzLmRhdGFJc1JlYWR5KSB7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGEgdGljayBhIHNjaGVkdWxlIGFuIG90aGVyIGNhbGwgdG8gdGhpcyBmdW5jdGlvbi5cbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuX3RpY2tBbmRSZXBlYXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl90aWNrKCk7XG4gICAgaWYoIXRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVhZCBhbmQgcHVzaCBhIGNodW5rLlxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaXplID0gREVGQVVMVF9CTE9DS19TSVpFO1xuICAgIHZhciBkYXRhID0gbnVsbCwgbmV4dEluZGV4ID0gTWF0aC5taW4odGhpcy5tYXgsIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLm1heCkge1xuICAgICAgICAvLyBFT0ZcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKHRoaXMudHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhLnN1YnN0cmluZyh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ1aW50OGFycmF5XCI6XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhLnN1YmFycmF5KHRoaXMuaW5kZXgsIG5leHRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIGNhc2UgXCJub2RlYnVmZmVyXCI6XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuaW5kZXgsIG5leHRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiBkYXRhLFxuICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogdGhpcy5tYXggPyB0aGlzLmluZGV4IC8gdGhpcy5tYXggKiAxMDAgOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVdvcmtlcjtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJHZW5lcmljV29ya2VyIiwiREVGQVVMVF9CTE9DS19TSVpFIiwiRGF0YVdvcmtlciIsImRhdGFQIiwiY2FsbCIsInNlbGYiLCJkYXRhSXNSZWFkeSIsImluZGV4IiwibWF4IiwiZGF0YSIsInR5cGUiLCJfdGlja1NjaGVkdWxlZCIsInRoZW4iLCJsZW5ndGgiLCJnZXRUeXBlT2YiLCJpc1BhdXNlZCIsIl90aWNrQW5kUmVwZWF0IiwiZSIsImVycm9yIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJjbGVhblVwIiwicmVzdW1lIiwiZGVsYXkiLCJpc0ZpbmlzaGVkIiwiX3RpY2siLCJzaXplIiwibmV4dEluZGV4IiwiTWF0aCIsIm1pbiIsImVuZCIsInN1YnN0cmluZyIsInN1YmFycmF5Iiwic2xpY2UiLCJwdXNoIiwibWV0YSIsInBlcmNlbnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/stream/DataWorker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js":
/*!********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/GenericWorker.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\n/**\n * A worker that does nothing but passing chunks to the next one. This is like\n * a nodejs stream but with some differences. On the good side :\n * - it works on IE 6-9 without any issue / polyfill\n * - it weights less than the full dependencies bundled with browserify\n * - it forwards errors (no need to declare an error handler EVERYWHERE)\n *\n * A chunk is an object with 2 attributes : `meta` and `data`. The former is an\n * object containing anything (`percent` for example), see each worker for more\n * details. The latter is the real data (String, Uint8Array, etc).\n *\n * @constructor\n * @param {String} name the name of the stream (mainly used for debugging purposes)\n */ function GenericWorker(name) {\n    // the name of the worker\n    this.name = name || \"default\";\n    // an object containing metadata about the workers chain\n    this.streamInfo = {};\n    // an error which happened when the worker was paused\n    this.generatedError = null;\n    // an object containing metadata to be merged by this worker into the general metadata\n    this.extraStreamInfo = {};\n    // true if the stream is paused (and should not do anything), false otherwise\n    this.isPaused = true;\n    // true if the stream is finished (and should not do anything), false otherwise\n    this.isFinished = false;\n    // true if the stream is locked to prevent further structure updates (pipe), false otherwise\n    this.isLocked = false;\n    // the event listeners\n    this._listeners = {\n        \"data\": [],\n        \"end\": [],\n        \"error\": []\n    };\n    // the previous worker, if any\n    this.previous = null;\n}\nGenericWorker.prototype = {\n    /**\n     * Push a chunk to the next workers.\n     * @param {Object} chunk the chunk to push\n     */ push: function(chunk) {\n        this.emit(\"data\", chunk);\n    },\n    /**\n     * End the stream.\n     * @return {Boolean} true if this call ended the worker, false otherwise.\n     */ end: function() {\n        if (this.isFinished) {\n            return false;\n        }\n        this.flush();\n        try {\n            this.emit(\"end\");\n            this.cleanUp();\n            this.isFinished = true;\n        } catch (e) {\n            this.emit(\"error\", e);\n        }\n        return true;\n    },\n    /**\n     * End the stream with an error.\n     * @param {Error} e the error which caused the premature end.\n     * @return {Boolean} true if this call ended the worker with an error, false otherwise.\n     */ error: function(e) {\n        if (this.isFinished) {\n            return false;\n        }\n        if (this.isPaused) {\n            this.generatedError = e;\n        } else {\n            this.isFinished = true;\n            this.emit(\"error\", e);\n            // in the workers chain exploded in the middle of the chain,\n            // the error event will go downward but we also need to notify\n            // workers upward that there has been an error.\n            if (this.previous) {\n                this.previous.error(e);\n            }\n            this.cleanUp();\n        }\n        return true;\n    },\n    /**\n     * Add a callback on an event.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Function} listener the function to call when the event is triggered\n     * @return {GenericWorker} the current object for chainability\n     */ on: function(name, listener) {\n        this._listeners[name].push(listener);\n        return this;\n    },\n    /**\n     * Clean any references when a worker is ending.\n     */ cleanUp: function() {\n        this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n        this._listeners = [];\n    },\n    /**\n     * Trigger an event. This will call registered callback with the provided arg.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Object} arg the argument to call the callback with.\n     */ emit: function(name, arg) {\n        if (this._listeners[name]) {\n            for(var i = 0; i < this._listeners[name].length; i++){\n                this._listeners[name][i].call(this, arg);\n            }\n        }\n    },\n    /**\n     * Chain a worker with an other.\n     * @param {Worker} next the worker receiving events from the current one.\n     * @return {worker} the next worker for chainability\n     */ pipe: function(next) {\n        return next.registerPrevious(this);\n    },\n    /**\n     * Same as `pipe` in the other direction.\n     * Using an API with `pipe(next)` is very easy.\n     * Implementing the API with the point of view of the next one registering\n     * a source is easier, see the ZipFileWorker.\n     * @param {Worker} previous the previous worker, sending events to this one\n     * @return {Worker} the current worker for chainability\n     */ registerPrevious: function(previous) {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n        // sharing the streamInfo...\n        this.streamInfo = previous.streamInfo;\n        // ... and adding our own bits\n        this.mergeStreamInfo();\n        this.previous = previous;\n        var self = this;\n        previous.on(\"data\", function(chunk) {\n            self.processChunk(chunk);\n        });\n        previous.on(\"end\", function() {\n            self.end();\n        });\n        previous.on(\"error\", function(e) {\n            self.error(e);\n        });\n        return this;\n    },\n    /**\n     * Pause the stream so it doesn't send events anymore.\n     * @return {Boolean} true if this call paused the worker, false otherwise.\n     */ pause: function() {\n        if (this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = true;\n        if (this.previous) {\n            this.previous.pause();\n        }\n        return true;\n    },\n    /**\n     * Resume a paused stream.\n     * @return {Boolean} true if this call resumed the worker, false otherwise.\n     */ resume: function() {\n        if (!this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = false;\n        // if true, the worker tried to resume but failed\n        var withError = false;\n        if (this.generatedError) {\n            this.error(this.generatedError);\n            withError = true;\n        }\n        if (this.previous) {\n            this.previous.resume();\n        }\n        return !withError;\n    },\n    /**\n     * Flush any remaining bytes as the stream is ending.\n     */ flush: function() {},\n    /**\n     * Process a chunk. This is usually the method overridden.\n     * @param {Object} chunk the chunk to process.\n     */ processChunk: function(chunk) {\n        this.push(chunk);\n    },\n    /**\n     * Add a key/value to be added in the workers chain streamInfo once activated.\n     * @param {String} key the key to use\n     * @param {Object} value the associated value\n     * @return {Worker} the current worker for chainability\n     */ withStreamInfo: function(key, value) {\n        this.extraStreamInfo[key] = value;\n        this.mergeStreamInfo();\n        return this;\n    },\n    /**\n     * Merge this worker's streamInfo into the chain's streamInfo.\n     */ mergeStreamInfo: function() {\n        for(var key in this.extraStreamInfo){\n            if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {\n                continue;\n            }\n            this.streamInfo[key] = this.extraStreamInfo[key];\n        }\n    },\n    /**\n     * Lock the stream to prevent further updates on the workers chain.\n     * After calling this method, all calls to pipe will fail.\n     */ lock: function() {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n        this.isLocked = true;\n        if (this.previous) {\n            this.previous.lock();\n        }\n    },\n    /**\n     *\n     * Pretty print the workers chain.\n     */ toString: function() {\n        var me = \"Worker \" + this.name;\n        if (this.previous) {\n            return this.previous + \" -> \" + me;\n        } else {\n            return me;\n        }\n    }\n};\nmodule.exports = GenericWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9HZW5lcmljV29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWI7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELFNBQVNBLGNBQWNDLElBQUk7SUFDdkIseUJBQXlCO0lBQ3pCLElBQUksQ0FBQ0EsSUFBSSxHQUFHQSxRQUFRO0lBQ3BCLHdEQUF3RDtJQUN4RCxJQUFJLENBQUNDLFVBQVUsR0FBRyxDQUFDO0lBQ25CLHFEQUFxRDtJQUNyRCxJQUFJLENBQUNDLGNBQWMsR0FBRztJQUN0QixzRkFBc0Y7SUFDdEYsSUFBSSxDQUFDQyxlQUFlLEdBQUcsQ0FBQztJQUN4Qiw2RUFBNkU7SUFDN0UsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFDaEIsK0VBQStFO0lBQy9FLElBQUksQ0FBQ0MsVUFBVSxHQUFHO0lBQ2xCLDRGQUE0RjtJQUM1RixJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNoQixzQkFBc0I7SUFDdEIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDZCxRQUFPLEVBQUU7UUFDVCxPQUFNLEVBQUU7UUFDUixTQUFRLEVBQUU7SUFDZDtJQUNBLDhCQUE4QjtJQUM5QixJQUFJLENBQUNDLFFBQVEsR0FBRztBQUNwQjtBQUVBVCxjQUFjVSxTQUFTLEdBQUc7SUFDdEI7OztLQUdDLEdBQ0RDLE1BQU8sU0FBVUMsS0FBSztRQUNsQixJQUFJLENBQUNDLElBQUksQ0FBQyxRQUFRRDtJQUN0QjtJQUNBOzs7S0FHQyxHQUNERSxLQUFNO1FBQ0YsSUFBSSxJQUFJLENBQUNSLFVBQVUsRUFBRTtZQUNqQixPQUFPO1FBQ1g7UUFFQSxJQUFJLENBQUNTLEtBQUs7UUFDVixJQUFJO1lBQ0EsSUFBSSxDQUFDRixJQUFJLENBQUM7WUFDVixJQUFJLENBQUNHLE9BQU87WUFDWixJQUFJLENBQUNWLFVBQVUsR0FBRztRQUN0QixFQUFFLE9BQU9XLEdBQUc7WUFDUixJQUFJLENBQUNKLElBQUksQ0FBQyxTQUFTSTtRQUN2QjtR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QUFZLElBQUksQ0FBQ3pDLElBQUk7UUFDOUIsSUFBSSxJQUFJLENBQUNRLFFBQVEsRUFBRTtZQUNmLE9BQU8sSUFBSSxDQUFDQSxRQUFRLEdBQUcsU0FBU2lDO1FBQ3BDLE9BQU87WUFDSCxPQUFPQTtRQUNYO0lBQ0o7QUFDSjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BwdHgtb3B0aW1pemVyLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vR2VuZXJpY1dvcmtlci5qcz9lZmIzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgZG9lcyBub3RoaW5nIGJ1dCBwYXNzaW5nIGNodW5rcyB0byB0aGUgbmV4dCBvbmUuIFRoaXMgaXMgbGlrZVxuICogYSBub2RlanMgc3RyZWFtIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXMuIE9uIHRoZSBnb29kIHNpZGUgOlxuICogLSBpdCB3b3JrcyBvbiBJRSA2LTkgd2l0aG91dCBhbnkgaXNzdWUgLyBwb2x5ZmlsbFxuICogLSBpdCB3ZWlnaHRzIGxlc3MgdGhhbiB0aGUgZnVsbCBkZXBlbmRlbmNpZXMgYnVuZGxlZCB3aXRoIGJyb3dzZXJpZnlcbiAqIC0gaXQgZm9yd2FyZHMgZXJyb3JzIChubyBuZWVkIHRvIGRlY2xhcmUgYW4gZXJyb3IgaGFuZGxlciBFVkVSWVdIRVJFKVxuICpcbiAqIEEgY2h1bmsgaXMgYW4gb2JqZWN0IHdpdGggMiBhdHRyaWJ1dGVzIDogYG1ldGFgIGFuZCBgZGF0YWAuIFRoZSBmb3JtZXIgaXMgYW5cbiAqIG9iamVjdCBjb250YWluaW5nIGFueXRoaW5nIChgcGVyY2VudGAgZm9yIGV4YW1wbGUpLCBzZWUgZWFjaCB3b3JrZXIgZm9yIG1vcmVcbiAqIGRldGFpbHMuIFRoZSBsYXR0ZXIgaXMgdGhlIHJlYWwgZGF0YSAoU3RyaW5nLCBVaW50OEFycmF5LCBldGMpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHN0cmVhbSAobWFpbmx5IHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcylcbiAqL1xuZnVuY3Rpb24gR2VuZXJpY1dvcmtlcihuYW1lKSB7XG4gICAgLy8gdGhlIG5hbWUgb2YgdGhlIHdvcmtlclxuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgXCJkZWZhdWx0XCI7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgYWJvdXQgdGhlIHdvcmtlcnMgY2hhaW5cbiAgICB0aGlzLnN0cmVhbUluZm8gPSB7fTtcbiAgICAvLyBhbiBlcnJvciB3aGljaCBoYXBwZW5lZCB3aGVuIHRoZSB3b3JrZXIgd2FzIHBhdXNlZFxuICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBudWxsO1xuICAgIC8vIGFuIG9iamVjdCBjb250YWluaW5nIG1ldGFkYXRhIHRvIGJlIG1lcmdlZCBieSB0aGlzIHdvcmtlciBpbnRvIHRoZSBnZW5lcmFsIG1ldGFkYXRhXG4gICAgdGhpcy5leHRyYVN0cmVhbUluZm8gPSB7fTtcbiAgICAvLyB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgcGF1c2VkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCAoYW5kIHNob3VsZCBub3QgZG8gYW55dGhpbmcpLCBmYWxzZSBvdGhlcndpc2VcbiAgICB0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAvLyB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgbG9ja2VkIHRvIHByZXZlbnQgZnVydGhlciBzdHJ1Y3R1cmUgdXBkYXRlcyAocGlwZSksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAvLyB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge1xuICAgICAgICBcImRhdGFcIjpbXSxcbiAgICAgICAgXCJlbmRcIjpbXSxcbiAgICAgICAgXCJlcnJvclwiOltdXG4gICAgfTtcbiAgICAvLyB0aGUgcHJldmlvdXMgd29ya2VyLCBpZiBhbnlcbiAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbn1cblxuR2VuZXJpY1dvcmtlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogUHVzaCBhIGNodW5rIHRvIHRoZSBuZXh0IHdvcmtlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwdXNoXG4gICAgICovXG4gICAgcHVzaCA6IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIGNodW5rKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBlbmQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW5VcCgpO1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmQgdGhlIHN0cmVhbSB3aXRoIGFuIGVycm9yLlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGUgdGhlIGVycm9yIHdoaWNoIGNhdXNlZCB0aGUgcHJlbWF0dXJlIGVuZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBlbmRlZCB0aGUgd29ya2VyIHdpdGggYW4gZXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBlcnJvciA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSk7XG5cbiAgICAgICAgICAgIC8vIGluIHRoZSB3b3JrZXJzIGNoYWluIGV4cGxvZGVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIGNoYWluLFxuICAgICAgICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IHdpbGwgZ28gZG93bndhcmQgYnV0IHdlIGFsc28gbmVlZCB0byBub3RpZnlcbiAgICAgICAgICAgIC8vIHdvcmtlcnMgdXB3YXJkIHRoYXQgdGhlcmUgaGFzIGJlZW4gYW4gZXJyb3IuXG4gICAgICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91cy5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBjYWxsYmFjayBvbiBhbiBldmVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGRhdGEsIGVuZCwgZXJyb3IpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICBvbiA6IGZ1bmN0aW9uIChuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2xlYW4gYW55IHJlZmVyZW5jZXMgd2hlbiBhIHdvcmtlciBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgY2xlYW5VcCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1JbmZvID0gdGhpcy5nZW5lcmF0ZWRFcnJvciA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGFuIGV2ZW50LiBUaGlzIHdpbGwgY2FsbCByZWdpc3RlcmVkIGNhbGxiYWNrIHdpdGggdGhlIHByb3ZpZGVkIGFyZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGRhdGEsIGVuZCwgZXJyb3IpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyB0aGUgYXJndW1lbnQgdG8gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aC5cbiAgICAgKi9cbiAgICBlbWl0IDogZnVuY3Rpb24gKG5hbWUsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW25hbWVdKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdGVuZXJzW25hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdW2ldLmNhbGwodGhpcywgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhaW4gYSB3b3JrZXIgd2l0aCBhbiBvdGhlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gbmV4dCB0aGUgd29ya2VyIHJlY2VpdmluZyBldmVudHMgZnJvbSB0aGUgY3VycmVudCBvbmUuXG4gICAgICogQHJldHVybiB7d29ya2VyfSB0aGUgbmV4dCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHBpcGUgOiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICByZXR1cm4gbmV4dC5yZWdpc3RlclByZXZpb3VzKHRoaXMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyBgcGlwZWAgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgICAgKiBVc2luZyBhbiBBUEkgd2l0aCBgcGlwZShuZXh0KWAgaXMgdmVyeSBlYXN5LlxuICAgICAqIEltcGxlbWVudGluZyB0aGUgQVBJIHdpdGggdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIG5leHQgb25lIHJlZ2lzdGVyaW5nXG4gICAgICogYSBzb3VyY2UgaXMgZWFzaWVyLCBzZWUgdGhlIFppcEZpbGVXb3JrZXIuXG4gICAgICogQHBhcmFtIHtXb3JrZXJ9IHByZXZpb3VzIHRoZSBwcmV2aW91cyB3b3JrZXIsIHNlbmRpbmcgZXZlbnRzIHRvIHRoaXMgb25lXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHJlZ2lzdGVyUHJldmlvdXMgOiBmdW5jdGlvbiAocHJldmlvdXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHJlYW0gJ1wiICsgdGhpcyArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hhcmluZyB0aGUgc3RyZWFtSW5mby4uLlxuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSBwcmV2aW91cy5zdHJlYW1JbmZvO1xuICAgICAgICAvLyAuLi4gYW5kIGFkZGluZyBvdXIgb3duIGJpdHNcbiAgICAgICAgdGhpcy5tZXJnZVN0cmVhbUluZm8oKTtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9ICBwcmV2aW91cztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwcmV2aW91cy5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBzZWxmLnByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJldmlvdXMub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIHN0cmVhbSBzbyBpdCBkb2Vzbid0IHNlbmQgZXZlbnRzIGFueW1vcmUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcGF1c2VkIHRoZSB3b3JrZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwYXVzZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcblxuICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgYSBwYXVzZWQgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIHJlc3VtZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlc3VtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoIXRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGlmIHRydWUsIHRoZSB3b3JrZXIgdHJpZWQgdG8gcmVzdW1lIGJ1dCBmYWlsZWRcbiAgICAgICAgdmFyIHdpdGhFcnJvciA9IGZhbHNlO1xuICAgICAgICBpZih0aGlzLmdlbmVyYXRlZEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKHRoaXMuZ2VuZXJhdGVkRXJyb3IpO1xuICAgICAgICAgICAgd2l0aEVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICF3aXRoRXJyb3I7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGbHVzaCBhbnkgcmVtYWluaW5nIGJ5dGVzIGFzIHRoZSBzdHJlYW0gaXMgZW5kaW5nLlxuICAgICAqL1xuICAgIGZsdXNoIDogZnVuY3Rpb24gKCkge30sXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIGNodW5rLiBUaGlzIGlzIHVzdWFsbHkgdGhlIG1ldGhvZCBvdmVycmlkZGVuLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaHVuayB0aGUgY2h1bmsgdG8gcHJvY2Vzcy5cbiAgICAgKi9cbiAgICBwcm9jZXNzQ2h1bmsgOiBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEga2V5L3ZhbHVlIHRvIGJlIGFkZGVkIGluIHRoZSB3b3JrZXJzIGNoYWluIHN0cmVhbUluZm8gb25jZSBhY3RpdmF0ZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSB0aGUga2V5IHRvIHVzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0aGUgYXNzb2NpYXRlZCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1dvcmtlcn0gdGhlIGN1cnJlbnQgd29ya2VyIGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICB3aXRoU3RyZWFtSW5mbyA6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZXh0cmFTdHJlYW1JbmZvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tZXJnZVN0cmVhbUluZm8oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNZXJnZSB0aGlzIHdvcmtlcidzIHN0cmVhbUluZm8gaW50byB0aGUgY2hhaW4ncyBzdHJlYW1JbmZvLlxuICAgICAqL1xuICAgIG1lcmdlU3RyZWFtSW5mbyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gdGhpcy5leHRyYVN0cmVhbUluZm8pIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZXh0cmFTdHJlYW1JbmZvLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUluZm9ba2V5XSA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvW2tleV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9jayB0aGUgc3RyZWFtIHRvIHByZXZlbnQgZnVydGhlciB1cGRhdGVzIG9uIHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsIGFsbCBjYWxscyB0byBwaXBlIHdpbGwgZmFpbC5cbiAgICAgKi9cbiAgICBsb2NrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RyZWFtICdcIiArIHRoaXMgKyBcIicgaGFzIGFscmVhZHkgYmVlbiB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMubG9jaygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUHJldHR5IHByaW50IHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqL1xuICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWUgPSBcIldvcmtlciBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzICsgXCIgLT4gXCIgKyBtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VuZXJpY1dvcmtlcjtcbiJdLCJuYW1lcyI6WyJHZW5lcmljV29ya2VyIiwibmFtZSIsInN0cmVhbUluZm8iLCJnZW5lcmF0ZWRFcnJvciIsImV4dHJhU3RyZWFtSW5mbyIsImlzUGF1c2VkIiwiaXNGaW5pc2hlZCIsImlzTG9ja2VkIiwiX2xpc3RlbmVycyIsInByZXZpb3VzIiwicHJvdG90eXBlIiwicHVzaCIsImNodW5rIiwiZW1pdCIsImVuZCIsImZsdXNoIiwiY2xlYW5VcCIsImUiLCJlcnJvciIsIm9uIiwibGlzdGVuZXIiLCJhcmciLCJpIiwibGVuZ3RoIiwiY2FsbCIsInBpcGUiLCJuZXh0IiwicmVnaXN0ZXJQcmV2aW91cyIsIkVycm9yIiwibWVyZ2VTdHJlYW1JbmZvIiwic2VsZiIsInByb2Nlc3NDaHVuayIsInBhdXNlIiwicmVzdW1lIiwid2l0aEVycm9yIiwid2l0aFN0cmVhbUluZm8iLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwibG9jayIsInRvU3RyaW5nIiwibWUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/stream/StreamHelper.js":
/*!*******************************************************!*\
  !*** ./node_modules/jszip/lib/stream/StreamHelper.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar ConvertWorker = __webpack_require__(/*! ./ConvertWorker */ \"(ssr)/./node_modules/jszip/lib/stream/ConvertWorker.js\");\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nvar base64 = __webpack_require__(/*! ../base64 */ \"(ssr)/./node_modules/jszip/lib/base64.js\");\nvar support = __webpack_require__(/*! ../support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\nvar external = __webpack_require__(/*! ../external */ \"(ssr)/./node_modules/jszip/lib/external.js\");\nvar NodejsStreamOutputAdapter = null;\nif (support.nodestream) {\n    try {\n        NodejsStreamOutputAdapter = __webpack_require__(/*! ../nodejs/NodejsStreamOutputAdapter */ \"(ssr)/./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js\");\n    } catch (e) {\n    // ignore\n    }\n}\n/**\n * Apply the final transformation of the data. If the user wants a Blob for\n * example, it's easier to work with an U8intArray and finally do the\n * ArrayBuffer/Blob conversion.\n * @param {String} type the name of the final type\n * @param {String|Uint8Array|Buffer} content the content to transform\n * @param {String} mimeType the mime type of the content, if applicable.\n * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.\n */ function transformZipOutput(type, content, mimeType) {\n    switch(type){\n        case \"blob\":\n            return utils.newBlob(utils.transformTo(\"arraybuffer\", content), mimeType);\n        case \"base64\":\n            return base64.encode(content);\n        default:\n            return utils.transformTo(type, content);\n    }\n}\n/**\n * Concatenate an array of data of the given type.\n * @param {String} type the type of the data in the given array.\n * @param {Array} dataArray the array containing the data chunks to concatenate\n * @return {String|Uint8Array|Buffer} the concatenated data\n * @throws Error if the asked type is unsupported\n */ function concat(type, dataArray) {\n    var i, index = 0, res = null, totalLength = 0;\n    for(i = 0; i < dataArray.length; i++){\n        totalLength += dataArray[i].length;\n    }\n    switch(type){\n        case \"string\":\n            return dataArray.join(\"\");\n        case \"array\":\n            return Array.prototype.concat.apply([], dataArray);\n        case \"uint8array\":\n            res = new Uint8Array(totalLength);\n            for(i = 0; i < dataArray.length; i++){\n                res.set(dataArray[i], index);\n                index += dataArray[i].length;\n            }\n            return res;\n        case \"nodebuffer\":\n            return Buffer.concat(dataArray);\n        default:\n            throw new Error(\"concat : unsupported type '\" + type + \"'\");\n    }\n}\n/**\n * Listen a StreamHelper, accumulate its content and concatenate it into a\n * complete block.\n * @param {StreamHelper} helper the helper to use.\n * @param {Function} updateCallback a callback called on each update. Called\n * with one arg :\n * - the metadata linked to the update received.\n * @return Promise the promise for the accumulation.\n */ function accumulate(helper, updateCallback) {\n    return new external.Promise(function(resolve, reject) {\n        var dataArray = [];\n        var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;\n        helper.on(\"data\", function(data, meta) {\n            dataArray.push(data);\n            if (updateCallback) {\n                updateCallback(meta);\n            }\n        }).on(\"error\", function(err) {\n            dataArray = [];\n            reject(err);\n        }).on(\"end\", function() {\n            try {\n                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n                resolve(result);\n            } catch (e) {\n                reject(e);\n            }\n            dataArray = [];\n        }).resume();\n    });\n}\n/**\n * An helper to easily use workers outside of JSZip.\n * @constructor\n * @param {Worker} worker the worker to wrap\n * @param {String} outputType the type of data expected by the use\n * @param {String} mimeType the mime type of the content, if applicable.\n */ function StreamHelper(worker, outputType, mimeType) {\n    var internalType = outputType;\n    switch(outputType){\n        case \"blob\":\n        case \"arraybuffer\":\n            internalType = \"uint8array\";\n            break;\n        case \"base64\":\n            internalType = \"string\";\n            break;\n    }\n    try {\n        // the type used internally\n        this._internalType = internalType;\n        // the type used to output results\n        this._outputType = outputType;\n        // the mime type\n        this._mimeType = mimeType;\n        utils.checkSupport(internalType);\n        this._worker = worker.pipe(new ConvertWorker(internalType));\n        // the last workers can be rewired without issues but we need to\n        // prevent any updates on previous workers.\n        worker.lock();\n    } catch (e) {\n        this._worker = new GenericWorker(\"error\");\n        this._worker.error(e);\n    }\n}\nStreamHelper.prototype = {\n    /**\n     * Listen a StreamHelper, accumulate its content and concatenate it into a\n     * complete block.\n     * @param {Function} updateCb the update callback.\n     * @return Promise the promise for the accumulation.\n     */ accumulate: function(updateCb) {\n        return accumulate(this, updateCb);\n    },\n    /**\n     * Add a listener on an event triggered on a stream.\n     * @param {String} evt the name of the event\n     * @param {Function} fn the listener\n     * @return {StreamHelper} the current helper.\n     */ on: function(evt, fn) {\n        var self = this;\n        if (evt === \"data\") {\n            this._worker.on(evt, function(chunk) {\n                fn.call(self, chunk.data, chunk.meta);\n            });\n        } else {\n            this._worker.on(evt, function() {\n                utils.delay(fn, arguments, self);\n            });\n        }\n        return this;\n    },\n    /**\n     * Resume the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */ resume: function() {\n        utils.delay(this._worker.resume, [], this._worker);\n        return this;\n    },\n    /**\n     * Pause the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */ pause: function() {\n        this._worker.pause();\n        return this;\n    },\n    /**\n     * Return a nodejs stream for this helper.\n     * @param {Function} updateCb the update callback.\n     * @return {NodejsStreamOutputAdapter} the nodejs stream.\n     */ toNodejsStream: function(updateCb) {\n        utils.checkSupport(\"nodestream\");\n        if (this._outputType !== \"nodebuffer\") {\n            // an object stream containing blob/arraybuffer/uint8array/string\n            // is strange and I don't know if it would be useful.\n            // I you find this comment and have a good usecase, please open a\n            // bug report !\n            throw new Error(this._outputType + \" is not supported by this method\");\n        }\n        return new NodejsStreamOutputAdapter(this, {\n            objectMode: this._outputType !== \"nodebuffer\"\n        }, updateCb);\n    }\n};\nmodule.exports = StreamHelper;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9TdHJlYW1IZWxwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQyx5REFBVTtBQUM5QixJQUFJQyxnQkFBZ0JELG1CQUFPQSxDQUFDLCtFQUFpQjtBQUM3QyxJQUFJRSxnQkFBZ0JGLG1CQUFPQSxDQUFDLCtFQUFpQjtBQUM3QyxJQUFJRyxTQUFTSCxtQkFBT0EsQ0FBQywyREFBVztBQUNoQyxJQUFJSSxVQUFVSixtQkFBT0EsQ0FBQyw2REFBWTtBQUNsQyxJQUFJSyxXQUFXTCxtQkFBT0EsQ0FBQywrREFBYTtBQUVwQyxJQUFJTSw0QkFBNEI7QUFDaEMsSUFBSUYsUUFBUUcsVUFBVSxFQUFFO0lBQ3BCLElBQUk7UUFDQUQsNEJBQTRCTixtQkFBT0EsQ0FBQywrR0FBcUM7SUFDN0UsRUFBRSxPQUFNUSxHQUFHO0lBQ1AsU0FBUztJQUNiO0FBQ0o7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNDLG1CQUFtQkMsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLFFBQVE7SUFDL0MsT0FBT0Y7UUFDUCxLQUFLO1lBQ0QsT0FBT1gsTUFBTWMsT0FBTyxDQUFDZCxNQUFNZSxXQUFXLENBQUMsZUFBZUgsVUFBVUM7UUFDcEUsS0FBSztZQUNELE9BQU9ULE9BQU9ZLE1BQU0sQ0FBQ0o7UUFDekI7WUFDSSxPQUFPWixNQUFNZSxXQUFXLENBQUNKLE1BQU1DO0lBQ25DO0FBQ0o7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTSyxPQUFRTixJQUFJLEVBQUVPLFNBQVM7SUFDNUIsSUFBSUMsR0FBR0MsUUFBUSxHQUFHQyxNQUFNLE1BQU1DLGNBQWM7SUFDNUMsSUFBSUgsSUFBSSxHQUFHQSxJQUFJRCxVQUFVSyxNQUFNLEVBQUVKLElBQUs7UUFDbENHLGVBQWVKLFNBQVMsQ0FBQ0MsRUFBRSxDQUFDSSxNQUFNO0lBQ3RDO0lBQ0EsT0FBT1o7UUFDUCxLQUFLO1lBQ0QsT0FBT08s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T0FBTztZQUNILElBQUksQ0FBQ1UsT0FBTyxDQUFDWixFQUFFLENBQUNpQixLQUFLO2dCQUNqQjVELE1BQU1pRSxLQUFLLENBQUNKLElBQUlLLFdBQVdKO1lBQy9CO1FBQ0o7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUNBOzs7S0FHQyxHQUNEYixRQUFTO1FBQ0xqRCxNQUFNaUUsS0FBSyxDQUFDLElBQUksQ0FBQ1YsT0FBTyxDQUFDTixNQUFNLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQ00sT0FBTztRQUNqRCxPQUFPLElBQUk7SUFDZjtJQUNBOzs7S0FHQyxHQUNEWSxPQUFRO1FBQ0osSUFBSSxDQUFDWixPQUFPLENBQUNZLEtBQUs7UUFDbEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7OztLQUlDLEdBQ0RDLGdCQUFpQixTQUFVVCxRQUFRO1FBQy9CM0QsTUFBTXNELFlBQVksQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ2IsV0FBVyxLQUFLLGNBQWM7WUFDbkMsaUVBQWlFO1lBQ2pFLHFEQUFxRDtZQUNyRCxpRUFBaUU7WUFDakUsZUFBZTtZQUNmLE1BQU0sSUFBSVYsTUFBTSxJQUFJLENBQUNVLFdBQVcsR0FBRztRQUN2QztRQUVBLE9BQU8sSUFBSWxDLDBCQUEwQixJQUFJLEVBQUU7WUFDdkM4RCxZQUFhLElBQUksQ0FBQzVCLFdBQVcsS0FBSztRQUN0QyxHQUFHa0I7SUFDUDtBQUNKO0FBR0FXLE9BQU9DLE9BQU8sR0FBR3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1vcHRpbWl6ZXIvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9TdHJlYW1IZWxwZXIuanM/MjFlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIENvbnZlcnRXb3JrZXIgPSByZXF1aXJlKFwiLi9Db252ZXJ0V29ya2VyXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9HZW5lcmljV29ya2VyXCIpO1xudmFyIGJhc2U2NCA9IHJlcXVpcmUoXCIuLi9iYXNlNjRcIik7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoXCIuLi9zdXBwb3J0XCIpO1xudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4uL2V4dGVybmFsXCIpO1xuXG52YXIgTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlciA9IG51bGw7XG5pZiAoc3VwcG9ydC5ub2Rlc3RyZWFtKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlciA9IHJlcXVpcmUoXCIuLi9ub2RlanMvTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlclwiKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxufVxuXG4vKipcbiAqIEFwcGx5IHRoZSBmaW5hbCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZGF0YS4gSWYgdGhlIHVzZXIgd2FudHMgYSBCbG9iIGZvclxuICogZXhhbXBsZSwgaXQncyBlYXNpZXIgdG8gd29yayB3aXRoIGFuIFU4aW50QXJyYXkgYW5kIGZpbmFsbHkgZG8gdGhlXG4gKiBBcnJheUJ1ZmZlci9CbG9iIGNvbnZlcnNpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgbmFtZSBvZiB0aGUgZmluYWwgdHlwZVxuICogQHBhcmFtIHtTdHJpbmd8VWludDhBcnJheXxCdWZmZXJ9IGNvbnRlbnQgdGhlIGNvbnRlbnQgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgY29udGVudCwgaWYgYXBwbGljYWJsZS5cbiAqIEByZXR1cm4ge1N0cmluZ3xVaW50OEFycmF5fEFycmF5QnVmZmVyfEJ1ZmZlcnxCbG9ifSB0aGUgY29udGVudCBpbiB0aGUgcmlnaHQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1aaXBPdXRwdXQodHlwZSwgY29udGVudCwgbWltZVR5cGUpIHtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgXCJibG9iXCIgOlxuICAgICAgICByZXR1cm4gdXRpbHMubmV3QmxvYih1dGlscy50cmFuc2Zvcm1UbyhcImFycmF5YnVmZmVyXCIsIGNvbnRlbnQpLCBtaW1lVHlwZSk7XG4gICAgY2FzZSBcImJhc2U2NFwiIDpcbiAgICAgICAgcmV0dXJuIGJhc2U2NC5lbmNvZGUoY29udGVudCk7XG4gICAgZGVmYXVsdCA6XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1Ubyh0eXBlLCBjb250ZW50KTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29uY2F0ZW5hdGUgYW4gYXJyYXkgb2YgZGF0YSBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBkYXRhIGluIHRoZSBnaXZlbiBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGFBcnJheSB0aGUgYXJyYXkgY29udGFpbmluZyB0aGUgZGF0YSBjaHVua3MgdG8gY29uY2F0ZW5hdGVcbiAqIEByZXR1cm4ge1N0cmluZ3xVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIGNvbmNhdGVuYXRlZCBkYXRhXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBhc2tlZCB0eXBlIGlzIHVuc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCAodHlwZSwgZGF0YUFycmF5KSB7XG4gICAgdmFyIGksIGluZGV4ID0gMCwgcmVzID0gbnVsbCwgdG90YWxMZW5ndGggPSAwO1xuICAgIGZvcihpID0gMDsgaSA8IGRhdGFBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbExlbmd0aCArPSBkYXRhQXJyYXlbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgcmV0dXJuIGRhdGFBcnJheS5qb2luKFwiXCIpO1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgZGF0YUFycmF5KTtcbiAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICByZXMgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGRhdGFBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzLnNldChkYXRhQXJyYXlbaV0sIGluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ICs9IGRhdGFBcnJheVtpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICBjYXNlIFwibm9kZWJ1ZmZlclwiOlxuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChkYXRhQXJyYXkpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmNhdCA6IHVuc3VwcG9ydGVkIHR5cGUgJ1wiICArIHR5cGUgKyBcIidcIik7XG4gICAgfVxufVxuXG4vKipcbiAqIExpc3RlbiBhIFN0cmVhbUhlbHBlciwgYWNjdW11bGF0ZSBpdHMgY29udGVudCBhbmQgY29uY2F0ZW5hdGUgaXQgaW50byBhXG4gKiBjb21wbGV0ZSBibG9jay5cbiAqIEBwYXJhbSB7U3RyZWFtSGVscGVyfSBoZWxwZXIgdGhlIGhlbHBlciB0byB1c2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYWxsYmFjayBhIGNhbGxiYWNrIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZS4gQ2FsbGVkXG4gKiB3aXRoIG9uZSBhcmcgOlxuICogLSB0aGUgbWV0YWRhdGEgbGlua2VkIHRvIHRoZSB1cGRhdGUgcmVjZWl2ZWQuXG4gKiBAcmV0dXJuIFByb21pc2UgdGhlIHByb21pc2UgZm9yIHRoZSBhY2N1bXVsYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGUoaGVscGVyLCB1cGRhdGVDYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB2YXIgY2h1bmtUeXBlID0gaGVscGVyLl9pbnRlcm5hbFR5cGUsXG4gICAgICAgICAgICByZXN1bHRUeXBlID0gaGVscGVyLl9vdXRwdXRUeXBlLFxuICAgICAgICAgICAgbWltZVR5cGUgPSBoZWxwZXIuX21pbWVUeXBlO1xuICAgICAgICBoZWxwZXJcbiAgICAgICAgICAgIC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGRhdGEsIG1ldGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhQXJyYXkucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICBpZih1cGRhdGVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDYWxsYmFjayhtZXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgZGF0YUFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cmFuc2Zvcm1aaXBPdXRwdXQocmVzdWx0VHlwZSwgY29uY2F0KGNodW5rVHlwZSwgZGF0YUFycmF5KSwgbWltZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN1bWUoKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBbiBoZWxwZXIgdG8gZWFzaWx5IHVzZSB3b3JrZXJzIG91dHNpZGUgb2YgSlNaaXAuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7V29ya2VyfSB3b3JrZXIgdGhlIHdvcmtlciB0byB3cmFwXG4gKiBAcGFyYW0ge1N0cmluZ30gb3V0cHV0VHlwZSB0aGUgdHlwZSBvZiBkYXRhIGV4cGVjdGVkIGJ5IHRoZSB1c2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBjb250ZW50LCBpZiBhcHBsaWNhYmxlLlxuICovXG5mdW5jdGlvbiBTdHJlYW1IZWxwZXIod29ya2VyLCBvdXRwdXRUeXBlLCBtaW1lVHlwZSkge1xuICAgIHZhciBpbnRlcm5hbFR5cGUgPSBvdXRwdXRUeXBlO1xuICAgIHN3aXRjaChvdXRwdXRUeXBlKSB7XG4gICAgY2FzZSBcImJsb2JcIjpcbiAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgaW50ZXJuYWxUeXBlID0gXCJ1aW50OGFycmF5XCI7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgaW50ZXJuYWxUeXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gdGhlIHR5cGUgdXNlZCBpbnRlcm5hbGx5XG4gICAgICAgIHRoaXMuX2ludGVybmFsVHlwZSA9IGludGVybmFsVHlwZTtcbiAgICAgICAgLy8gdGhlIHR5cGUgdXNlZCB0byBvdXRwdXQgcmVzdWx0c1xuICAgICAgICB0aGlzLl9vdXRwdXRUeXBlID0gb3V0cHV0VHlwZTtcbiAgICAgICAgLy8gdGhlIG1pbWUgdHlwZVxuICAgICAgICB0aGlzLl9taW1lVHlwZSA9IG1pbWVUeXBlO1xuICAgICAgICB1dGlscy5jaGVja1N1cHBvcnQoaW50ZXJuYWxUeXBlKTtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gd29ya2VyLnBpcGUobmV3IENvbnZlcnRXb3JrZXIoaW50ZXJuYWxUeXBlKSk7XG4gICAgICAgIC8vIHRoZSBsYXN0IHdvcmtlcnMgY2FuIGJlIHJld2lyZWQgd2l0aG91dCBpc3N1ZXMgYnV0IHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcHJldmVudCBhbnkgdXBkYXRlcyBvbiBwcmV2aW91cyB3b3JrZXJzLlxuICAgICAgICB3b3JrZXIubG9jaygpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICB0aGlzLl93b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB0aGlzLl93b3JrZXIuZXJyb3IoZSk7XG4gICAgfVxufVxuXG5TdHJlYW1IZWxwZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIExpc3RlbiBhIFN0cmVhbUhlbHBlciwgYWNjdW11bGF0ZSBpdHMgY29udGVudCBhbmQgY29uY2F0ZW5hdGUgaXQgaW50byBhXG4gICAgICogY29tcGxldGUgYmxvY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2IgdGhlIHVwZGF0ZSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIFByb21pc2UgdGhlIHByb21pc2UgZm9yIHRoZSBhY2N1bXVsYXRpb24uXG4gICAgICovXG4gICAgYWNjdW11bGF0ZSA6IGZ1bmN0aW9uICh1cGRhdGVDYikge1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0ZSh0aGlzLCB1cGRhdGVDYik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBvbiBhbiBldmVudCB0cmlnZ2VyZWQgb24gYSBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2dCB0aGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGUgbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtTdHJlYW1IZWxwZXJ9IHRoZSBjdXJyZW50IGhlbHBlci5cbiAgICAgKi9cbiAgICBvbiA6IGZ1bmN0aW9uIChldnQsIGZuKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZihldnQgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oZXZ0LCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKHNlbGYsIGNodW5rLmRhdGEsIGNodW5rLm1ldGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oZXZ0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdXRpbHMuZGVsYXkoZm4sIGFyZ3VtZW50cywgc2VsZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSB0aGUgZmxvdyBvZiBjaHVua3MuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl93b3JrZXIucmVzdW1lLCBbXSwgdGhpcy5fd29ya2VyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgZmxvdyBvZiBjaHVua3MuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgcGF1c2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5wYXVzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5vZGVqcyBzdHJlYW0gZm9yIHRoaXMgaGVscGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7Tm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcn0gdGhlIG5vZGVqcyBzdHJlYW0uXG4gICAgICovXG4gICAgdG9Ob2RlanNTdHJlYW0gOiBmdW5jdGlvbiAodXBkYXRlQ2IpIHtcbiAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KFwibm9kZXN0cmVhbVwiKTtcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dFR5cGUgIT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICAvLyBhbiBvYmplY3Qgc3RyZWFtIGNvbnRhaW5pbmcgYmxvYi9hcnJheWJ1ZmZlci91aW50OGFycmF5L3N0cmluZ1xuICAgICAgICAgICAgLy8gaXMgc3RyYW5nZSBhbmQgSSBkb24ndCBrbm93IGlmIGl0IHdvdWxkIGJlIHVzZWZ1bC5cbiAgICAgICAgICAgIC8vIEkgeW91IGZpbmQgdGhpcyBjb21tZW50IGFuZCBoYXZlIGEgZ29vZCB1c2VjYXNlLCBwbGVhc2Ugb3BlbiBhXG4gICAgICAgICAgICAvLyBidWcgcmVwb3J0ICFcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9vdXRwdXRUeXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcih0aGlzLCB7XG4gICAgICAgICAgICBvYmplY3RNb2RlIDogdGhpcy5fb3V0cHV0VHlwZSAhPT0gXCJub2RlYnVmZmVyXCJcbiAgICAgICAgfSwgdXBkYXRlQ2IpO1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1IZWxwZXI7XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiQ29udmVydFdvcmtlciIsIkdlbmVyaWNXb3JrZXIiLCJiYXNlNjQiLCJzdXBwb3J0IiwiZXh0ZXJuYWwiLCJOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyIiwibm9kZXN0cmVhbSIsImUiLCJ0cmFuc2Zvcm1aaXBPdXRwdXQiLCJ0eXBlIiwiY29udGVudCIsIm1pbWVUeXBlIiwibmV3QmxvYiIsInRyYW5zZm9ybVRvIiwiZW5jb2RlIiwiY29uY2F0IiwiZGF0YUFycmF5IiwiaSIsImluZGV4IiwicmVzIiwidG90YWxMZW5ndGgiLCJsZW5ndGgiLCJqb2luIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJCdWZmZXIiLCJFcnJvciIsImFjY3VtdWxhdGUiLCJoZWxwZXIiLCJ1cGRhdGVDYWxsYmFjayIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2h1bmtUeXBlIiwiX2ludGVybmFsVHlwZSIsInJlc3VsdFR5cGUiLCJfb3V0cHV0VHlwZSIsIl9taW1lVHlwZSIsIm9uIiwiZGF0YSIsIm1ldGEiLCJwdXNoIiwiZXJyIiwicmVzdWx0IiwicmVzdW1lIiwiU3RyZWFtSGVscGVyIiwid29ya2VyIiwib3V0cHV0VHlwZSIsImludGVybmFsVHlwZSIsImNoZWNrU3VwcG9ydCIsIl93b3JrZXIiLCJwaXBlIiwibG9jayIsImVycm9yIiwidXBkYXRlQ2IiLCJldnQiLCJmbiIsInNlbGYiLCJjaHVuayIsImNhbGwiLCJkZWxheSIsImFyZ3VtZW50cyIsInBhdXNlIiwidG9Ob2RlanNTdHJlYW0iLCJvYmplY3RNb2RlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/stream/StreamHelper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/support.js":
/*!*******************************************!*\
  !*** ./node_modules/jszip/lib/support.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nexports.base64 = true;\nexports.array = true;\nexports.string = true;\nexports.arraybuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\nexports.nodebuffer = typeof Buffer !== \"undefined\";\n// contains true if JSZip can read/generate Uint8Array, false otherwise.\nexports.uint8array = typeof Uint8Array !== \"undefined\";\nif (typeof ArrayBuffer === \"undefined\") {\n    exports.blob = false;\n} else {\n    var buffer = new ArrayBuffer(0);\n    try {\n        exports.blob = new Blob([\n            buffer\n        ], {\n            type: \"application/zip\"\n        }).size === 0;\n    } catch (e) {\n        try {\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            exports.blob = builder.getBlob(\"application/zip\").size === 0;\n        } catch (e) {\n            exports.blob = false;\n        }\n    }\n}\ntry {\n    exports.nodestream = !!(__webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/readable-stream/readable.js\").Readable);\n} catch (e) {\n    exports.nodestream = false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N1cHBvcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsY0FBYyxHQUFHO0FBQ2pCQSxhQUFhLEdBQUc7QUFDaEJBLGNBQWMsR0FBRztBQUNqQkEsbUJBQW1CLEdBQUcsT0FBT0ssZ0JBQWdCLGVBQWUsT0FBT0MsZUFBZTtBQUNsRk4sa0JBQWtCLEdBQUcsT0FBT1EsV0FBVztBQUN2Qyx3RUFBd0U7QUFDeEVSLGtCQUFrQixHQUFHLE9BQU9NLGVBQWU7QUFFM0MsSUFBSSxPQUFPRCxnQkFBZ0IsYUFBYTtJQUNwQ0wsWUFBWSxHQUFHO0FBQ25CLE9BQ0s7SUFDRCxJQUFJVyxTQUFTLElBQUlOLFlBQVk7SUFDN0IsSUFBSTtRQUNBTCxZQUFZLEdBQUcsSUFBSVksS0FBSztZQUFDRDtTQUFPLEVBQUU7WUFDOUJFLE1BQU07UUFDVixHQUFHQyxJQUFJLEtBQUs7SUFDaEIsRUFDQSxPQUFPQyxHQUFHO1FBQ04sSUFBSTtZQUNBLElBQUlDLFVBQVVDLEtBQUtDLFdBQVcsSUFBSUQsS0FBS0UsaUJBQWlCLElBQUlGLEtBQUtHLGNBQWMsSUFBSUgsS0FBS0ksYUFBYTtZQUNyRyxJQUFJQyxVQUFVLElBQUlOO1lBQ2xCTSxRQUFRQyxNQUFNLENBQUNaO1lBQ2ZYLFlBQVksR0FBR3NCLFFBQVFFLE9BQU8sQ0FBQyxtQkFBbUJWLElBQUksS0FBSztRQUMvRCxFQUNBLE9BQU9DLEdBQUc7WUFDTmYsWUFBWSxHQUFHO1FBQ25CO0lBQ0o7QUFDSjtBQUVBLElBQUk7SUFDQUEsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDMEIseUdBQW1DO0FBQzlELEVBQUUsT0FBTVgsR0FBRztJQUNQZixrQkFBa0IsR0FBRztBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BwdHgtb3B0aW1pemVyLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdXBwb3J0LmpzPzFjYmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuYmFzZTY0ID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXkgPSB0cnVlO1xuZXhwb3J0cy5zdHJpbmcgPSB0cnVlO1xuZXhwb3J0cy5hcnJheWJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcbmV4cG9ydHMubm9kZWJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCI7XG4vLyBjb250YWlucyB0cnVlIGlmIEpTWmlwIGNhbiByZWFkL2dlbmVyYXRlIFVpbnQ4QXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbmV4cG9ydHMudWludDhhcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5pZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZXhwb3J0cy5ibG9iID0gZmFsc2U7XG59XG5lbHNlIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIHRyeSB7XG4gICAgICAgIGV4cG9ydHMuYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdLCB7XG4gICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL3ppcFwiXG4gICAgICAgIH0pLnNpemUgPT09IDA7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgQnVpbGRlciA9IHNlbGYuQmxvYkJ1aWxkZXIgfHwgc2VsZi5XZWJLaXRCbG9iQnVpbGRlciB8fCBzZWxmLk1vekJsb2JCdWlsZGVyIHx8IHNlbGYuTVNCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKGJ1ZmZlcik7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBidWlsZGVyLmdldEJsb2IoXCJhcHBsaWNhdGlvbi96aXBcIikuc2l6ZSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXhwb3J0cy5ibG9iID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnRyeSB7XG4gICAgZXhwb3J0cy5ub2Rlc3RyZWFtID0gISFyZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpLlJlYWRhYmxlO1xufSBjYXRjaChlKSB7XG4gICAgZXhwb3J0cy5ub2Rlc3RyZWFtID0gZmFsc2U7XG59XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsImJhc2U2NCIsImFycmF5Iiwic3RyaW5nIiwiYXJyYXlidWZmZXIiLCJBcnJheUJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJub2RlYnVmZmVyIiwiQnVmZmVyIiwidWludDhhcnJheSIsImJsb2IiLCJidWZmZXIiLCJCbG9iIiwidHlwZSIsInNpemUiLCJlIiwiQnVpbGRlciIsInNlbGYiLCJCbG9iQnVpbGRlciIsIldlYktpdEJsb2JCdWlsZGVyIiwiTW96QmxvYkJ1aWxkZXIiLCJNU0Jsb2JCdWlsZGVyIiwiYnVpbGRlciIsImFwcGVuZCIsImdldEJsb2IiLCJub2Rlc3RyZWFtIiwicmVxdWlyZSIsIlJlYWRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/support.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/utf8.js":
/*!****************************************!*\
  !*** ./node_modules/jszip/lib/utf8.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"(ssr)/./node_modules/jszip/lib/nodejsUtils.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */ // Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor(var i = 0; i < 256; i++){\n    _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n// convert string to array (typed, when possible)\nvar string2buf = function(str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n    // count binary size\n    for(m_pos = 0; m_pos < str_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n    // convert\n    for(i = 0, m_pos = 0; i < buf_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */ buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */ buf[i++] = 0xC0 | c >>> 6;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else if (c < 0x10000) {\n            /* three bytes */ buf[i++] = 0xE0 | c >>> 12;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else {\n            /* four bytes */ buf[i++] = 0xf0 | c >>> 18;\n            buf[i++] = 0x80 | c >>> 12 & 0x3f;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        }\n    }\n    return buf;\n};\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n    max = max || buf.length;\n    if (max > buf.length) {\n        max = buf.length;\n    }\n    // go back from last position, until start of sequence found\n    pos = max - 1;\n    while(pos >= 0 && (buf[pos] & 0xC0) === 0x80){\n        pos--;\n    }\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) {\n        return max;\n    }\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) {\n        return max;\n    }\n    return pos + _utf8len[buf[pos]] > max ? pos : max;\n};\n// convert array to string\nvar buf2string = function(buf) {\n    var i, out, c, c_len;\n    var len = buf.length;\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len * 2);\n    for(out = 0, i = 0; i < len;){\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) {\n            utf16buf[out++] = c;\n            continue;\n        }\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) {\n            utf16buf[out++] = 0xfffd;\n            i += c_len - 1;\n            continue;\n        }\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while(c_len > 1 && i < len){\n            c = c << 6 | buf[i++] & 0x3f;\n            c_len--;\n        }\n        // terminated by end of string?\n        if (c_len > 1) {\n            utf16buf[out++] = 0xfffd;\n            continue;\n        }\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n            utf16buf[out++] = 0xdc00 | c & 0x3ff;\n        }\n    }\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if (utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n// That's all for the pako functions.\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */ exports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodejsUtils.newBufferFrom(str, \"utf-8\");\n    }\n    return string2buf(str);\n};\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */ exports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n    return buf2string(buf);\n};\n/**\n * A worker to decode utf8 encoded binary chunks into string chunks.\n * @constructor\n */ function Utf8DecodeWorker() {\n    GenericWorker.call(this, \"utf-8 decode\");\n    // the last bytes if a chunk didn't end with a complete codepoint.\n    this.leftOver = null;\n}\nutils.inherits(Utf8DecodeWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ Utf8DecodeWorker.prototype.processChunk = function(chunk) {\n    var data = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", chunk.data);\n    // 1st step, re-use what's left of the previous chunk\n    if (this.leftOver && this.leftOver.length) {\n        if (support.uint8array) {\n            var previousData = data;\n            data = new Uint8Array(previousData.length + this.leftOver.length);\n            data.set(this.leftOver, 0);\n            data.set(previousData, this.leftOver.length);\n        } else {\n            data = this.leftOver.concat(data);\n        }\n        this.leftOver = null;\n    }\n    var nextBoundary = utf8border(data);\n    var usableData = data;\n    if (nextBoundary !== data.length) {\n        if (support.uint8array) {\n            usableData = data.subarray(0, nextBoundary);\n            this.leftOver = data.subarray(nextBoundary, data.length);\n        } else {\n            usableData = data.slice(0, nextBoundary);\n            this.leftOver = data.slice(nextBoundary, data.length);\n        }\n    }\n    this.push({\n        data: exports.utf8decode(usableData),\n        meta: chunk.meta\n    });\n};\n/**\n * @see GenericWorker.flush\n */ Utf8DecodeWorker.prototype.flush = function() {\n    if (this.leftOver && this.leftOver.length) {\n        this.push({\n            data: exports.utf8decode(this.leftOver),\n            meta: {}\n        });\n        this.leftOver = null;\n    }\n};\nexports.Utf8DecodeWorker = Utf8DecodeWorker;\n/**\n * A worker to endcode string chunks into utf8 encoded binary chunks.\n * @constructor\n */ function Utf8EncodeWorker() {\n    GenericWorker.call(this, \"utf-8 encode\");\n}\nutils.inherits(Utf8EncodeWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ Utf8EncodeWorker.prototype.processChunk = function(chunk) {\n    this.push({\n        data: exports.utf8encode(chunk.data),\n        meta: chunk.meta\n    });\n};\nexports.Utf8EncodeWorker = Utf8EncodeWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3V0ZjguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQyx3REFBUztBQUM3QixJQUFJQyxVQUFVRCxtQkFBT0EsQ0FBQyw0REFBVztBQUNqQyxJQUFJRSxjQUFjRixtQkFBT0EsQ0FBQyxvRUFBZTtBQUN6QyxJQUFJRyxnQkFBZ0JILG1CQUFPQSxDQUFDLHNGQUF3QjtBQUVwRDs7O0NBR0MsR0FFRCxpRUFBaUU7QUFDakUsb0ZBQW9GO0FBQ3BGLDZDQUE2QztBQUM3QyxJQUFJSSxXQUFXLElBQUlDLE1BQU07QUFDekIsSUFBSyxJQUFJQyxJQUFFLEdBQUdBLElBQUUsS0FBS0EsSUFBSztJQUN0QkYsUUFBUSxDQUFDRSxFQUFFLEdBQUlBLEtBQUssTUFBTSxJQUFJQSxLQUFLLE1BQU0sSUFBSUEsS0FBSyxNQUFNLElBQUlBLEtBQUssTUFBTSxJQUFJQSxLQUFLLE1BQU0sSUFBSTtBQUM5RjtBQUNBRixRQUFRLENBQUMsSUFBSSxHQUFDQSxRQUFRLENBQUMsSUFBSSxHQUFDLEdBQUcseUJBQXlCO0FBRXhELGlEQUFpRDtBQUNqRCxJQUFJRyxhQUFhLFNBQVVDLEdBQUc7SUFDMUIsSUFBSUMsS0FBS0MsR0FBR0MsSUFBSUMsT0FBT04sR0FBR08sVUFBVUwsSUFBSU0sTUFBTSxFQUFFQyxVQUFVO0lBRTFELG9CQUFvQjtJQUNwQixJQUFLSCxRQUFRLEdBQUdBLFFBQVFDLFNBQVNELFFBQVM7UUFDdENGLElBQUlGLElBQUlRLFVBQVUsQ0FBQ0o7UUFDbkIsSUFBSSxDQUFDRixJQUFJLE1BQUssTUFBTyxVQUFXRSxRQUFNLElBQUlDLFNBQVU7WUFDaERGLEtBQUtILElBQUlRLFVBQVUsQ0FBQ0osUUFBTTtZQUMxQixJQUFJLENBQUNELEtBQUssTUFBSyxNQUFPLFFBQVE7Z0JBQzFCRCxJQUFJLFVBQVcsS0FBSyxVQUFXLEVBQUMsSUFBTUMsQ0FBQUEsS0FBSyxNQUFLO2dCQUNo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LElBQUksQ0FBQztRQUNOUCxNQUFPZCxRQUFRQyxVQUFVLENBQUNZLE1BQU1DLElBQUk7UUFDcENRLE1BQU9ULE1BQU1TLElBQUk7SUFDckI7QUFDSjtBQUNBdEIsd0JBQXdCLEdBQUd3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BwdHgtb3B0aW1pemVyLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi91dGY4LmpzPzEzNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi9zdXBwb3J0XCIpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNvbWUgZnJvbSBwYWtvLCBmcm9tIHBha28vbGliL3V0aWxzL3N0cmluZ3NcbiAqIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIHBha28gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL1xuICovXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpPTA7IGk8MjU2OyBpKyspIHtcbiAgICBfdXRmOGxlbltpXSA9IChpID49IDI1MiA/IDYgOiBpID49IDI0OCA/IDUgOiBpID49IDI0MCA/IDQgOiBpID49IDIyNCA/IDMgOiBpID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF09X3V0ZjhsZW5bMjU0XT0xOyAvLyBJbnZhbGlkIHNlcXVlbmNlIHN0YXJ0XG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbnZhciBzdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gICAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MrMSA8IHN0cl9sZW4pKSB7XG4gICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKzEpO1xuICAgICAgICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICAgICAgICAgIG1fcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgICB9XG5cbiAgICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGJ1Zl9sZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBBcnJheShidWZfbGVuKTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0XG4gICAgZm9yIChpPTAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICAgICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcysxIDwgc3RyX2xlbikpIHtcbiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MrMSk7XG4gICAgICAgICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgICAgICAgICAgbV9wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IGM7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWY7XG59O1xuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xudmFyIHV0Zjhib3JkZXIgPSBmdW5jdGlvbihidWYsIG1heCkge1xuICAgIHZhciBwb3M7XG5cbiAgICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgeyBtYXggPSBidWYubGVuZ3RoOyB9XG5cbiAgICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgICBwb3MgPSBtYXgtMTtcbiAgICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAgIC8vIEZ1Y2t1cCAtIHZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgdnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgICAvLyByZXR1cm4gbWF4IHRvby5cbiAgICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICAgIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG52YXIgYnVmMnN0cmluZyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICB2YXIgaSwgb3V0LCBjLCBjX2xlbjtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcblxuICAgIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICAgIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4qMik7XG5cbiAgICBmb3IgKG91dD0wLCBpPTA7IGk8bGVuOykge1xuICAgICAgICBjID0gYnVmW2krK107XG4gICAgICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAgICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuLTE7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAgICAgLy8gam9pbiB0aGUgcmVzdFxuICAgICAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgICAgICAgY19sZW4tLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICAgICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2hyaW5rQnVmKHV0ZjE2YnVmLCBvdXQpXG4gICAgaWYgKHV0ZjE2YnVmLmxlbmd0aCAhPT0gb3V0KSB7XG4gICAgICAgIGlmKHV0ZjE2YnVmLnN1YmFycmF5KSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZiA9IHV0ZjE2YnVmLnN1YmFycmF5KDAsIG91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGYxNmJ1Zi5sZW5ndGggPSBvdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGYxNmJ1Zik7XG4gICAgcmV0dXJuIHV0aWxzLmFwcGx5RnJvbUNoYXJDb2RlKHV0ZjE2YnVmKTtcbn07XG5cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgamF2YXNjcmlwdCBzdHJpbmcgaW50byBhbiBhcnJheSAodHlwZWQgaWYgcG9zc2libGUpIG9mIGJ5dGVzLFxuICogVVRGLTggZW5jb2RlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgVVRGLTggZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydHMudXRmOGVuY29kZSA9IGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyKSB7XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShzdHIsIFwidXRmLThcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZzJidWYoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBieXRlcyBhcnJheSAob3IgYSByZXByZXNlbnRhdGlvbikgcmVwcmVzZW50aW5nIGFuIFVURi04IGVuY29kZWRcbiAqIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBzdHJpbmcuXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSBidWYgdGhlIGRhdGEgZGUgZGVjb2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBkZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0cy51dGY4ZGVjb2RlID0gZnVuY3Rpb24gdXRmOGRlY29kZShidWYpIHtcbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcIm5vZGVidWZmZXJcIiwgYnVmKS50b1N0cmluZyhcInV0Zi04XCIpO1xuICAgIH1cblxuICAgIGJ1ZiA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBidWYpO1xuXG4gICAgcmV0dXJuIGJ1ZjJzdHJpbmcoYnVmKTtcbn07XG5cbi8qKlxuICogQSB3b3JrZXIgdG8gZGVjb2RlIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzIGludG8gc3RyaW5nIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVdGY4RGVjb2RlV29ya2VyKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcInV0Zi04IGRlY29kZVwiKTtcbiAgICAvLyB0aGUgbGFzdCBieXRlcyBpZiBhIGNodW5rIGRpZG4ndCBlbmQgd2l0aCBhIGNvbXBsZXRlIGNvZGVwb2ludC5cbiAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbn1cbnV0aWxzLmluaGVyaXRzKFV0ZjhEZWNvZGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuVXRmOERlY29kZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgZGF0YSA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBjaHVuay5kYXRhKTtcblxuICAgIC8vIDFzdCBzdGVwLCByZS11c2Ugd2hhdCdzIGxlZnQgb2YgdGhlIHByZXZpb3VzIGNodW5rXG4gICAgaWYgKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgaWYoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNEYXRhID0gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShwcmV2aW91c0RhdGEubGVuZ3RoICsgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpO1xuICAgICAgICAgICAgZGF0YS5zZXQodGhpcy5sZWZ0T3ZlciwgMCk7XG4gICAgICAgICAgICBkYXRhLnNldChwcmV2aW91c0RhdGEsIHRoaXMubGVmdE92ZXIubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxlZnRPdmVyLmNvbmNhdChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEJvdW5kYXJ5ID0gdXRmOGJvcmRlcihkYXRhKTtcbiAgICB2YXIgdXNhYmxlRGF0YSA9IGRhdGE7XG4gICAgaWYgKG5leHRCb3VuZGFyeSAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc3ViYXJyYXkoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnN1YmFycmF5KG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc2xpY2UoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnNsaWNlKG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGRlY29kZSh1c2FibGVEYXRhKSxcbiAgICAgICAgbWV0YSA6IGNodW5rLm1ldGFcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblV0ZjhEZWNvZGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhkZWNvZGUodGhpcy5sZWZ0T3ZlciksXG4gICAgICAgICAgICBtZXRhIDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGVmdE92ZXIgPSBudWxsO1xuICAgIH1cbn07XG5leHBvcnRzLlV0ZjhEZWNvZGVXb3JrZXIgPSBVdGY4RGVjb2RlV29ya2VyO1xuXG4vKipcbiAqIEEgd29ya2VyIHRvIGVuZGNvZGUgc3RyaW5nIGNodW5rcyBpbnRvIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFV0ZjhFbmNvZGVXb3JrZXIoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwidXRmLTggZW5jb2RlXCIpO1xufVxudXRpbHMuaW5oZXJpdHMoVXRmOEVuY29kZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5VdGY4RW5jb2RlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZW5jb2RlKGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbmV4cG9ydHMuVXRmOEVuY29kZVdvcmtlciA9IFV0ZjhFbmNvZGVXb3JrZXI7XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwic3VwcG9ydCIsIm5vZGVqc1V0aWxzIiwiR2VuZXJpY1dvcmtlciIsIl91dGY4bGVuIiwiQXJyYXkiLCJpIiwic3RyaW5nMmJ1ZiIsInN0ciIsImJ1ZiIsImMiLCJjMiIsIm1fcG9zIiwic3RyX2xlbiIsImxlbmd0aCIsImJ1Zl9sZW4iLCJjaGFyQ29kZUF0IiwidWludDhhcnJheSIsIlVpbnQ4QXJyYXkiLCJ1dGY4Ym9yZGVyIiwibWF4IiwicG9zIiwiYnVmMnN0cmluZyIsIm91dCIsImNfbGVuIiwibGVuIiwidXRmMTZidWYiLCJzdWJhcnJheSIsImFwcGx5RnJvbUNoYXJDb2RlIiwiZXhwb3J0cyIsInV0ZjhlbmNvZGUiLCJub2RlYnVmZmVyIiwibmV3QnVmZmVyRnJvbSIsInV0ZjhkZWNvZGUiLCJ0cmFuc2Zvcm1UbyIsInRvU3RyaW5nIiwiVXRmOERlY29kZVdvcmtlciIsImNhbGwiLCJsZWZ0T3ZlciIsImluaGVyaXRzIiwicHJvdG90eXBlIiwicHJvY2Vzc0NodW5rIiwiY2h1bmsiLCJkYXRhIiwicHJldmlvdXNEYXRhIiwic2V0IiwiY29uY2F0IiwibmV4dEJvdW5kYXJ5IiwidXNhYmxlRGF0YSIsInNsaWNlIiwicHVzaCIsIm1ldGEiLCJmbHVzaCIsIlV0ZjhFbmNvZGVXb3JrZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/utf8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/utils.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\nvar base64 = __webpack_require__(/*! ./base64 */ \"(ssr)/./node_modules/jszip/lib/base64.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"(ssr)/./node_modules/jszip/lib/nodejsUtils.js\");\nvar external = __webpack_require__(/*! ./external */ \"(ssr)/./node_modules/jszip/lib/external.js\");\n__webpack_require__(/*! setimmediate */ \"(ssr)/./node_modules/next/dist/compiled/setimmediate/setImmediate.js\");\n/**\n * Convert a string that pass as a \"binary string\": it should represent a byte\n * array but may have > 255 char codes. Be sure to take only the first byte\n * and returns the byte array.\n * @param {String} str the string to transform.\n * @return {Array|Uint8Array} the string in a binary format.\n */ function string2binary(str) {\n    var result = null;\n    if (support.uint8array) {\n        result = new Uint8Array(str.length);\n    } else {\n        result = new Array(str.length);\n    }\n    return stringToArrayLike(str, result);\n}\n/**\n * Create a new blob with the given content and the given type.\n * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use\n * an Uint8Array because the stock browser of android 4 won't accept it (it\n * will be silently converted to a string, \"[object Uint8Array]\").\n *\n * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:\n * when a large amount of Array is used to create the Blob, the amount of\n * memory consumed is nearly 100 times the original data amount.\n *\n * @param {String} type the mime type of the blob.\n * @return {Blob} the created blob.\n */ exports.newBlob = function(part, type) {\n    exports.checkSupport(\"blob\");\n    try {\n        // Blob constructor\n        return new Blob([\n            part\n        ], {\n            type: type\n        });\n    } catch (e) {\n        try {\n            // deprecated, browser only, old way\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(part);\n            return builder.getBlob(type);\n        } catch (e) {\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */ function identity(input) {\n    return input;\n}\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */ function stringToArrayLike(str, array) {\n    for(var i = 0; i < str.length; ++i){\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n/**\n * An helper for the function arrayLikeToString.\n * This contains static information and functions that\n * can be optimized by the browser JIT compiler.\n */ var arrayToStringHelper = {\n    /**\n     * Transform an array of int into a string, chunk by chunk.\n     * See the performances notes on arrayLikeToString.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @param {String} type the type of the array.\n     * @param {Integer} chunk the chunk size.\n     * @return {String} the resulting string.\n     * @throws Error if the chunk is too big for the stack.\n     */ stringifyByChunk: function(array, type, chunk) {\n        var result = [], k = 0, len = array.length;\n        // shortcut\n        if (len <= chunk) {\n            return String.fromCharCode.apply(null, array);\n        }\n        while(k < len){\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            } else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        return result.join(\"\");\n    },\n    /**\n     * Call String.fromCharCode on every item in the array.\n     * This is the naive implementation, which generate A LOT of intermediate string.\n     * This should be used when everything else fail.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @return {String} the result.\n     */ stringifyByChar: function(array) {\n        var resultStr = \"\";\n        for(var i = 0; i < array.length; i++){\n            resultStr += String.fromCharCode(array[i]);\n        }\n        return resultStr;\n    },\n    applyCanBeUsed: {\n        /**\n         * true if the browser accepts to use String.fromCharCode on Uint8Array\n         */ uint8array: function() {\n            try {\n                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        }(),\n        /**\n         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.\n         */ nodebuffer: function() {\n            try {\n                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        }()\n    }\n};\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */ function arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    // TODO : we now have workers that split the work. Do we still need that ?\n    var chunk = 65536, type = exports.getTypeOf(array), canUseApply = true;\n    if (type === \"uint8array\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;\n    } else if (type === \"nodebuffer\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;\n    }\n    if (canUseApply) {\n        while(chunk > 1){\n            try {\n                return arrayToStringHelper.stringifyByChunk(array, type, chunk);\n            } catch (e) {\n                chunk = Math.floor(chunk / 2);\n            }\n        }\n    }\n    // no apply or chunk error : slow and painful algorithm\n    // default browser on android 4.*\n    return arrayToStringHelper.stringifyByChar(array);\n}\nexports.applyFromCharCode = arrayLikeToString;\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */ function arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for(var i = 0; i < arrayFrom.length; i++){\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));\n    }\n};\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return new Uint8Array(input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(new Uint8Array(input));\n    }\n};\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */ exports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n/**\n * Resolve all relative path components, \".\" and \"..\", in a path. If these relative components\n * traverse above the root then the resulting path will only contain the final path component.\n *\n * All empty components, e.g. \"//\", are removed.\n * @param {string} path A path with / or \\ separators\n * @returns {string} The path with all relative path components resolved.\n */ exports.resolve = function(path) {\n    var parts = path.split(\"/\");\n    var result = [];\n    for(var index = 0; index < parts.length; index++){\n        var part = parts[index];\n        // Allow the first and last component to be empty for trailing slashes.\n        if (part === \".\" || part === \"\" && index !== 0 && index !== parts.length - 1) {\n            continue;\n        } else if (part === \"..\") {\n            result.pop();\n        } else {\n            result.push(part);\n        }\n    }\n    return result.join(\"/\");\n};\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */ exports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */ exports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this platform\");\n    }\n};\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */ exports.pretty = function(str) {\n    var res = \"\", code, i;\n    for(i = 0; i < (str || \"\").length; i++){\n        code = str.charCodeAt(i);\n        res += \"\\\\x\" + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n/**\n * Defer the call of a function.\n * @param {Function} callback the function to call asynchronously.\n * @param {Array} args the arguments to give to the callback.\n */ exports.delay = function(callback, args, self1) {\n    setImmediate(function() {\n        callback.apply(self1 || null, args || []);\n    });\n};\n/**\n * Extends a prototype with an other, without calling a constructor with\n * side effects. Inspired by nodejs' `utils.inherits`\n * @param {Function} ctor the constructor to augment\n * @param {Function} superCtor the parent constructor to use\n */ exports.inherits = function(ctor, superCtor) {\n    var Obj = function() {};\n    Obj.prototype = superCtor.prototype;\n    ctor.prototype = new Obj();\n};\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */ exports.extend = function() {\n    var result = {}, i, attr;\n    for(i = 0; i < arguments.length; i++){\n        for(attr in arguments[i]){\n            if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n/**\n * Transform arbitrary content into a Promise.\n * @param {String} name a name for the content being processed.\n * @param {Object} inputData the content to process.\n * @param {Boolean} isBinary true if the content is not an unicode string\n * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.\n * @param {Boolean} isBase64 true if the string content is encoded with base64.\n * @return {Promise} a promise in a format usable by JSZip.\n */ exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {\n    // if inputData is already a promise, this flatten it.\n    var promise = external.Promise.resolve(inputData).then(function(data) {\n        var isBlob = support.blob && (data instanceof Blob || [\n            \"[object File]\",\n            \"[object Blob]\"\n        ].indexOf(Object.prototype.toString.call(data)) !== -1);\n        if (isBlob && typeof FileReader !== \"undefined\") {\n            return new external.Promise(function(resolve, reject) {\n                var reader = new FileReader();\n                reader.onload = function(e) {\n                    resolve(e.target.result);\n                };\n                reader.onerror = function(e) {\n                    reject(e.target.error);\n                };\n                reader.readAsArrayBuffer(data);\n            });\n        } else {\n            return data;\n        }\n    });\n    return promise.then(function(data) {\n        var dataType = exports.getTypeOf(data);\n        if (!dataType) {\n            return external.Promise.reject(new Error(\"Can't read the data of '\" + name + \"'. Is it \" + \"in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\"));\n        }\n        // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === \"arraybuffer\") {\n            data = exports.transformTo(\"uint8array\", data);\n        } else if (dataType === \"string\") {\n            if (isBase64) {\n                data = base64.decode(data);\n            } else if (isBinary) {\n                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask\n                if (isOptimizedBinaryString !== true) {\n                    // this is a string, not in a base64 format.\n                    // Be sure that this is a correct \"binary string\"\n                    data = string2binary(data);\n                }\n            }\n        }\n        return data;\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsVUFBVUMsbUJBQU9BLENBQUMsNERBQVc7QUFDakMsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUMsMERBQVU7QUFDL0IsSUFBSUUsY0FBY0YsbUJBQU9BLENBQUMsb0VBQWU7QUFDekMsSUFBSUcsV0FBV0gsbUJBQU9BLENBQUMsOERBQVk7QUFDbkNBLG1CQUFPQSxDQUFDLDBGQUFjO0FBR3RCOzs7Ozs7Q0FNQyxHQUNELFNBQVNJLGNBQWNDLEdBQUc7SUFDdEIsSUFBSUMsU0FBUztJQUNiLElBQUlQLFFBQVFRLFVBQVUsRUFBRTtRQUNwQkQsU0FBUyxJQUFJRSxXQUFXSCxJQUFJSSxNQUFNO0lBQ3RDLE9BQU87UUFDSEgsU0FBUyxJQUFJSSxNQUFNTCxJQUFJSSxNQUFNO0lBQ2pDO0lBQ0EsT0FBT0Usa0JBQWtCTixLQUFLQztBQUNsQztBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNETSxlQUFlLEdBQUcsU0FBU0UsSUFBSSxFQUFFQyxJQUFJO0lBQ2pDSCxRQUFRSSxZQUFZLENBQUM7SUFFckIsSUFBSTtRQUNBLG1CQUFtQjtRQUNuQixPQUFPLElBQUlDLEtBQUs7WUFBQ0g7U0FBSyxFQUFFO1lBQ3BCQyxNQUFNQTtRQUNWO0lBQ0osRUFDQSxPQUFPRyxHQUFHO1FBRU4sSUFBSTtZQUNBLG9DQUFvQztZQUNwQyxJQUFJQyxVQUFVQyxLQUFLQyxXQUFXLElBQUlELEtBQUtFLGlCQUFpQixJQUFJRixLQUFLRyxjQUFjLElBQUlILEtBQUtJLGFBQWE7WUFDckcsSUFBSUMsVUFBVSxJQUFJTjtZQUNsQk0sUUFBUUMsTUFBTSxDQUFDWjtZQUNmLE9BQU9XLFFBQVFFLE9BQU8sQ0FBQ1o7UUFDM0IsRUFDQSxPQUFPRyxHQUFHO1lBRU4sZ0JBQWdCO1lBQ2hCLE1BQU0sSUFBSVUsTUFBTTtRQUNwQjtJQUNKO0FBR0o7QUFDQTs7OztDQUlDLEdBQ0QsU0FB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RyxlQUFlLGFBQWE7WUFDN0MsT0FBTyxJQUFJL0csU0FBU3lHLE9BQU8sQ0FBQyxTQUFVeEMsT0FBTyxFQUFFK0MsTUFBTTtnQkFDakQsSUFBSUMsU0FBUyxJQUFJRjtnQkFFakJFLE9BQU9DLE1BQU0sR0FBRyxTQUFTbkcsQ0FBQztvQkFDdEJrRCxRQUFRbEQsRUFBRW9HLE1BQU0sQ0FBQ2hILE1BQU07Z0JBQzNCO2dCQUNBOEcsT0FBT0csT0FBTyxHQUFHLFNBQVNyRyxDQUFDO29CQUN2QmlHLE9BQU9qRyxFQUFFb0csTUFBTSxDQUFDRSxLQUFLO2dCQUN6QjtnQkFDQUosT0FBT0ssaUJBQWlCLENBQUNYO1lBQzdCO1FBQ0osT0FBTztZQUNILE9BQU9BO1FBQ1g7SUFDSjtJQUVBLE9BQU9ILFFBQVFFLElBQUksQ0FBQyxTQUFTQyxJQUFJO1FBQzdCLElBQUlZLFdBQVc5RyxRQUFRMEMsU0FBUyxDQUFDd0Q7UUFFakMsSUFBSSxDQUFDWSxVQUFVO1lBQ1gsT0FBT3ZILFNBQVN5RyxPQUFPLENBQUNPLE1BQU0sQ0FDMUIsSUFBSXZGLE1BQU0sNkJBQTZCMEUsT0FBTyxjQUNwQztRQUVsQjtRQUNBLCtFQUErRTtRQUMvRSxJQUFJb0IsYUFBYSxlQUFlO1lBQzVCWixPQUFPbEcsUUFBUXFELFdBQVcsQ0FBQyxjQUFjNkM7UUFDN0MsT0FBTyxJQUFJWSxhQUFhLFVBQVU7WUFDOUIsSUFBSWhCLFVBQVU7Z0JBQ1ZJLE9BQU83RyxPQUFPMEgsTUFBTSxDQUFDYjtZQUN6QixPQUNLLElBQUlOLFVBQVU7Z0JBQ2YsZ0dBQWdHO2dCQUNoRyxJQUFJQyw0QkFBNEIsTUFBTTtvQkFDbEMsNENBQTRDO29CQUM1QyxpREFBaUQ7b0JBQ2pESyxPQUFPMUcsY0FBYzBHO2dCQUN6QjtZQUNKO1FBQ0o7UUFDQSxPQUFPQTtJQUNYO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcHR4LW9wdGltaXplci8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvdXRpbHMuanM/M2Q5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi9zdXBwb3J0XCIpO1xudmFyIGJhc2U2NCA9IHJlcXVpcmUoXCIuL2Jhc2U2NFwiKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoXCIuL25vZGVqc1V0aWxzXCIpO1xudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuXG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyB0aGF0IHBhc3MgYXMgYSBcImJpbmFyeSBzdHJpbmdcIjogaXQgc2hvdWxkIHJlcHJlc2VudCBhIGJ5dGVcbiAqIGFycmF5IGJ1dCBtYXkgaGF2ZSA+IDI1NSBjaGFyIGNvZGVzLiBCZSBzdXJlIHRvIHRha2Ugb25seSB0aGUgZmlyc3QgYnl0ZVxuICogYW5kIHJldHVybnMgdGhlIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7QXJyYXl8VWludDhBcnJheX0gdGhlIHN0cmluZyBpbiBhIGJpbmFyeSBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZzJiaW5hcnkoc3RyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShzdHIsIHJlc3VsdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGJsb2Igd2l0aCB0aGUgZ2l2ZW4gY29udGVudCBhbmQgdGhlIGdpdmVuIHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcn0gcGFydCB0aGUgY29udGVudCB0byBwdXQgaW4gdGhlIGJsb2IuIERPIE5PVCB1c2VcbiAqIGFuIFVpbnQ4QXJyYXkgYmVjYXVzZSB0aGUgc3RvY2sgYnJvd3NlciBvZiBhbmRyb2lkIDQgd29uJ3QgYWNjZXB0IGl0IChpdFxuICogd2lsbCBiZSBzaWxlbnRseSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcsIFwiW29iamVjdCBVaW50OEFycmF5XVwiKS5cbiAqXG4gKiBVc2Ugb25seSBPTkUgcGFydCB0byBidWlsZCB0aGUgYmxvYiB0byBhdm9pZCBhIG1lbW9yeSBsZWFrIGluIElFMTEgLyBFZGdlOlxuICogd2hlbiBhIGxhcmdlIGFtb3VudCBvZiBBcnJheSBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgQmxvYiwgdGhlIGFtb3VudCBvZlxuICogbWVtb3J5IGNvbnN1bWVkIGlzIG5lYXJseSAxMDAgdGltZXMgdGhlIG9yaWdpbmFsIGRhdGEgYW1vdW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGJsb2IuXG4gKiBAcmV0dXJuIHtCbG9ifSB0aGUgY3JlYXRlZCBibG9iLlxuICovXG5leHBvcnRzLm5ld0Jsb2IgPSBmdW5jdGlvbihwYXJ0LCB0eXBlKSB7XG4gICAgZXhwb3J0cy5jaGVja1N1cHBvcnQoXCJibG9iXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQmxvYiBjb25zdHJ1Y3RvclxuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW3BhcnRdLCB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkLCBicm93c2VyIG9ubHksIG9sZCB3YXlcbiAgICAgICAgICAgIHZhciBCdWlsZGVyID0gc2VsZi5CbG9iQnVpbGRlciB8fCBzZWxmLldlYktpdEJsb2JCdWlsZGVyIHx8IHNlbGYuTW96QmxvYkJ1aWxkZXIgfHwgc2VsZi5NU0Jsb2JCdWlsZGVyO1xuICAgICAgICAgICAgdmFyIGJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICAgICAgICAgICAgYnVpbGRlci5hcHBlbmQocGFydCk7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlci5nZXRCbG9iKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgIC8vIHdlbGwsIGZ1Y2sgPyFcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IGNhbid0IGNvbnN0cnVjdCB0aGUgQmxvYi5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cblxufTtcbi8qKlxuICogVGhlIGlkZW50aXR5IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IHRoZSBpbnB1dC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHNhbWUgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0O1xufVxuXG4vKipcbiAqIEZpbGwgaW4gYW4gYXJyYXkgd2l0aCBhIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB1c2UuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gZmlsbCBpbiAod2lsbCBiZSBtdXRhdGVkKS5cbiAqIEByZXR1cm4ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgdXBkYXRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheUxpa2Uoc3RyLCBhcnJheSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGFycmF5W2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQW4gaGVscGVyIGZvciB0aGUgZnVuY3Rpb24gYXJyYXlMaWtlVG9TdHJpbmcuXG4gKiBUaGlzIGNvbnRhaW5zIHN0YXRpYyBpbmZvcm1hdGlvbiBhbmQgZnVuY3Rpb25zIHRoYXRcbiAqIGNhbiBiZSBvcHRpbWl6ZWQgYnkgdGhlIGJyb3dzZXIgSklUIGNvbXBpbGVyLlxuICovXG52YXIgYXJyYXlUb1N0cmluZ0hlbHBlciA9IHtcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgaW50IGludG8gYSBzdHJpbmcsIGNodW5rIGJ5IGNodW5rLlxuICAgICAqIFNlZSB0aGUgcGVyZm9ybWFuY2VzIG5vdGVzIG9uIGFycmF5TGlrZVRvU3RyaW5nLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIGFycmF5LlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gY2h1bmsgdGhlIGNodW5rIHNpemUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0aW5nIHN0cmluZy5cbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBjaHVuayBpcyB0b28gYmlnIGZvciB0aGUgc3RhY2suXG4gICAgICovXG4gICAgc3RyaW5naWZ5QnlDaHVuazogZnVuY3Rpb24oYXJyYXksIHR5cGUsIGNodW5rKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSwgayA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgLy8gc2hvcnRjdXRcbiAgICAgICAgaWYgKGxlbiA8PSBjaHVuaykge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhcnJheVwiIHx8IHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheS5zbGljZShrLCBNYXRoLm1pbihrICsgY2h1bmssIGxlbikpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5LnN1YmFycmF5KGssIE1hdGgubWluKGsgKyBjaHVuaywgbGVuKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsgKz0gY2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2FsbCBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIGV2ZXJ5IGl0ZW0gaW4gdGhlIGFycmF5LlxuICAgICAqIFRoaXMgaXMgdGhlIG5haXZlIGltcGxlbWVudGF0aW9uLCB3aGljaCBnZW5lcmF0ZSBBIExPVCBvZiBpbnRlcm1lZGlhdGUgc3RyaW5nLlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgd2hlbiBldmVyeXRoaW5nIGVsc2UgZmFpbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBzdHJpbmdpZnlCeUNoYXI6IGZ1bmN0aW9uKGFycmF5KXtcbiAgICAgICAgdmFyIHJlc3VsdFN0ciA9IFwiXCI7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRTdHI7XG4gICAgfSxcbiAgICBhcHBseUNhbkJlVXNlZCA6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgaWYgdGhlIGJyb3dzZXIgYWNjZXB0cyB0byB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZSBvbiBVaW50OEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB1aW50OGFycmF5IDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnQudWludDhhcnJheSAmJiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKS5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBpZiB0aGUgYnJvd3NlciBhY2NlcHRzIHRvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIG5vZGVqcyBCdWZmZXIuXG4gICAgICAgICAqL1xuICAgICAgICBub2RlYnVmZmVyIDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnQubm9kZWJ1ZmZlciAmJiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5vZGVqc1V0aWxzLmFsbG9jQnVmZmVyKDEpKS5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpXG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXktbGlrZSBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZyhhcnJheSkge1xuICAgIC8vIFBlcmZvcm1hbmNlcyBub3RlcyA6XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5KSBpcyB0aGUgZmFzdGVzdCwgc2VlXG4gICAgLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbnZlcnRpbmctYS11aW50OGFycmF5LXRvLWEtc3RyaW5nLzJcbiAgICAvLyBidXQgdGhlIHN0YWNrIGlzIGxpbWl0ZWQgKGFuZCB3ZSBjYW4gZ2V0IGh1Z2UgYXJyYXlzICEpLlxuICAgIC8vXG4gICAgLy8gcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pOyBnZW5lcmF0ZSB0b28gbWFueSBzdHJpbmdzICFcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBpcyBpbnNwaXJlZCBieSBodHRwOi8vanNwZXJmLmNvbS9hcnJheWJ1ZmZlci10by1zdHJpbmctYXBwbHktcGVyZm9ybWFuY2UvMlxuICAgIC8vIFRPRE8gOiB3ZSBub3cgaGF2ZSB3b3JrZXJzIHRoYXQgc3BsaXQgdGhlIHdvcmsuIERvIHdlIHN0aWxsIG5lZWQgdGhhdCA/XG4gICAgdmFyIGNodW5rID0gNjU1MzYsXG4gICAgICAgIHR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihhcnJheSksXG4gICAgICAgIGNhblVzZUFwcGx5ID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gXCJ1aW50OGFycmF5XCIpIHtcbiAgICAgICAgY2FuVXNlQXBwbHkgPSBhcnJheVRvU3RyaW5nSGVscGVyLmFwcGx5Q2FuQmVVc2VkLnVpbnQ4YXJyYXk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICBjYW5Vc2VBcHBseSA9IGFycmF5VG9TdHJpbmdIZWxwZXIuYXBwbHlDYW5CZVVzZWQubm9kZWJ1ZmZlcjtcbiAgICB9XG5cbiAgICBpZiAoY2FuVXNlQXBwbHkpIHtcbiAgICAgICAgd2hpbGUgKGNodW5rID4gMSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlUb1N0cmluZ0hlbHBlci5zdHJpbmdpZnlCeUNodW5rKGFycmF5LCB0eXBlLCBjaHVuayk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBNYXRoLmZsb29yKGNodW5rIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBubyBhcHBseSBvciBjaHVuayBlcnJvciA6IHNsb3cgYW5kIHBhaW5mdWwgYWxnb3JpdGhtXG4gICAgLy8gZGVmYXVsdCBicm93c2VyIG9uIGFuZHJvaWQgNC4qXG4gICAgcmV0dXJuIGFycmF5VG9TdHJpbmdIZWxwZXIuc3RyaW5naWZ5QnlDaGFyKGFycmF5KTtcbn1cblxuZXhwb3J0cy5hcHBseUZyb21DaGFyQ29kZSA9IGFycmF5TGlrZVRvU3RyaW5nO1xuXG5cbi8qKlxuICogQ29weSB0aGUgZGF0YSBmcm9tIGFuIGFycmF5LWxpa2UgdG8gYW4gb3RoZXIgYXJyYXktbGlrZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5RnJvbSB0aGUgb3JpZ2luIGFycmF5LlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXlUbyB0aGUgZGVzdGluYXRpb24gYXJyYXkgd2hpY2ggd2lsbCBiZSBtdXRhdGVkLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGRlc3RpbmF0aW9uIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VUb0FycmF5TGlrZShhcnJheUZyb20sIGFycmF5VG8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5RnJvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVRvW2ldID0gYXJyYXlGcm9tW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlUbztcbn1cblxuLy8gYSBtYXRyaXggY29udGFpbmluZyBmdW5jdGlvbnMgdG8gdHJhbnNmb3JtIGV2ZXJ5dGhpbmcgaW50byBldmVyeXRoaW5nLlxudmFyIHRyYW5zZm9ybSA9IHt9O1xuXG4vLyBzdHJpbmcgdG8gP1xudHJhbnNmb3JtW1wic3RyaW5nXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGlkZW50aXR5LFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1bXCJzdHJpbmdcIl1bXCJ1aW50OGFycmF5XCJdKGlucHV0KS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKGlucHV0LCBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5vZGVqc1V0aWxzLmFsbG9jQnVmZmVyKGlucHV0Lmxlbmd0aCkpO1xuICAgIH1cbn07XG5cbi8vIGFycmF5IHRvID9cbnRyYW5zZm9ybVtcImFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKG5ldyBVaW50OEFycmF5KGlucHV0KSkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20oaW5wdXQpO1xuICAgIH1cbn07XG5cbi8vIGFycmF5YnVmZmVyIHRvID9cbnRyYW5zZm9ybVtcImFycmF5YnVmZmVyXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb1N0cmluZyhuZXcgVWludDhBcnJheShpbnB1dCkpO1xuICAgIH0sXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UobmV3IFVpbnQ4QXJyYXkoaW5wdXQpLCBuZXcgQXJyYXkoaW5wdXQuYnl0ZUxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBpZGVudGl0eSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShuZXcgVWludDhBcnJheShpbnB1dCkpO1xuICAgIH1cbn07XG5cbi8vIHVpbnQ4YXJyYXkgdG8gP1xudHJhbnNmb3JtW1widWludDhhcnJheVwiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBhcnJheUxpa2VUb1N0cmluZyxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGlkZW50aXR5LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gbm9kZWJ1ZmZlciB0byA/XG50cmFuc2Zvcm1bXCJub2RlYnVmZmVyXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1bXCJub2RlYnVmZmVyXCJdW1widWludDhhcnJheVwiXShpbnB1dCkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogaWRlbnRpdHlcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGlucHV0IGludG8gYW55IHR5cGUuXG4gKiBUaGUgc3VwcG9ydGVkIG91dHB1dCB0eXBlIGFyZSA6IHN0cmluZywgYXJyYXksIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBub2RlYnVmZmVyLlxuICogSWYgbm8gb3V0cHV0IHR5cGUgaXMgc3BlY2lmaWVkLCB0aGUgdW5tb2RpZmllZCBpbnB1dCB3aWxsIGJlIHJldHVybmVkLlxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIG91dHB1dCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGlucHV0IHRoZSBpbnB1dCB0byBjb252ZXJ0LlxuICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgcmVxdWVzdGVkIG91dHB1dCB0eXBlLlxuICovXG5leHBvcnRzLnRyYW5zZm9ybVRvID0gZnVuY3Rpb24ob3V0cHV0VHlwZSwgaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCwgbnVsbCwgZXRjXG4gICAgICAgIC8vIGFuIGVtcHR5IHN0cmluZyB3b24ndCBoYXJtLlxuICAgICAgICBpbnB1dCA9IFwiXCI7XG4gICAgfVxuICAgIGlmICghb3V0cHV0VHlwZSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGV4cG9ydHMuY2hlY2tTdXBwb3J0KG91dHB1dFR5cGUpO1xuICAgIHZhciBpbnB1dFR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihpbnB1dCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybVtpbnB1dFR5cGVdW291dHB1dFR5cGVdKGlucHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXNvbHZlIGFsbCByZWxhdGl2ZSBwYXRoIGNvbXBvbmVudHMsIFwiLlwiIGFuZCBcIi4uXCIsIGluIGEgcGF0aC4gSWYgdGhlc2UgcmVsYXRpdmUgY29tcG9uZW50c1xuICogdHJhdmVyc2UgYWJvdmUgdGhlIHJvb3QgdGhlbiB0aGUgcmVzdWx0aW5nIHBhdGggd2lsbCBvbmx5IGNvbnRhaW4gdGhlIGZpbmFsIHBhdGggY29tcG9uZW50LlxuICpcbiAqIEFsbCBlbXB0eSBjb21wb25lbnRzLCBlLmcuIFwiLy9cIiwgYXJlIHJlbW92ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBBIHBhdGggd2l0aCAvIG9yIFxcIHNlcGFyYXRvcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwYXRoIHdpdGggYWxsIHJlbGF0aXZlIHBhdGggY29tcG9uZW50cyByZXNvbHZlZC5cbiAqL1xuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgcGFydHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaW5kZXhdO1xuICAgICAgICAvLyBBbGxvdyB0aGUgZmlyc3QgYW5kIGxhc3QgY29tcG9uZW50IHRvIGJlIGVtcHR5IGZvciB0cmFpbGluZyBzbGFzaGVzLlxuICAgICAgICBpZiAocGFydCA9PT0gXCIuXCIgfHwgKHBhcnQgPT09IFwiXCIgJiYgaW5kZXggIT09IDAgJiYgaW5kZXggIT09IHBhcnRzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbihcIi9cIik7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKiBUaGUgdHlwZSB3aWxsIGJlIGluIGEgZm9ybWF0IHZhbGlkIGZvciBKU1ppcC51dGlscy50cmFuc2Zvcm1UbyA6IHN0cmluZywgYXJyYXksIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IHRoZSBpbnB1dCB0byBpZGVudGlmeS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIChsb3dlcmNhc2UpIHR5cGUgb2YgdGhlIGlucHV0LlxuICovXG5leHBvcnRzLmdldFR5cGVPZiA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyICYmIG5vZGVqc1V0aWxzLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gXCJub2RlYnVmZmVyXCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkgJiYgaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBcInVpbnQ4YXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQuYXJyYXlidWZmZXIgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gXCJhcnJheWJ1ZmZlclwiO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSB0byBjaGVjay5cbiAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCB0eXBlLlxuICovXG5leHBvcnRzLmNoZWNrU3VwcG9ydCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB2YXIgc3VwcG9ydGVkID0gc3VwcG9ydFt0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmICghc3VwcG9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHBsYXRmb3JtXCIpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuTUFYX1ZBTFVFXzE2QklUUyA9IDY1NTM1O1xuZXhwb3J0cy5NQVhfVkFMVUVfMzJCSVRTID0gLTE7IC8vIHdlbGwsIFwiXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlwiIGlzIHBhcnNlZCBhcyAtMVxuXG4vKipcbiAqIFByZXR0aWZ5IGEgc3RyaW5nIHJlYWQgYXMgYmluYXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHByZXR0aWZ5LlxuICogQHJldHVybiB7c3RyaW5nfSBhIHByZXR0eSBzdHJpbmcuXG4gKi9cbmV4cG9ydHMucHJldHR5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIHJlcyA9IFwiXCIsXG4gICAgICAgIGNvZGUsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IChzdHIgfHwgXCJcIikubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICByZXMgKz0gXCJcXFxceFwiICsgKGNvZGUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyBjb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBEZWZlciB0aGUgY2FsbCBvZiBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgYXN5bmNocm9ub3VzbHkuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIHRoZSBhcmd1bWVudHMgdG8gZ2l2ZSB0byB0aGUgY2FsbGJhY2suXG4gKi9cbmV4cG9ydHMuZGVsYXkgPSBmdW5jdGlvbihjYWxsYmFjaywgYXJncywgc2VsZikge1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHNlbGYgfHwgbnVsbCwgYXJncyB8fCBbXSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEV4dGVuZHMgYSBwcm90b3R5cGUgd2l0aCBhbiBvdGhlciwgd2l0aG91dCBjYWxsaW5nIGEgY29uc3RydWN0b3Igd2l0aFxuICogc2lkZSBlZmZlY3RzLiBJbnNwaXJlZCBieSBub2RlanMnIGB1dGlscy5pbmhlcml0c2BcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN0b3IgdGhlIGNvbnN0cnVjdG9yIHRvIGF1Z21lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyQ3RvciB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIHRvIHVzZVxuICovXG5leHBvcnRzLmluaGVyaXRzID0gZnVuY3Rpb24gKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIHZhciBPYmogPSBmdW5jdGlvbigpIHt9O1xuICAgIE9iai5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IE9iaigpO1xufTtcblxuLyoqXG4gKiBNZXJnZSB0aGUgb2JqZWN0cyBwYXNzZWQgYXMgcGFyYW1ldGVycyBpbnRvIGEgbmV3IG9uZS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX2FyZ3MgQWxsIG9iamVjdHMgdG8gbWVyZ2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdCB3aXRoIHRoZSBkYXRhIG9mIHRoZSBvdGhlcnMuXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBpLCBhdHRyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgLy8gYXJndW1lbnRzIGlzIG5vdCBlbnVtZXJhYmxlIGluIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgZm9yIChhdHRyIGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbaV0sIGF0dHIpICYmIHR5cGVvZiByZXN1bHRbYXR0cl0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbYXR0cl0gPSBhcmd1bWVudHNbaV1bYXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFyYml0cmFyeSBjb250ZW50IGludG8gYSBQcm9taXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgYSBuYW1lIGZvciB0aGUgY29udGVudCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhIHRoZSBjb250ZW50IHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IHRydWUgaWYgdGhlIGNvbnRlbnQgaXMgbm90IGFuIHVuaWNvZGUgc3RyaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nIHRydWUgaWYgdGhlIHN0cmluZyBjb250ZW50IG9ubHkgaGFzIG9uZSBieXRlIHBlciBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmFzZTY0IHRydWUgaWYgdGhlIHN0cmluZyBjb250ZW50IGlzIGVuY29kZWQgd2l0aCBiYXNlNjQuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgaW4gYSBmb3JtYXQgdXNhYmxlIGJ5IEpTWmlwLlxuICovXG5leHBvcnRzLnByZXBhcmVDb250ZW50ID0gZnVuY3Rpb24obmFtZSwgaW5wdXREYXRhLCBpc0JpbmFyeSwgaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIGlzQmFzZTY0KSB7XG5cbiAgICAvLyBpZiBpbnB1dERhdGEgaXMgYWxyZWFkeSBhIHByb21pc2UsIHRoaXMgZmxhdHRlbiBpdC5cbiAgICB2YXIgcHJvbWlzZSA9IGV4dGVybmFsLlByb21pc2UucmVzb2x2ZShpbnB1dERhdGEpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuXG5cbiAgICAgICAgdmFyIGlzQmxvYiA9IHN1cHBvcnQuYmxvYiAmJiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IgfHwgW1wiW29iamVjdCBGaWxlXVwiLCBcIltvYmplY3QgQmxvYl1cIl0uaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpICE9PSAtMSk7XG5cbiAgICAgICAgaWYgKGlzQmxvYiAmJiB0eXBlb2YgRmlsZVJlYWRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZS50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBkYXRhVHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGRhdGEpO1xuXG4gICAgICAgIGlmICghZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXCJDYW4ndCByZWFkIHRoZSBkYXRhIG9mICdcIiArIG5hbWUgKyBcIicuIElzIGl0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbiBhIHN1cHBvcnRlZCBKYXZhU2NyaXB0IHR5cGUgKFN0cmluZywgQmxvYiwgQXJyYXlCdWZmZXIsIGV0YykgP1wiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgOiBpdCdzIHdheSBlYXNpZXIgdG8gd29yayB3aXRoIFVpbnQ4QXJyYXkgdGhhbiB3aXRoIEFycmF5QnVmZmVyXG4gICAgICAgIGlmIChkYXRhVHlwZSA9PT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICBkYXRhID0gZXhwb3J0cy50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIiwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0Jhc2U2NCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBiYXNlNjQuZGVjb2RlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNCaW5hcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWRCaW5hcnlTdHJpbmcgPT09IHRydWUgbWVhbnMgdGhhdCB0aGUgZmlsZSBoYXMgYWxyZWFkeSBiZWVuIGZpbHRlcmVkIHdpdGggYSAweEZGIG1hc2tcbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHN0cmluZywgbm90IGluIGEgYmFzZTY0IGZvcm1hdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmUgc3VyZSB0aGF0IHRoaXMgaXMgYSBjb3JyZWN0IFwiYmluYXJ5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzdHJpbmcyYmluYXJ5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbn07XG4iXSwibmFtZXMiOlsic3VwcG9ydCIsInJlcXVpcmUiLCJiYXNlNjQiLCJub2RlanNVdGlscyIsImV4dGVybmFsIiwic3RyaW5nMmJpbmFyeSIsInN0ciIsInJlc3VsdCIsInVpbnQ4YXJyYXkiLCJVaW50OEFycmF5IiwibGVuZ3RoIiwiQXJyYXkiLCJzdHJpbmdUb0FycmF5TGlrZSIsImV4cG9ydHMiLCJuZXdCbG9iIiwicGFydCIsInR5cGUiLCJjaGVja1N1cHBvcnQiLCJCbG9iIiwiZSIsIkJ1aWxkZXIiLCJzZWxmIiwiQmxvYkJ1aWxkZXIiLCJXZWJLaXRCbG9iQnVpbGRlciIsIk1vekJsb2JCdWlsZGVyIiwiTVNCbG9iQnVpbGRlciIsImJ1aWxkZXIiLCJhcHBlbmQiLCJnZXRCbG9iIiwiRXJyb3IiLCJpZGVudGl0eSIsImlucHV0IiwiYXJyYXkiLCJpIiwiY2hhckNvZGVBdCIsImFycmF5VG9TdHJpbmdIZWxwZXIiLCJzdHJpbmdpZnlCeUNodW5rIiwiY2h1bmsiLCJrIiwibGVuIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJwdXNoIiwic2xpY2UiLCJNYXRoIiwibWluIiwic3ViYXJyYXkiLCJqb2luIiwic3RyaW5naWZ5QnlDaGFyIiwicmVzdWx0U3RyIiwiYXBwbHlDYW5CZVVzZWQiLCJub2RlYnVmZmVyIiwiYWxsb2NCdWZmZXIiLCJhcnJheUxpa2VUb1N0cmluZyIsImdldFR5cGVPZiIsImNhblVzZUFwcGx5IiwiZmxvb3IiLCJhcHBseUZyb21DaGFyQ29kZSIsImFycmF5TGlrZVRvQXJyYXlMaWtlIiwiYXJyYXlGcm9tIiwiYXJyYXlUbyIsInRyYW5zZm9ybSIsImJ1ZmZlciIsIm5ld0J1ZmZlckZyb20iLCJieXRlTGVuZ3RoIiwidHJhbnNmb3JtVG8iLCJvdXRwdXRUeXBlIiwiaW5wdXRUeXBlIiwicmVzb2x2ZSIsInBhdGgiLCJwYXJ0cyIsInNwbGl0IiwiaW5kZXgiLCJwb3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc0J1ZmZlciIsImFycmF5YnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJzdXBwb3J0ZWQiLCJ0b0xvd2VyQ2FzZSIsIk1BWF9WQUxVRV8xNkJJVFMiLCJNQVhfVkFMVUVfMzJCSVRTIiwicHJldHR5IiwicmVzIiwiY29kZSIsInRvVXBwZXJDYXNlIiwiZGVsYXkiLCJjYWxsYmFjayIsImFyZ3MiLCJzZXRJbW1lZGlhdGUiLCJpbmhlcml0cyIsImN0b3IiLCJzdXBlckN0b3IiLCJPYmoiLCJleHRlbmQiLCJhdHRyIiwiYXJndW1lbnRzIiwiaGFzT3duUHJvcGVydHkiLCJwcmVwYXJlQ29udGVudCIsIm5hbWUiLCJpbnB1dERhdGEiLCJpc0JpbmFyeSIsImlzT3B0aW1pemVkQmluYXJ5U3RyaW5nIiwiaXNCYXNlNjQiLCJwcm9taXNlIiwiUHJvbWlzZSIsInRoZW4iLCJkYXRhIiwiaXNCbG9iIiwiYmxvYiIsImluZGV4T2YiLCJGaWxlUmVhZGVyIiwicmVqZWN0IiwicmVhZGVyIiwib25sb2FkIiwidGFyZ2V0Iiwib25lcnJvciIsImVycm9yIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJkYXRhVHlwZSIsImRlY29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/zipEntries.js":
/*!**********************************************!*\
  !*** ./node_modules/jszip/lib/zipEntries.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar readerFor = __webpack_require__(/*! ./reader/readerFor */ \"(ssr)/./node_modules/jszip/lib/reader/readerFor.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar sig = __webpack_require__(/*! ./signature */ \"(ssr)/./node_modules/jszip/lib/signature.js\");\nvar ZipEntry = __webpack_require__(/*! ./zipEntry */ \"(ssr)/./node_modules/jszip/lib/zipEntry.js\");\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\n//  class ZipEntries {{{\n/**\n * All the entries in the zip file.\n * @constructor\n * @param {Object} loadOptions Options for loading the stream.\n */ function ZipEntries(loadOptions) {\n    this.files = [];\n    this.loadOptions = loadOptions;\n}\nZipEntries.prototype = {\n    /**\n     * Check that the reader is on the specified signature.\n     * @param {string} expectedSignature the expected signature.\n     * @throws {Error} if it is an other signature.\n     */ checkSignature: function(expectedSignature) {\n        if (!this.reader.readAndCheckSignature(expectedSignature)) {\n            this.reader.index -= 4;\n            var signature = this.reader.readString(4);\n            throw new Error(\"Corrupted zip or bug: unexpected signature \" + \"(\" + utils.pretty(signature) + \", expected \" + utils.pretty(expectedSignature) + \")\");\n        }\n    },\n    /**\n     * Check if the given signature is at the given index.\n     * @param {number} askedIndex the index to check.\n     * @param {string} expectedSignature the signature to expect.\n     * @return {boolean} true if the signature is here, false otherwise.\n     */ isSignature: function(askedIndex, expectedSignature) {\n        var currentIndex = this.reader.index;\n        this.reader.setIndex(askedIndex);\n        var signature = this.reader.readString(4);\n        var result = signature === expectedSignature;\n        this.reader.setIndex(currentIndex);\n        return result;\n    },\n    /**\n     * Read the end of the central directory.\n     */ readBlockEndOfCentral: function() {\n        this.diskNumber = this.reader.readInt(2);\n        this.diskWithCentralDirStart = this.reader.readInt(2);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n        this.centralDirRecords = this.reader.readInt(2);\n        this.centralDirSize = this.reader.readInt(4);\n        this.centralDirOffset = this.reader.readInt(4);\n        this.zipCommentLength = this.reader.readInt(2);\n        // warning : the encoding depends of the system locale\n        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.\n        // On a windows machine, this field is encoded with the localized windows code page.\n        var zipComment = this.reader.readData(this.zipCommentLength);\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        // To get consistent behavior with the generation part, we will assume that\n        // this is utf8 encoded unless specified otherwise.\n        var decodeContent = utils.transformTo(decodeParamType, zipComment);\n        this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n    },\n    /**\n     * Read the end of the Zip 64 central directory.\n     * Not merged with the method readEndOfCentral :\n     * The end of central can coexist with its Zip64 brother,\n     * I don't want to read the wrong number of bytes !\n     */ readBlockZip64EndOfCentral: function() {\n        this.zip64EndOfCentralSize = this.reader.readInt(8);\n        this.reader.skip(4);\n        // this.versionMadeBy = this.reader.readString(2);\n        // this.versionNeeded = this.reader.readInt(2);\n        this.diskNumber = this.reader.readInt(4);\n        this.diskWithCentralDirStart = this.reader.readInt(4);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n        this.centralDirRecords = this.reader.readInt(8);\n        this.centralDirSize = this.reader.readInt(8);\n        this.centralDirOffset = this.reader.readInt(8);\n        this.zip64ExtensibleData = {};\n        var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;\n        while(index < extraDataSize){\n            extraFieldId = this.reader.readInt(2);\n            extraFieldLength = this.reader.readInt(4);\n            extraFieldValue = this.reader.readData(extraFieldLength);\n            this.zip64ExtensibleData[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Read the end of the Zip 64 central directory locator.\n     */ readBlockZip64EndOfCentralLocator: function() {\n        this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n        this.disksCount = this.reader.readInt(4);\n        if (this.disksCount > 1) {\n            throw new Error(\"Multi-volumes zip are not supported\");\n        }\n    },\n    /**\n     * Read the local files, based on the offset read in the central part.\n     */ readLocalFiles: function() {\n        var i, file;\n        for(i = 0; i < this.files.length; i++){\n            file = this.files[i];\n            this.reader.setIndex(file.localHeaderOffset);\n            this.checkSignature(sig.LOCAL_FILE_HEADER);\n            file.readLocalPart(this.reader);\n            file.handleUTF8();\n            file.processAttributes();\n        }\n    },\n    /**\n     * Read the central directory.\n     */ readCentralDir: function() {\n        var file;\n        this.reader.setIndex(this.centralDirOffset);\n        while(this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)){\n            file = new ZipEntry({\n                zip64: this.zip64\n            }, this.loadOptions);\n            file.readCentralPart(this.reader);\n            this.files.push(file);\n        }\n        if (this.centralDirRecords !== this.files.length) {\n            if (this.centralDirRecords !== 0 && this.files.length === 0) {\n                // We expected some records but couldn't find ANY.\n                // This is really suspicious, as if something went wrong.\n                throw new Error(\"Corrupted zip or bug: expected \" + this.centralDirRecords + \" records in central dir, got \" + this.files.length);\n            } else {\n            // We found some records but not all.\n            // Something is wrong but we got something for the user: no error here.\n            // console.warn(\"expected\", this.centralDirRecords, \"records in central dir, got\", this.files.length);\n            }\n        }\n    },\n    /**\n     * Read the end of central directory.\n     */ readEndOfCentral: function() {\n        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n        if (offset < 0) {\n            // Check if the content is a truncated zip or complete garbage.\n            // A \"LOCAL_FILE_HEADER\" is not required at the beginning (auto\n            // extractible zip for example) but it can give a good hint.\n            // If an ajax request was used without responseType, we will also\n            // get unreadable data.\n            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);\n            if (isGarbage) {\n                throw new Error(\"Can't find end of central directory : is this a zip file ? \" + \"If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html\");\n            } else {\n                throw new Error(\"Corrupted zip: can't find end of central directory\");\n            }\n        }\n        this.reader.setIndex(offset);\n        var endOfCentralDirOffset = offset;\n        this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n        this.readBlockEndOfCentral();\n        /* extract from the zip spec :\n            4)  If one of the fields in the end of central directory\n                record is too small to hold required data, the field\n                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the\n                ZIP64 format record should be created.\n            5)  The end of central directory record and the\n                Zip64 end of central directory locator record must\n                reside on the same disk when splitting or spanning\n                an archive.\n         */ if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n            this.zip64 = true;\n            /*\n            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from\n            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents\n            all numbers as 64-bit double precision IEEE 754 floating point numbers.\n            So, we have 53bits for integers and bitwise operations treat everything as 32bits.\n            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators\n            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5\n            */ // should look for a zip64 EOCD locator\n            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            if (offset < 0) {\n                throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");\n            }\n            this.reader.setIndex(offset);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            this.readBlockZip64EndOfCentralLocator();\n            // now the zip64 EOCD record\n            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {\n                // console.warn(\"ZIP64 end of central directory not where expected.\");\n                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n                    throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");\n                }\n            }\n            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n            this.readBlockZip64EndOfCentral();\n        }\n        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n        if (this.zip64) {\n            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator\n            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */  + this.zip64EndOfCentralSize;\n        }\n        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n        if (extraBytes > 0) {\n            // console.warn(extraBytes, \"extra bytes at beginning or within zipfile\");\n            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {\n            // The offsets seem wrong, but we have something at the specified offset.\n            // So… we keep it.\n            } else {\n                // the offset is wrong, update the \"zero\" of the reader\n                // this happens if data has been prepended (crx files for example)\n                this.reader.zero = extraBytes;\n            }\n        } else if (extraBytes < 0) {\n            throw new Error(\"Corrupted zip: missing \" + Math.abs(extraBytes) + \" bytes.\");\n        }\n    },\n    prepareReader: function(data) {\n        this.reader = readerFor(data);\n    },\n    /**\n     * Read a zip file and create ZipEntries.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.\n     */ load: function(data) {\n        this.prepareReader(data);\n        this.readEndOfCentral();\n        this.readCentralDir();\n        this.readLocalFiles();\n    }\n};\n// }}} end of ZipEntries\nmodule.exports = ZipEntries;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcEVudHJpZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZQyxtQkFBT0EsQ0FBQyw4RUFBb0I7QUFDNUMsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUMsd0RBQVM7QUFDN0IsSUFBSUUsTUFBTUYsbUJBQU9BLENBQUMsZ0VBQWE7QUFDL0IsSUFBSUcsV0FBV0gsbUJBQU9BLENBQUMsOERBQVk7QUFDbkMsSUFBSUksVUFBVUosbUJBQU9BLENBQUMsNERBQVc7QUFDakMsd0JBQXdCO0FBQ3hCOzs7O0NBSUMsR0FDRCxTQUFTSyxXQUFXQyxXQUFXO0lBQzNCLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUU7SUFDZixJQUFJLENBQUNELFdBQVcsR0FBR0E7QUFDdkI7QUFDQUQsV0FBV0csU0FBUyxHQUFHO0lBQ25COzs7O0tBSUMsR0FDREMsZ0JBQWdCLFNBQVNDLGlCQUFpQjtRQUN0QyxJQUFJLENBQUMsSUFBSSxDQUFDQyxNQUFNLENBQUNDLHFCQUFxQixDQUFDRixvQkFBb0I7WUFDdkQsSUFBSSxDQUFDQyxNQUFNLENBQUNFLEtBQUssSUFBSTtZQUNyQixJQUFJQyxZQUFZLElBQUksQ0FBQ0gsTUFBTSxDQUFDSSxVQUFVLENBQUM7WUFDdkMsTUFBTSxJQUFJQyxNQUFNLGdEQUFnRCxNQUFNZixNQUFNZ0IsTUFBTSxDQUFDSCxhQUFhLGdCQUFnQmIsTUFBTWdCLE1BQU0sQ0FBQ1AscUJBQXFCO1FBQ3RKO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEUSxhQUFhLFNBQVNDLFVBQVUsRUFBRVQsaUJBQWlCO1FBQy9DLElBQUlVLGVBQWUsSUFBSSxDQUFDVCxNQUFNLENBQUNFLEtBQUs7UUFDcEMsSUFBSSxDQUFDRixNQUFNLENBQUNVLFFBQVEsQ0FBQ0Y7UUFDckIsSUFBSUwsWUFBWSxJQUFJLENBQUNILE1BQU0sQ0FBQ0ksVUFBVSxDQUFDO1FBQ3ZDLElBQUlPLFNBQVNSLGNBQWNKO1FBQzNCLElB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LGdDQUFnQztZQUNyRUEsaUNBQWlDLEdBQUcsMkNBQTJDLE1BQUssSUFBSSxDQUFDckMscUJBQXFCO1FBQ2xIO1FBRUEsSUFBSXNDLGFBQWFOLHdCQUF3Qks7UUFFekMsSUFBSUMsYUFBYSxHQUFHO1lBQ2hCLDBFQUEwRTtZQUMxRSxJQUFJLElBQUksQ0FBQzVELFdBQVcsQ0FBQ3NELHVCQUF1QnRFLElBQUk2RCxtQkFBbUIsR0FBRztZQUNsRSx5RUFBeUU7WUFDekUsa0JBQWtCO1lBQ3RCLE9BQU87Z0JBQ0gsdURBQXVEO2dCQUN2RCxrRUFBa0U7Z0JBQ2xFLElBQUksQ0FBQ3BELE1BQU0sQ0FBQ29FLElBQUksR0FBR0Q7WUFDdkI7UUFDSixPQUFPLElBQUlBLGFBQWEsR0FBRztZQUN2QixNQUFNLElBQUk5RCxNQUFNLDRCQUE0QmdFLEtBQUtDLEdBQUcsQ0FBQ0gsY0FBYztRQUN2RTtJQUNKO0lBQ0FJLGVBQWUsU0FBU0MsSUFBSTtRQUN4QixJQUFJLENBQUN4RSxNQUFNLEdBQUdaLFVBQVVvRjtJQUM1QjtJQUNBOzs7S0FHQyxHQUNEQyxNQUFNLFNBQVNELElBQUk7UUFDZixJQUFJLENBQUNELGFBQWEsQ0FBQ0M7UUFDbkIsSUFBSSxDQUFDaEIsZ0JBQWdCO1FBQ3JCLElBQUksQ0FBQ0wsY0FBYztRQUNuQixJQUFJLENBQUNSLGNBQWM7SUFDdkI7QUFDSjtBQUNBLHdCQUF3QjtBQUN4QitCLE9BQU9DLE9BQU8sR0FBR2pGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1vcHRpbWl6ZXIvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcEVudHJpZXMuanM/YWVlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciByZWFkZXJGb3IgPSByZXF1aXJlKFwiLi9yZWFkZXIvcmVhZGVyRm9yXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgc2lnID0gcmVxdWlyZShcIi4vc2lnbmF0dXJlXCIpO1xudmFyIFppcEVudHJ5ID0gcmVxdWlyZShcIi4vemlwRW50cnlcIik7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoXCIuL3N1cHBvcnRcIik7XG4vLyAgY2xhc3MgWmlwRW50cmllcyB7e3tcbi8qKlxuICogQWxsIHRoZSBlbnRyaWVzIGluIHRoZSB6aXAgZmlsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IGxvYWRPcHRpb25zIE9wdGlvbnMgZm9yIGxvYWRpbmcgdGhlIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gWmlwRW50cmllcyhsb2FkT3B0aW9ucykge1xuICAgIHRoaXMuZmlsZXMgPSBbXTtcbiAgICB0aGlzLmxvYWRPcHRpb25zID0gbG9hZE9wdGlvbnM7XG59XG5aaXBFbnRyaWVzLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSByZWFkZXIgaXMgb24gdGhlIHNwZWNpZmllZCBzaWduYXR1cmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkU2lnbmF0dXJlIHRoZSBleHBlY3RlZCBzaWduYXR1cmUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGlzIGFuIG90aGVyIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBjaGVja1NpZ25hdHVyZTogZnVuY3Rpb24oZXhwZWN0ZWRTaWduYXR1cmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmUoZXhwZWN0ZWRTaWduYXR1cmUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5pbmRleCAtPSA0O1xuICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoNCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIG9yIGJ1ZzogdW5leHBlY3RlZCBzaWduYXR1cmUgXCIgKyBcIihcIiArIHV0aWxzLnByZXR0eShzaWduYXR1cmUpICsgXCIsIGV4cGVjdGVkIFwiICsgdXRpbHMucHJldHR5KGV4cGVjdGVkU2lnbmF0dXJlKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIHNpZ25hdHVyZSBpcyBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFza2VkSW5kZXggdGhlIGluZGV4IHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIHRvIGV4cGVjdC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgaGVyZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzU2lnbmF0dXJlOiBmdW5jdGlvbihhc2tlZEluZGV4LCBleHBlY3RlZFNpZ25hdHVyZSkge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5yZWFkZXIuaW5kZXg7XG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KGFza2VkSW5kZXgpO1xuICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNpZ25hdHVyZSA9PT0gZXhwZWN0ZWRTaWduYXR1cmU7XG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KGN1cnJlbnRJbmRleCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRCbG9ja0VuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlza051bWJlciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHMgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcblxuICAgICAgICB0aGlzLnppcENvbW1lbnRMZW5ndGggPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAvLyB3YXJuaW5nIDogdGhlIGVuY29kaW5nIGRlcGVuZHMgb2YgdGhlIHN5c3RlbSBsb2NhbGVcbiAgICAgICAgLy8gT24gYSBsaW51eCBtYWNoaW5lIHdpdGggTEFORz1lbl9VUy51dGY4LCB0aGlzIGZpZWxkIGlzIHV0ZjggZW5jb2RlZC5cbiAgICAgICAgLy8gT24gYSB3aW5kb3dzIG1hY2hpbmUsIHRoaXMgZmllbGQgaXMgZW5jb2RlZCB3aXRoIHRoZSBsb2NhbGl6ZWQgd2luZG93cyBjb2RlIHBhZ2UuXG4gICAgICAgIHZhciB6aXBDb21tZW50ID0gdGhpcy5yZWFkZXIucmVhZERhdGEodGhpcy56aXBDb21tZW50TGVuZ3RoKTtcbiAgICAgICAgdmFyIGRlY29kZVBhcmFtVHlwZSA9IHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuICAgICAgICAvLyBUbyBnZXQgY29uc2lzdGVudCBiZWhhdmlvciB3aXRoIHRoZSBnZW5lcmF0aW9uIHBhcnQsIHdlIHdpbGwgYXNzdW1lIHRoYXRcbiAgICAgICAgLy8gdGhpcyBpcyB1dGY4IGVuY29kZWQgdW5sZXNzIHNwZWNpZmllZCBvdGhlcndpc2UuXG4gICAgICAgIHZhciBkZWNvZGVDb250ZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oZGVjb2RlUGFyYW1UeXBlLCB6aXBDb21tZW50KTtcbiAgICAgICAgdGhpcy56aXBDb21tZW50ID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShkZWNvZGVDb250ZW50KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgWmlwIDY0IGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqIE5vdCBtZXJnZWQgd2l0aCB0aGUgbWV0aG9kIHJlYWRFbmRPZkNlbnRyYWwgOlxuICAgICAqIFRoZSBlbmQgb2YgY2VudHJhbCBjYW4gY29leGlzdCB3aXRoIGl0cyBaaXA2NCBicm90aGVyLFxuICAgICAqIEkgZG9uJ3Qgd2FudCB0byByZWFkIHRoZSB3cm9uZyBudW1iZXIgb2YgYnl0ZXMgIVxuICAgICAqL1xuICAgIHJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLnJlYWRlci5za2lwKDQpO1xuICAgICAgICAvLyB0aGlzLnZlcnNpb25NYWRlQnkgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDIpO1xuICAgICAgICAvLyB0aGlzLnZlcnNpb25OZWVkZWQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpck9mZnNldCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG5cbiAgICAgICAgdGhpcy56aXA2NEV4dGVuc2libGVEYXRhID0ge307XG4gICAgICAgIHZhciBleHRyYURhdGFTaXplID0gdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemUgLSA0NCxcbiAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWU7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGV4dHJhRGF0YVNpemUpIHtcbiAgICAgICAgICAgIGV4dHJhRmllbGRJZCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZSA9IHRoaXMucmVhZGVyLnJlYWREYXRhKGV4dHJhRmllbGRMZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy56aXA2NEV4dGVuc2libGVEYXRhW2V4dHJhRmllbGRJZF0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4dHJhRmllbGRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBaaXAgNjQgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvci5cbiAgICAgKi9cbiAgICByZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc2tXaXRoWmlwNjRDZW50cmFsRGlyU3RhcnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmRpc2tzQ291bnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICBpZiAodGhpcy5kaXNrc0NvdW50ID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGktdm9sdW1lcyB6aXAgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGxvY2FsIGZpbGVzLCBiYXNlZCBvbiB0aGUgb2Zmc2V0IHJlYWQgaW4gdGhlIGNlbnRyYWwgcGFydC5cbiAgICAgKi9cbiAgICByZWFkTG9jYWxGaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpLCBmaWxlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5maWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbaV07XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChmaWxlLmxvY2FsSGVhZGVyT2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLkxPQ0FMX0ZJTEVfSEVBREVSKTtcbiAgICAgICAgICAgIGZpbGUucmVhZExvY2FsUGFydCh0aGlzLnJlYWRlcik7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZVVURjgoKTtcbiAgICAgICAgICAgIGZpbGUucHJvY2Vzc0F0dHJpYnV0ZXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgcmVhZENlbnRyYWxEaXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZmlsZTtcblxuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleCh0aGlzLmNlbnRyYWxEaXJPZmZzZXQpO1xuICAgICAgICB3aGlsZSAodGhpcy5yZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0ZJTEVfSEVBREVSKSkge1xuICAgICAgICAgICAgZmlsZSA9IG5ldyBaaXBFbnRyeSh7XG4gICAgICAgICAgICAgICAgemlwNjQ6IHRoaXMuemlwNjRcbiAgICAgICAgICAgIH0sIHRoaXMubG9hZE9wdGlvbnMpO1xuICAgICAgICAgICAgZmlsZS5yZWFkQ2VudHJhbFBhcnQodGhpcy5yZWFkZXIpO1xuICAgICAgICAgICAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2VudHJhbERpclJlY29yZHMgIT09IHRoaXMuZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jZW50cmFsRGlyUmVjb3JkcyAhPT0gMCAmJiB0aGlzLmZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGV4cGVjdGVkIHNvbWUgcmVjb3JkcyBidXQgY291bGRuJ3QgZmluZCBBTlkuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyByZWFsbHkgc3VzcGljaW91cywgYXMgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCBvciBidWc6IGV4cGVjdGVkIFwiICsgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyArIFwiIHJlY29yZHMgaW4gY2VudHJhbCBkaXIsIGdvdCBcIiArIHRoaXMuZmlsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgc29tZSByZWNvcmRzIGJ1dCBub3QgYWxsLlxuICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyBpcyB3cm9uZyBidXQgd2UgZ290IHNvbWV0aGluZyBmb3IgdGhlIHVzZXI6IG5vIGVycm9yIGhlcmUuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwiZXhwZWN0ZWRcIiwgdGhpcy5jZW50cmFsRGlyUmVjb3JkcywgXCJyZWNvcmRzIGluIGNlbnRyYWwgZGlyLCBnb3RcIiwgdGhpcy5maWxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgcmVhZEVuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZW50IGlzIGEgdHJ1bmNhdGVkIHppcCBvciBjb21wbGV0ZSBnYXJiYWdlLlxuICAgICAgICAgICAgLy8gQSBcIkxPQ0FMX0ZJTEVfSEVBREVSXCIgaXMgbm90IHJlcXVpcmVkIGF0IHRoZSBiZWdpbm5pbmcgKGF1dG9cbiAgICAgICAgICAgIC8vIGV4dHJhY3RpYmxlIHppcCBmb3IgZXhhbXBsZSkgYnV0IGl0IGNhbiBnaXZlIGEgZ29vZCBoaW50LlxuICAgICAgICAgICAgLy8gSWYgYW4gYWpheCByZXF1ZXN0IHdhcyB1c2VkIHdpdGhvdXQgcmVzcG9uc2VUeXBlLCB3ZSB3aWxsIGFsc29cbiAgICAgICAgICAgIC8vIGdldCB1bnJlYWRhYmxlIGRhdGEuXG4gICAgICAgICAgICB2YXIgaXNHYXJiYWdlID0gIXRoaXMuaXNTaWduYXR1cmUoMCwgc2lnLkxPQ0FMX0ZJTEVfSEVBREVSKTtcblxuICAgICAgICAgICAgaWYgKGlzR2FyYmFnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IDogaXMgdGhpcyBhIHppcCBmaWxlID8gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIklmIGl0IGlzLCBzZWUgaHR0cHM6Ly9zdHVrLmdpdGh1Yi5pby9qc3ppcC9kb2N1bWVudGF0aW9uL2hvd3RvL3JlYWRfemlwLmh0bWxcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IGNhbid0IGZpbmQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgob2Zmc2V0KTtcbiAgICAgICAgdmFyIGVuZE9mQ2VudHJhbERpck9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgdGhpcy5yZWFkQmxvY2tFbmRPZkNlbnRyYWwoKTtcblxuXG4gICAgICAgIC8qIGV4dHJhY3QgZnJvbSB0aGUgemlwIHNwZWMgOlxuICAgICAgICAgICAgNCkgIElmIG9uZSBvZiB0aGUgZmllbGRzIGluIHRoZSBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgICAgICAgICByZWNvcmQgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVxdWlyZWQgZGF0YSwgdGhlIGZpZWxkXG4gICAgICAgICAgICAgICAgc2hvdWxkIGJlIHNldCB0byAtMSAoMHhGRkZGIG9yIDB4RkZGRkZGRkYpIGFuZCB0aGVcbiAgICAgICAgICAgICAgICBaSVA2NCBmb3JtYXQgcmVjb3JkIHNob3VsZCBiZSBjcmVhdGVkLlxuICAgICAgICAgICAgNSkgIFRoZSBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3JkIGFuZCB0aGVcbiAgICAgICAgICAgICAgICBaaXA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvciByZWNvcmQgbXVzdFxuICAgICAgICAgICAgICAgIHJlc2lkZSBvbiB0aGUgc2FtZSBkaXNrIHdoZW4gc3BsaXR0aW5nIG9yIHNwYW5uaW5nXG4gICAgICAgICAgICAgICAgYW4gYXJjaGl2ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmRpc2tOdW1iZXIgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclNpemUgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyT2Zmc2V0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLnppcDY0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIFdhcm5pbmcgOiB0aGUgemlwNjQgZXh0ZW5zaW9uIGlzIHN1cHBvcnRlZCwgYnV0IE9OTFkgaWYgdGhlIDY0Yml0cyBpbnRlZ2VyIHJlYWQgZnJvbVxuICAgICAgICAgICAgdGhlIHppcCBmaWxlIGNhbiBmaXQgaW50byBhIDMyYml0cyBpbnRlZ2VyLiBUaGlzIGNhbm5vdCBiZSBzb2x2ZWQgOiBKYXZhU2NyaXB0IHJlcHJlc2VudHNcbiAgICAgICAgICAgIGFsbCBudW1iZXJzIGFzIDY0LWJpdCBkb3VibGUgcHJlY2lzaW9uIElFRUUgNzU0IGZsb2F0aW5nIHBvaW50IG51bWJlcnMuXG4gICAgICAgICAgICBTbywgd2UgaGF2ZSA1M2JpdHMgZm9yIGludGVnZXJzIGFuZCBiaXR3aXNlIG9wZXJhdGlvbnMgdHJlYXQgZXZlcnl0aGluZyBhcyAzMmJpdHMuXG4gICAgICAgICAgICBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvQml0d2lzZV9PcGVyYXRvcnNcbiAgICAgICAgICAgIGFuZCBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvcHVibGljYXRpb25zL2ZpbGVzL0VDTUEtU1QvRUNNQS0yNjIucGRmIHNlY3Rpb24gOC41XG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvLyBzaG91bGQgbG9vayBmb3IgYSB6aXA2NCBFT0NEIGxvY2F0b3JcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SKTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCB0aGUgWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3JcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUik7XG4gICAgICAgICAgICB0aGlzLnJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvcigpO1xuXG4gICAgICAgICAgICAvLyBub3cgdGhlIHppcDY0IEVPQ0QgcmVjb3JkXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNTaWduYXR1cmUodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyLCBzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcIlpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBub3Qgd2hlcmUgZXhwZWN0ZWQuXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA9IHRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IGNhbid0IGZpbmQgdGhlIFpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleCh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgICAgIHRoaXMucmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCA9IHRoaXMuY2VudHJhbERpck9mZnNldCArIHRoaXMuY2VudHJhbERpclNpemU7XG4gICAgICAgIGlmICh0aGlzLnppcDY0KSB7XG4gICAgICAgICAgICBleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCArPSAyMDsgLy8gZW5kIG9mIGNlbnRyYWwgZGlyIDY0IGxvY2F0b3JcbiAgICAgICAgICAgIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ICs9IDEyIC8qIHNob3VsZCBub3QgaW5jbHVkZSB0aGUgbGVhZGluZyAxMiBieXRlcyAqLyArIHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4dHJhQnl0ZXMgPSBlbmRPZkNlbnRyYWxEaXJPZmZzZXQgLSBleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldDtcblxuICAgICAgICBpZiAoZXh0cmFCeXRlcyA+IDApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihleHRyYUJ5dGVzLCBcImV4dHJhIGJ5dGVzIGF0IGJlZ2lubmluZyBvciB3aXRoaW4gemlwZmlsZVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU2lnbmF0dXJlKGVuZE9mQ2VudHJhbERpck9mZnNldCwgc2lnLkNFTlRSQUxfRklMRV9IRUFERVIpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9mZnNldHMgc2VlbSB3cm9uZywgYnV0IHdlIGhhdmUgc29tZXRoaW5nIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0LlxuICAgICAgICAgICAgICAgIC8vIFNv4oCmIHdlIGtlZXAgaXQuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBvZmZzZXQgaXMgd3JvbmcsIHVwZGF0ZSB0aGUgXCJ6ZXJvXCIgb2YgdGhlIHJlYWRlclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBpZiBkYXRhIGhhcyBiZWVuIHByZXBlbmRlZCAoY3J4IGZpbGVzIGZvciBleGFtcGxlKVxuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVyLnplcm8gPSBleHRyYUJ5dGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBtaXNzaW5nIFwiICsgTWF0aC5hYnMoZXh0cmFCeXRlcykgKyBcIiBieXRlcy5cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHByZXBhcmVSZWFkZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZWFkZXIgPSByZWFkZXJGb3IoZGF0YSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIGEgemlwIGZpbGUgYW5kIGNyZWF0ZSBaaXBFbnRyaWVzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBiaW5hcnkgc3RyaW5nIHJlcHJlc2VudGluZyBhIHppcCBmaWxlLlxuICAgICAqL1xuICAgIGxvYWQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlUmVhZGVyKGRhdGEpO1xuICAgICAgICB0aGlzLnJlYWRFbmRPZkNlbnRyYWwoKTtcbiAgICAgICAgdGhpcy5yZWFkQ2VudHJhbERpcigpO1xuICAgICAgICB0aGlzLnJlYWRMb2NhbEZpbGVzKCk7XG4gICAgfVxufTtcbi8vIH19fSBlbmQgb2YgWmlwRW50cmllc1xubW9kdWxlLmV4cG9ydHMgPSBaaXBFbnRyaWVzO1xuIl0sIm5hbWVzIjpbInJlYWRlckZvciIsInJlcXVpcmUiLCJ1dGlscyIsInNpZyIsIlppcEVudHJ5Iiwic3VwcG9ydCIsIlppcEVudHJpZXMiLCJsb2FkT3B0aW9ucyIsImZpbGVzIiwicHJvdG90eXBlIiwiY2hlY2tTaWduYXR1cmUiLCJleHBlY3RlZFNpZ25hdHVyZSIsInJlYWRlciIsInJlYWRBbmRDaGVja1NpZ25hdHVyZSIsImluZGV4Iiwic2lnbmF0dXJlIiwicmVhZFN0cmluZyIsIkVycm9yIiwicHJldHR5IiwiaXNTaWduYXR1cmUiLCJhc2tlZEluZGV4IiwiY3VycmVudEluZGV4Iiwic2V0SW5kZXgiLCJyZXN1bHQiLCJyZWFkQmxvY2tFbmRPZkNlbnRyYWwiLCJkaXNrTnVtYmVyIiwicmVhZEludCIsImRpc2tXaXRoQ2VudHJhbERpclN0YXJ0IiwiY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrIiwiY2VudHJhbERpclJlY29yZHMiLCJjZW50cmFsRGlyU2l6ZSIsImNlbnRyYWxEaXJPZmZzZXQiLCJ6aXBDb21tZW50TGVuZ3RoIiwiemlwQ29tbWVudCIsInJlYWREYXRhIiwiZGVjb2RlUGFyYW1UeXBlIiwidWludDhhcnJheSIsImRlY29kZUNvbnRlbnQiLCJ0cmFuc2Zvcm1UbyIsImRlY29kZUZpbGVOYW1lIiwicmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWwiLCJ6aXA2NEVuZE9mQ2VudHJhbFNpemUiLCJza2lwIiwiemlwNjRFeHRlbnNpYmxlRGF0YSIsImV4dHJhRGF0YVNpemUiLCJleHRyYUZpZWxkSWQiLCJleHRyYUZpZWxkTGVuZ3RoIiwiZXh0cmFGaWVsZFZhbHVlIiwiaWQiLCJsZW5ndGgiLCJ2YWx1ZSIsInJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvciIsImRpc2tXaXRoWmlwNjRDZW50cmFsRGlyU3RhcnQiLCJyZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyIiwiZGlza3NDb3VudCIsInJlYWRMb2NhbEZpbGVzIiwiaSIsImZpbGUiLCJsb2NhbEhlYWRlck9mZnNldCIsIkxPQ0FMX0ZJTEVfSEVBREVSIiwicmVhZExvY2FsUGFydCIsImhhbmRsZVVURjgiLCJwcm9jZXNzQXR0cmlidXRlcyIsInJlYWRDZW50cmFsRGlyIiwiQ0VOVFJBTF9GSUxFX0hFQURFUiIsInppcDY0IiwicmVhZENlbnRyYWxQYXJ0IiwicHVzaCIsInJlYWRFbmRPZkNlbnRyYWwiLCJvZmZzZXQiLCJsYXN0SW5kZXhPZlNpZ25hdHVyZSIsIkNFTlRSQUxfRElSRUNUT1JZX0VORCIsImlzR2FyYmFnZSIsImVuZE9mQ2VudHJhbERpck9mZnNldCIsIk1BWF9WQUxVRV8xNkJJVFMiLCJNQVhfVkFMVUVfMzJCSVRTIiwiWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiIsIlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCIsImV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0IiwiZXh0cmFCeXRlcyIsInplcm8iLCJNYXRoIiwiYWJzIiwicHJlcGFyZVJlYWRlciIsImRhdGEiLCJsb2FkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/zipEntries.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/zipEntry.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/zipEntry.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar readerFor = __webpack_require__(/*! ./reader/readerFor */ \"(ssr)/./node_modules/jszip/lib/reader/readerFor.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"(ssr)/./node_modules/jszip/lib/compressedObject.js\");\nvar crc32fn = __webpack_require__(/*! ./crc32 */ \"(ssr)/./node_modules/jszip/lib/crc32.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"(ssr)/./node_modules/jszip/lib/utf8.js\");\nvar compressions = __webpack_require__(/*! ./compressions */ \"(ssr)/./node_modules/jszip/lib/compressions.js\");\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\nvar MADE_BY_DOS = 0x00;\nvar MADE_BY_UNIX = 0x03;\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */ var findCompression = function(compressionMethod) {\n    for(var method in compressions){\n        if (!Object.prototype.hasOwnProperty.call(compressions, method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n// class ZipEntry {{{\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */ function ZipEntry(options, loadOptions) {\n    this.options = options;\n    this.loadOptions = loadOptions;\n}\nZipEntry.prototype = {\n    /**\n     * say if the file is encrypted.\n     * @return {boolean} true if the file is encrypted, false otherwise.\n     */ isEncrypted: function() {\n        // bit 1 is set\n        return (this.bitFlag & 0x0001) === 0x0001;\n    },\n    /**\n     * say if the file has utf-8 filename/comment.\n     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n     */ useUTF8: function() {\n        // bit 11 is set\n        return (this.bitFlag & 0x0800) === 0x0800;\n    },\n    /**\n     * Read the local part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */ readLocalPart: function(reader) {\n        var compression, localExtraFieldsLength;\n        // we already know everything from the central dir !\n        // If the central dir data are false, we are doomed.\n        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n        // The less data we get here, the more reliable this should be.\n        // Let's skip the whole header and dash to the data !\n        reader.skip(22);\n        // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n        // Strangely, the filename here is OK.\n        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n        // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n        // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n        // the internet.\n        //\n        // I think I see the logic here : the central directory is used to display\n        // content and the local directory is used to extract the files. Mixing / and \\\n        // may be used to display \\ to windows users and use / when extracting the files.\n        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n        this.fileNameLength = reader.readInt(2);\n        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.\n        this.fileName = reader.readData(this.fileNameLength);\n        reader.skip(localExtraFieldsLength);\n        if (this.compressedSize === -1 || this.uncompressedSize === -1) {\n            throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory \" + \"(compressedSize === -1 || uncompressedSize === -1)\");\n        }\n        compression = findCompression(this.compressionMethod);\n        if (compression === null) {\n            throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + utils.transformTo(\"string\", this.fileName) + \")\");\n        }\n        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */ readCentralPart: function(reader) {\n        this.versionMadeBy = reader.readInt(2);\n        reader.skip(2);\n        // this.versionNeeded = reader.readInt(2);\n        this.bitFlag = reader.readInt(2);\n        this.compressionMethod = reader.readString(2);\n        this.date = reader.readDate();\n        this.crc32 = reader.readInt(4);\n        this.compressedSize = reader.readInt(4);\n        this.uncompressedSize = reader.readInt(4);\n        var fileNameLength = reader.readInt(2);\n        this.extraFieldsLength = reader.readInt(2);\n        this.fileCommentLength = reader.readInt(2);\n        this.diskNumberStart = reader.readInt(2);\n        this.internalFileAttributes = reader.readInt(2);\n        this.externalFileAttributes = reader.readInt(4);\n        this.localHeaderOffset = reader.readInt(4);\n        if (this.isEncrypted()) {\n            throw new Error(\"Encrypted zip are not supported\");\n        }\n        // will be read in the local part, see the comments there\n        reader.skip(fileNameLength);\n        this.readExtraFields(reader);\n        this.parseZIP64ExtraField(reader);\n        this.fileComment = reader.readData(this.fileCommentLength);\n    },\n    /**\n     * Parse the external file attributes and get the unix/dos permissions.\n     */ processAttributes: function() {\n        this.unixPermissions = null;\n        this.dosPermissions = null;\n        var madeBy = this.versionMadeBy >> 8;\n        // Check if we have the DOS directory flag set.\n        // We look for it in the DOS and UNIX permissions\n        // but some unknown platform could set it as a compatibility flag.\n        this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n        if (madeBy === MADE_BY_DOS) {\n            // first 6 bits (0 to 5)\n            this.dosPermissions = this.externalFileAttributes & 0x3F;\n        }\n        if (madeBy === MADE_BY_UNIX) {\n            this.unixPermissions = this.externalFileAttributes >> 16 & 0xFFFF;\n        // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n        }\n        // fail safe : if the name ends with a / it probably means a folder\n        if (!this.dir && this.fileNameStr.slice(-1) === \"/\") {\n            this.dir = true;\n        }\n    },\n    /**\n     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n     * @param {DataReader} reader the reader to use.\n     */ parseZIP64ExtraField: function() {\n        if (!this.extraFields[0x0001]) {\n            return;\n        }\n        // should be something, preparing the extra reader\n        var extraReader = readerFor(this.extraFields[0x0001].value);\n        // I really hope that these 64bits integer can fit in 32 bits integer, because js\n        // won't let us have more.\n        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n            this.uncompressedSize = extraReader.readInt(8);\n        }\n        if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n            this.compressedSize = extraReader.readInt(8);\n        }\n        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n            this.localHeaderOffset = extraReader.readInt(8);\n        }\n        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n            this.diskNumberStart = extraReader.readInt(4);\n        }\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */ readExtraFields: function(reader) {\n        var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;\n        if (!this.extraFields) {\n            this.extraFields = {};\n        }\n        while(reader.index + 4 < end){\n            extraFieldId = reader.readInt(2);\n            extraFieldLength = reader.readInt(2);\n            extraFieldValue = reader.readData(extraFieldLength);\n            this.extraFields[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n        reader.setIndex(end);\n    },\n    /**\n     * Apply an UTF8 transformation if needed.\n     */ handleUTF8: function() {\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        if (this.useUTF8()) {\n            this.fileNameStr = utf8.utf8decode(this.fileName);\n            this.fileCommentStr = utf8.utf8decode(this.fileComment);\n        } else {\n            var upath = this.findExtraFieldUnicodePath();\n            if (upath !== null) {\n                this.fileNameStr = upath;\n            } else {\n                // ASCII text or unsupported code page\n                var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);\n                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n            }\n            var ucomment = this.findExtraFieldUnicodeComment();\n            if (ucomment !== null) {\n                this.fileCommentStr = ucomment;\n            } else {\n                // ASCII text or unsupported code page\n                var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);\n                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n            }\n        }\n    },\n    /**\n     * Find the unicode path declared in the extra field, if any.\n     * @return {String} the unicode path, null otherwise.\n     */ findExtraFieldUnicodePath: function() {\n        var upathField = this.extraFields[0x7075];\n        if (upathField) {\n            var extraReader = readerFor(upathField.value);\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n            // the crc of the filename changed, this field is out of date.\n            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {\n                return null;\n            }\n            return utf8.utf8decode(extraReader.readData(upathField.length - 5));\n        }\n        return null;\n    },\n    /**\n     * Find the unicode comment declared in the extra field, if any.\n     * @return {String} the unicode comment, null otherwise.\n     */ findExtraFieldUnicodeComment: function() {\n        var ucommentField = this.extraFields[0x6375];\n        if (ucommentField) {\n            var extraReader = readerFor(ucommentField.value);\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n            // the crc of the comment changed, this field is out of date.\n            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {\n                return null;\n            }\n            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));\n        }\n        return null;\n    }\n};\nmodule.exports = ZipEntry;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcEVudHJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsWUFBWUMsbUJBQU9BLENBQUMsOEVBQW9CO0FBQzVDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLHdEQUFTO0FBQzdCLElBQUlFLG1CQUFtQkYsbUJBQU9BLENBQUMsOEVBQW9CO0FBQ25ELElBQUlHLFVBQVVILG1CQUFPQSxDQUFDLHdEQUFTO0FBQy9CLElBQUlJLE9BQU9KLG1CQUFPQSxDQUFDLHNEQUFRO0FBQzNCLElBQUlLLGVBQWVMLG1CQUFPQSxDQUFDLHNFQUFnQjtBQUMzQyxJQUFJTSxVQUFVTixtQkFBT0EsQ0FBQyw0REFBVztBQUVqQyxJQUFJTyxjQUFjO0FBQ2xCLElBQUlDLGVBQWU7QUFFbkI7Ozs7Q0FJQyxHQUNELElBQUlDLGtCQUFrQixTQUFTQyxpQkFBaUI7SUFDNUMsSUFBSyxJQUFJQyxVQUFVTixhQUFjO1FBQzdCLElBQUksQ0FBQ08sT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1YsY0FBY00sU0FBUztZQUM3RDtRQUNKO1FBQ0EsSUFBSU4sWUFBWSxDQUFDTSxPQUFPLENBQUNLLEtBQUssS0FBS04sbUJBQW1CO1lBQ2xELE9BQU9MLFlBQVksQ0FBQ00sT0FBTztRQUMvQjtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBRUEscUJBQXFCO0FBQ3JCOzs7OztDQUtDLEdBQ0QsU0FBU00sU0FBU0MsT0FBTyxFQUFFQyxXQUFXO0lBQ2xDLElBQUksQ0FBQ0QsT0FBTyxHQUFHQTtJQUNmLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtBQUN2QjtBQUNBRixTQUFTSixTQUFTLEdBQUc7SUFDakI7OztLQUdDLEdBQ0RPLGFBQWE7UUFDVCxlQUFlO1FBQ2YsT0FBTyxDQUFDLElBQUksQ0FBQ0MsT0FBTyxHQUFHLE1BQUssTUFBTztJQUN2QztJQUNBOzs7S0FHQyxHQUNEQyxTQUFTO1FBQ0wsZ0JBQWdCO1FBQ2hCLE9B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STtnQkFDbkQsT0FBTztZQUNYO1lBRUEsT0FBT3pCLEtBQUt1RSxVQUFVLENBQUNkLFlBQVk5QixRQUFRLENBQUNxRCxXQUFXZCxNQUFNLEdBQUc7UUFDcEU7UUFDQSxPQUFPO0lBQ1g7SUFFQTs7O0tBR0MsR0FDRFksOEJBQThCO1FBQzFCLElBQUlHLGdCQUFnQixJQUFJLENBQUN6QixXQUFXLENBQUMsT0FBTztRQUM1QyxJQUFJeUIsZUFBZTtZQUNmLElBQUl4QixjQUFjOUQsVUFBVXNGLGNBQWN2QixLQUFLO1lBRS9DLGdCQUFnQjtZQUNoQixJQUFJRCxZQUFZaEMsT0FBTyxDQUFDLE9BQU8sR0FBRztnQkFDOUIsT0FBTztZQUNYO1lBRUEsNkRBQTZEO1lBQzdELElBQUkxQixRQUFRLElBQUksQ0FBQ2lELFdBQVcsTUFBTVMsWUFBWWhDLE9BQU8sQ0FBQyxJQUFJO2dCQUN0RCxPQUFPO1lBQ1g7WUFFQSxPQUFPekIsS0FBS3VFLFVBQVUsQ0FBQ2QsWUFBWTlCLFFBQVEsQ0FBQ3NELGNBQWNmLE1BQU0sR0FBRztRQUN2RTtRQUNBLE9BQU87SUFDWDtBQUNKO0FBQ0FnQixPQUFPQyxPQUFPLEdBQUd0RSIsInNvdXJjZXMiOlsid2VicGFjazovL3BwdHgtb3B0aW1pemVyLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyeS5qcz8zMjQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHJlYWRlckZvciA9IHJlcXVpcmUoXCIuL3JlYWRlci9yZWFkZXJGb3JcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZShcIi4vY29tcHJlc3NlZE9iamVjdFwiKTtcbnZhciBjcmMzMmZuID0gcmVxdWlyZShcIi4vY3JjMzJcIik7XG52YXIgdXRmOCA9IHJlcXVpcmUoXCIuL3V0ZjhcIik7XG52YXIgY29tcHJlc3Npb25zID0gcmVxdWlyZShcIi4vY29tcHJlc3Npb25zXCIpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi9zdXBwb3J0XCIpO1xuXG52YXIgTUFERV9CWV9ET1MgPSAweDAwO1xudmFyIE1BREVfQllfVU5JWCA9IDB4MDM7XG5cbi8qKlxuICogRmluZCBhIGNvbXByZXNzaW9uIHJlZ2lzdGVyZWQgaW4gSlNaaXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcHJlc3Npb25NZXRob2QgdGhlIG1ldGhvZCBtYWdpYyB0byBmaW5kLlxuICogQHJldHVybiB7T2JqZWN0fG51bGx9IHRoZSBKU1ppcCBjb21wcmVzc2lvbiBvYmplY3QsIG51bGwgaWYgbm9uZSBmb3VuZC5cbiAqL1xudmFyIGZpbmRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uKGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgZm9yICh2YXIgbWV0aG9kIGluIGNvbXByZXNzaW9ucykge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb21wcmVzc2lvbnMsIG1ldGhvZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc2lvbnNbbWV0aG9kXS5tYWdpYyA9PT0gY29tcHJlc3Npb25NZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2lvbnNbbWV0aG9kXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIGNsYXNzIFppcEVudHJ5IHt7e1xuLyoqXG4gKiBBbiBlbnRyeSBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2YgdGhlIGN1cnJlbnQgZmlsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJ5KG9wdGlvbnMsIGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvYWRPcHRpb25zID0gbG9hZE9wdGlvbnM7XG59XG5aaXBFbnRyeS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzRW5jcnlwdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDEgaXMgc2V0XG4gICAgICAgIHJldHVybiAodGhpcy5iaXRGbGFnICYgMHgwMDAxKSA9PT0gMHgwMDAxO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGhhcyB1dGYtOCBmaWxlbmFtZS9jb21tZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGZpbGVuYW1lL2NvbW1lbnQgaXMgaW4gdXRmLTgsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB1c2VVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDExIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDgwMCkgPT09IDB4MDgwMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGxvY2FsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRMb2NhbFBhcnQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB2YXIgY29tcHJlc3Npb24sIGxvY2FsRXh0cmFGaWVsZHNMZW5ndGg7XG5cbiAgICAgICAgLy8gd2UgYWxyZWFkeSBrbm93IGV2ZXJ5dGhpbmcgZnJvbSB0aGUgY2VudHJhbCBkaXIgIVxuICAgICAgICAvLyBJZiB0aGUgY2VudHJhbCBkaXIgZGF0YSBhcmUgZmFsc2UsIHdlIGFyZSBkb29tZWQuXG4gICAgICAgIC8vIE9uIHRoZSBicmlnaHQgc2lkZSwgdGhlIGxvY2FsIHBhcnQgaXMgc2NhcnkgIDogemlwNjQsIGRhdGEgZGVzY3JpcHRvcnMsIGJvdGgsIGV0Yy5cbiAgICAgICAgLy8gVGhlIGxlc3MgZGF0YSB3ZSBnZXQgaGVyZSwgdGhlIG1vcmUgcmVsaWFibGUgdGhpcyBzaG91bGQgYmUuXG4gICAgICAgIC8vIExldCdzIHNraXAgdGhlIHdob2xlIGhlYWRlciBhbmQgZGFzaCB0byB0aGUgZGF0YSAhXG4gICAgICAgIHJlYWRlci5za2lwKDIyKTtcbiAgICAgICAgLy8gaW4gc29tZSB6aXAgY3JlYXRlZCBvbiB3aW5kb3dzLCB0aGUgZmlsZW5hbWUgc3RvcmVkIGluIHRoZSBjZW50cmFsIGRpciBjb250YWlucyBcXCBpbnN0ZWFkIG9mIC8uXG4gICAgICAgIC8vIFN0cmFuZ2VseSwgdGhlIGZpbGVuYW1lIGhlcmUgaXMgT0suXG4gICAgICAgIC8vIEkgd291bGQgbG92ZSB0byB0cmVhdCB0aGVzZSB6aXAgZmlsZXMgYXMgY29ycnVwdGVkIChzZWUgaHR0cDovL3d3dy5pbmZvLXppcC5vcmcvRkFRLmh0bWwjYmFja3NsYXNoZXNcbiAgICAgICAgLy8gb3IgQVBQTk9URSM0LjQuMTcuMSwgXCJBbGwgc2xhc2hlcyBNVVNUIGJlIGZvcndhcmQgc2xhc2hlcyAnLydcIikgYnV0IHRoZXJlIGFyZSBhIGxvdCBvZiBiYWQgemlwIGdlbmVyYXRvcnMuLi5cbiAgICAgICAgLy8gU2VhcmNoIFwidW56aXAgbWlzbWF0Y2hpbmcgXCJsb2NhbFwiIGZpbGVuYW1lIGNvbnRpbnVpbmcgd2l0aCBcImNlbnRyYWxcIiBmaWxlbmFtZSB2ZXJzaW9uXCIgb25cbiAgICAgICAgLy8gdGhlIGludGVybmV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJIHRoaW5rIEkgc2VlIHRoZSBsb2dpYyBoZXJlIDogdGhlIGNlbnRyYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZGlzcGxheVxuICAgICAgICAvLyBjb250ZW50IGFuZCB0aGUgbG9jYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZXh0cmFjdCB0aGUgZmlsZXMuIE1peGluZyAvIGFuZCBcXFxuICAgICAgICAvLyBtYXkgYmUgdXNlZCB0byBkaXNwbGF5IFxcIHRvIHdpbmRvd3MgdXNlcnMgYW5kIHVzZSAvIHdoZW4gZXh0cmFjdGluZyB0aGUgZmlsZXMuXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoaXMgbGVhZCBhbHNvIHRvIHNvbWUgaXNzdWVzIDogaHR0cDovL3NlY2xpc3RzLm9yZy9mdWxsZGlzY2xvc3VyZS8yMDA5L1NlcC8zOTRcbiAgICAgICAgdGhpcy5maWxlTmFtZUxlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7IC8vIGNhbid0IGJlIHN1cmUgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBjZW50cmFsIGRpclxuICAgICAgICAvLyB0aGUgZmlsZU5hbWUgaXMgc3RvcmVkIGFzIGJpbmFyeSBkYXRhLCB0aGUgaGFuZGxlVVRGOCBtZXRob2Qgd2lsbCB0YWtlIGNhcmUgb2YgdGhlIGVuY29kaW5nLlxuICAgICAgICB0aGlzLmZpbGVOYW1lID0gcmVhZGVyLnJlYWREYXRhKHRoaXMuZmlsZU5hbWVMZW5ndGgpO1xuICAgICAgICByZWFkZXIuc2tpcChsb2NhbEV4dHJhRmllbGRzTGVuZ3RoKTtcblxuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2VkU2l6ZSA9PT0gLTEgfHwgdGhpcy51bmNvbXByZXNzZWRTaXplID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIG9yIGNvcnJ1cHRlZCB6aXAgOiBkaWRuJ3QgZ2V0IGVub3VnaCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBcIiArIFwiKGNvbXByZXNzZWRTaXplID09PSAtMSB8fCB1bmNvbXByZXNzZWRTaXplID09PSAtMSlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wcmVzc2lvbiA9IGZpbmRDb21wcmVzc2lvbih0aGlzLmNvbXByZXNzaW9uTWV0aG9kKTtcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uID09PSBudWxsKSB7IC8vIG5vIGNvbXByZXNzaW9uIGZvdW5kXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogY29tcHJlc3Npb24gXCIgKyB1dGlscy5wcmV0dHkodGhpcy5jb21wcmVzc2lvbk1ldGhvZCkgKyBcIiB1bmtub3duIChpbm5lciBmaWxlIDogXCIgKyB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLmZpbGVOYW1lKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY29tcHJlc3NlZCA9IG5ldyBDb21wcmVzc2VkT2JqZWN0KHRoaXMuY29tcHJlc3NlZFNpemUsIHRoaXMudW5jb21wcmVzc2VkU2l6ZSwgdGhpcy5jcmMzMiwgY29tcHJlc3Npb24sIHJlYWRlci5yZWFkRGF0YSh0aGlzLmNvbXByZXNzZWRTaXplKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgcGFydCBvZiBhIHppcCBmaWxlIGFuZCBhZGQgdGhlIGluZm8gaW4gdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcmVhZENlbnRyYWxQYXJ0OiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uTWFkZUJ5ID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHJlYWRlci5za2lwKDIpO1xuICAgICAgICAvLyB0aGlzLnZlcnNpb25OZWVkZWQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5iaXRGbGFnID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb25NZXRob2QgPSByZWFkZXIucmVhZFN0cmluZygyKTtcbiAgICAgICAgdGhpcy5kYXRlID0gcmVhZGVyLnJlYWREYXRlKCk7XG4gICAgICAgIHRoaXMuY3JjMzIgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdmFyIGZpbGVOYW1lTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZXh0cmFGaWVsZHNMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5maWxlQ29tbWVudExlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXJTdGFydCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmludGVybmFsRmlsZUF0dHJpYnV0ZXMgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPSByZWFkZXIucmVhZEludCg0KTtcblxuICAgICAgICBpZiAodGhpcy5pc0VuY3J5cHRlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0ZWQgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2lsbCBiZSByZWFkIGluIHRoZSBsb2NhbCBwYXJ0LCBzZWUgdGhlIGNvbW1lbnRzIHRoZXJlXG4gICAgICAgIHJlYWRlci5za2lwKGZpbGVOYW1lTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5yZWFkRXh0cmFGaWVsZHMocmVhZGVyKTtcbiAgICAgICAgdGhpcy5wYXJzZVpJUDY0RXh0cmFGaWVsZChyZWFkZXIpO1xuICAgICAgICB0aGlzLmZpbGVDb21tZW50ID0gcmVhZGVyLnJlYWREYXRhKHRoaXMuZmlsZUNvbW1lbnRMZW5ndGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIGFuZCBnZXQgdGhlIHVuaXgvZG9zIHBlcm1pc3Npb25zLlxuICAgICAqL1xuICAgIHByb2Nlc3NBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG51bGw7XG4gICAgICAgIHZhciBtYWRlQnkgPSB0aGlzLnZlcnNpb25NYWRlQnkgPj4gODtcblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRoZSBET1MgZGlyZWN0b3J5IGZsYWcgc2V0LlxuICAgICAgICAvLyBXZSBsb29rIGZvciBpdCBpbiB0aGUgRE9TIGFuZCBVTklYIHBlcm1pc3Npb25zXG4gICAgICAgIC8vIGJ1dCBzb21lIHVua25vd24gcGxhdGZvcm0gY291bGQgc2V0IGl0IGFzIGEgY29tcGF0aWJpbGl0eSBmbGFnLlxuICAgICAgICB0aGlzLmRpciA9IHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyAmIDB4MDAxMCA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgICBpZihtYWRlQnkgPT09IE1BREVfQllfRE9TKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCA2IGJpdHMgKDAgdG8gNSlcbiAgICAgICAgICAgIHRoaXMuZG9zUGVybWlzc2lvbnMgPSB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgJiAweDNGO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobWFkZUJ5ID09PSBNQURFX0JZX1VOSVgpIHtcbiAgICAgICAgICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gKHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA+PiAxNikgJiAweEZGRkY7XG4gICAgICAgICAgICAvLyB0aGUgb2N0YWwgcGVybWlzc2lvbnMgYXJlIGluICh0aGlzLnVuaXhQZXJtaXNzaW9ucyAmIDB4MDFGRikudG9TdHJpbmcoOCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmYWlsIHNhZmUgOiBpZiB0aGUgbmFtZSBlbmRzIHdpdGggYSAvIGl0IHByb2JhYmx5IG1lYW5zIGEgZm9sZGVyXG4gICAgICAgIGlmICghdGhpcy5kaXIgJiYgdGhpcy5maWxlTmFtZVN0ci5zbGljZSgtMSkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICB0aGlzLmRpciA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIFpJUDY0IGV4dHJhIGZpZWxkIGFuZCBtZXJnZSB0aGUgaW5mbyBpbiB0aGUgY3VycmVudCBaaXBFbnRyeS5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICBwYXJzZVpJUDY0RXh0cmFGaWVsZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5leHRyYUZpZWxkc1sweDAwMDFdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaG91bGQgYmUgc29tZXRoaW5nLCBwcmVwYXJpbmcgdGhlIGV4dHJhIHJlYWRlclxuICAgICAgICB2YXIgZXh0cmFSZWFkZXIgPSByZWFkZXJGb3IodGhpcy5leHRyYUZpZWxkc1sweDAwMDFdLnZhbHVlKTtcblxuICAgICAgICAvLyBJIHJlYWxseSBob3BlIHRoYXQgdGhlc2UgNjRiaXRzIGludGVnZXIgY2FuIGZpdCBpbiAzMiBiaXRzIGludGVnZXIsIGJlY2F1c2UganNcbiAgICAgICAgLy8gd29uJ3QgbGV0IHVzIGhhdmUgbW9yZS5cbiAgICAgICAgaWYgKHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy51bmNvbXByZXNzZWRTaXplID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2VkU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2tOdW1iZXJTdGFydCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5kaXNrTnVtYmVyU3RhcnQgPSBleHRyYVJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRFeHRyYUZpZWxkczogZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIHZhciBlbmQgPSByZWFkZXIuaW5kZXggKyB0aGlzLmV4dHJhRmllbGRzTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZXh0cmFGaWVsZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0cmFGaWVsZHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChyZWFkZXIuaW5kZXggKyA0IDwgZW5kKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZSA9IHJlYWRlci5yZWFkRGF0YShleHRyYUZpZWxkTGVuZ3RoKTtcblxuICAgICAgICAgICAgdGhpcy5leHRyYUZpZWxkc1tleHRyYUZpZWxkSWRdID0ge1xuICAgICAgICAgICAgICAgIGlkOiBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRyYUZpZWxkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZWFkZXIuc2V0SW5kZXgoZW5kKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFwcGx5IGFuIFVURjggdHJhbnNmb3JtYXRpb24gaWYgbmVlZGVkLlxuICAgICAqL1xuICAgIGhhbmRsZVVURjg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVjb2RlUGFyYW1UeXBlID0gc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG4gICAgICAgIGlmICh0aGlzLnVzZVVURjgoKSkge1xuICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHV0ZjgudXRmOGRlY29kZSh0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB1dGY4LnV0ZjhkZWNvZGUodGhpcy5maWxlQ29tbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdXBhdGggPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGgoKTtcbiAgICAgICAgICAgIGlmICh1cGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB1cGF0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgdGV4dCBvciB1bnN1cHBvcnRlZCBjb2RlIHBhZ2VcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWVCeXRlQXJyYXkgPSAgdXRpbHMudHJhbnNmb3JtVG8oZGVjb2RlUGFyYW1UeXBlLCB0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShmaWxlTmFtZUJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1Y29tbWVudCA9IHRoaXMuZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudCgpO1xuICAgICAgICAgICAgaWYgKHVjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHVjb21tZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBU0NJSSB0ZXh0IG9yIHVuc3VwcG9ydGVkIGNvZGUgcGFnZVxuICAgICAgICAgICAgICAgIHZhciBjb21tZW50Qnl0ZUFycmF5ID0gIHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgdGhpcy5maWxlQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoY29tbWVudEJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgdW5pY29kZSBwYXRoIGRlY2xhcmVkIGluIHRoZSBleHRyYSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHVuaWNvZGUgcGF0aCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZEV4dHJhRmllbGRVbmljb2RlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cGF0aEZpZWxkID0gdGhpcy5leHRyYUZpZWxkc1sweDcwNzVdO1xuICAgICAgICBpZiAodXBhdGhGaWVsZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHVwYXRoRmllbGQudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyB3cm9uZyB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoZXh0cmFSZWFkZXIucmVhZEludCgxKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgY3JjIG9mIHRoZSBmaWxlbmFtZSBjaGFuZ2VkLCB0aGlzIGZpZWxkIGlzIG91dCBvZiBkYXRlLlxuICAgICAgICAgICAgaWYgKGNyYzMyZm4odGhpcy5maWxlTmFtZSkgIT09IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShleHRyYVJlYWRlci5yZWFkRGF0YSh1cGF0aEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgdW5pY29kZSBjb21tZW50IGRlY2xhcmVkIGluIHRoZSBleHRyYSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHVuaWNvZGUgY29tbWVudCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1Y29tbWVudEZpZWxkID0gdGhpcy5leHRyYUZpZWxkc1sweDYzNzVdO1xuICAgICAgICBpZiAodWNvbW1lbnRGaWVsZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHVjb21tZW50RmllbGQudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyB3cm9uZyB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoZXh0cmFSZWFkZXIucmVhZEludCgxKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgY3JjIG9mIHRoZSBjb21tZW50IGNoYW5nZWQsIHRoaXMgZmllbGQgaXMgb3V0IG9mIGRhdGUuXG4gICAgICAgICAgICBpZiAoY3JjMzJmbih0aGlzLmZpbGVDb21tZW50KSAhPT0gZXh0cmFSZWFkZXIucmVhZEludCg0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXRmOC51dGY4ZGVjb2RlKGV4dHJhUmVhZGVyLnJlYWREYXRhKHVjb21tZW50RmllbGQubGVuZ3RoIC0gNSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJ5O1xuIl0sIm5hbWVzIjpbInJlYWRlckZvciIsInJlcXVpcmUiLCJ1dGlscyIsIkNvbXByZXNzZWRPYmplY3QiLCJjcmMzMmZuIiwidXRmOCIsImNvbXByZXNzaW9ucyIsInN1cHBvcnQiLCJNQURFX0JZX0RPUyIsIk1BREVfQllfVU5JWCIsImZpbmRDb21wcmVzc2lvbiIsImNvbXByZXNzaW9uTWV0aG9kIiwibWV0aG9kIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibWFnaWMiLCJaaXBFbnRyeSIsIm9wdGlvbnMiLCJsb2FkT3B0aW9ucyIsImlzRW5jcnlwdGVkIiwiYml0RmxhZyIsInVzZVVURjgiLCJyZWFkTG9jYWxQYXJ0IiwicmVhZGVyIiwiY29tcHJlc3Npb24iLCJsb2NhbEV4dHJhRmllbGRzTGVuZ3RoIiwic2tpcCIsImZpbGVOYW1lTGVuZ3RoIiwicmVhZEludCIsImZpbGVOYW1lIiwicmVhZERhdGEiLCJjb21wcmVzc2VkU2l6ZSIsInVuY29tcHJlc3NlZFNpemUiLCJFcnJvciIsInByZXR0eSIsInRyYW5zZm9ybVRvIiwiZGVjb21wcmVzc2VkIiwiY3JjMzIiLCJyZWFkQ2VudHJhbFBhcnQiLCJ2ZXJzaW9uTWFkZUJ5IiwicmVhZFN0cmluZyIsImRhdGUiLCJyZWFkRGF0ZSIsImV4dHJhRmllbGRzTGVuZ3RoIiwiZmlsZUNvbW1lbnRMZW5ndGgiLCJkaXNrTnVtYmVyU3RhcnQiLCJpbnRlcm5hbEZpbGVBdHRyaWJ1dGVzIiwiZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyIsImxvY2FsSGVhZGVyT2Zmc2V0IiwicmVhZEV4dHJhRmllbGRzIiwicGFyc2VaSVA2NEV4dHJhRmllbGQiLCJmaWxlQ29tbWVudCIsInByb2Nlc3NBdHRyaWJ1dGVzIiwidW5peFBlcm1pc3Npb25zIiwiZG9zUGVybWlzc2lvbnMiLCJtYWRlQnkiLCJkaXIiLCJmaWxlTmFtZVN0ciIsInNsaWNlIiwiZXh0cmFGaWVsZHMiLCJleHRyYVJlYWRlciIsInZhbHVlIiwiTUFYX1ZBTFVFXzMyQklUUyIsImVuZCIsImluZGV4IiwiZXh0cmFGaWVsZElkIiwiZXh0cmFGaWVsZExlbmd0aCIsImV4dHJhRmllbGRWYWx1ZSIsImlkIiwibGVuZ3RoIiwic2V0SW5kZXgiLCJoYW5kbGVVVEY4IiwiZGVjb2RlUGFyYW1UeXBlIiwidWludDhhcnJheSIsInV0ZjhkZWNvZGUiLCJmaWxlQ29tbWVudFN0ciIsInVwYXRoIiwiZmluZEV4dHJhRmllbGRVbmljb2RlUGF0aCIsImZpbGVOYW1lQnl0ZUFycmF5IiwiZGVjb2RlRmlsZU5hbWUiLCJ1Y29tbWVudCIsImZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQiLCJjb21tZW50Qnl0ZUFycmF5IiwidXBhdGhGaWVsZCIsInVjb21tZW50RmllbGQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/zipEntry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/zipObject.js":
/*!*********************************************!*\
  !*** ./node_modules/jszip/lib/zipObject.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar StreamHelper = __webpack_require__(/*! ./stream/StreamHelper */ \"(ssr)/./node_modules/jszip/lib/stream/StreamHelper.js\");\nvar DataWorker = __webpack_require__(/*! ./stream/DataWorker */ \"(ssr)/./node_modules/jszip/lib/stream/DataWorker.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"(ssr)/./node_modules/jszip/lib/utf8.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"(ssr)/./node_modules/jszip/lib/compressedObject.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */ var ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n    this._data = data;\n    this._dataBinary = options.binary;\n    // keep only the compression\n    this.options = {\n        compression: options.compression,\n        compressionOptions: options.compressionOptions\n    };\n};\nZipObject.prototype = {\n    /**\n     * Create an internal stream for the content of this object.\n     * @param {String} type the type of each chunk.\n     * @return StreamHelper the stream.\n     */ internalStream: function(type) {\n        var result = null, outputType = \"string\";\n        try {\n            if (!type) {\n                throw new Error(\"No output type specified.\");\n            }\n            outputType = type.toLowerCase();\n            var askUnicodeString = outputType === \"string\" || outputType === \"text\";\n            if (outputType === \"binarystring\" || outputType === \"text\") {\n                outputType = \"string\";\n            }\n            result = this._decompressWorker();\n            var isUnicodeString = !this._dataBinary;\n            if (isUnicodeString && !askUnicodeString) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            if (!isUnicodeString && askUnicodeString) {\n                result = result.pipe(new utf8.Utf8DecodeWorker());\n            }\n        } catch (e) {\n            result = new GenericWorker(\"error\");\n            result.error(e);\n        }\n        return new StreamHelper(result, outputType, \"\");\n    },\n    /**\n     * Prepare the content in the asked type.\n     * @param {String} type the type of the result.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Promise the promise of the result.\n     */ async: function(type, onUpdate) {\n        return this.internalStream(type).accumulate(onUpdate);\n    },\n    /**\n     * Prepare the content as a nodejs stream.\n     * @param {String} type the type of each chunk.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Stream the stream.\n     */ nodeStream: function(type, onUpdate) {\n        return this.internalStream(type || \"nodebuffer\").toNodejsStream(onUpdate);\n    },\n    /**\n     * Return a worker for the compressed content.\n     * @private\n     * @param {Object} compression the compression object to use.\n     * @param {Object} compressionOptions the options to use when compressing.\n     * @return Worker the worker.\n     */ _compressWorker: function(compression, compressionOptions) {\n        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {\n            return this._data.getCompressedWorker();\n        } else {\n            var result = this._decompressWorker();\n            if (!this._dataBinary) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);\n        }\n    },\n    /**\n     * Return a worker for the decompressed content.\n     * @private\n     * @return Worker the worker.\n     */ _decompressWorker: function() {\n        if (this._data instanceof CompressedObject) {\n            return this._data.getContentWorker();\n        } else if (this._data instanceof GenericWorker) {\n            return this._data;\n        } else {\n            return new DataWorker(this._data);\n        }\n    }\n};\nvar removedMethods = [\n    \"asText\",\n    \"asBinary\",\n    \"asNodeBuffer\",\n    \"asUint8Array\",\n    \"asArrayBuffer\"\n];\nvar removedFn = function() {\n    throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n};\nfor(var i = 0; i < removedMethods.length; i++){\n    ZipObject.prototype[removedMethods[i]] = removedFn;\n}\nmodule.exports = ZipObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcE9iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLGVBQWVDLG1CQUFPQSxDQUFDLG9GQUF1QjtBQUNsRCxJQUFJQyxhQUFhRCxtQkFBT0EsQ0FBQyxnRkFBcUI7QUFDOUMsSUFBSUUsT0FBT0YsbUJBQU9BLENBQUMsc0RBQVE7QUFDM0IsSUFBSUcsbUJBQW1CSCxtQkFBT0EsQ0FBQyw4RUFBb0I7QUFDbkQsSUFBSUksZ0JBQWdCSixtQkFBT0EsQ0FBQyxzRkFBd0I7QUFFcEQ7Ozs7OztDQU1DLEdBQ0QsSUFBSUssWUFBWSxTQUFTQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsT0FBTztJQUN4QyxJQUFJLENBQUNGLElBQUksR0FBR0E7SUFDWixJQUFJLENBQUNHLEdBQUcsR0FBR0QsUUFBUUMsR0FBRztJQUN0QixJQUFJLENBQUNDLElBQUksR0FBR0YsUUFBUUUsSUFBSTtJQUN4QixJQUFJLENBQUNDLE9BQU8sR0FBR0gsUUFBUUcsT0FBTztJQUM5QixJQUFJLENBQUNDLGVBQWUsR0FBR0osUUFBUUksZUFBZTtJQUM5QyxJQUFJLENBQUNDLGNBQWMsR0FBR0wsUUFBUUssY0FBYztJQUU1QyxJQUFJLENBQUNDLEtBQUssR0FBR1A7SUFDYixJQUFJLENBQUNRLFdBQVcsR0FBR1AsUUFBUVEsTUFBTTtJQUNqQyw0QkFBNEI7SUFDNUIsSUFBSSxDQUFDUixPQUFPLEdBQUc7UUFDWFMsYUFBY1QsUUFBUVMsV0FBVztRQUNqQ0Msb0JBQXFCVixRQUFRVSxrQkFBa0I7SUFDbkQ7QUFDSjtBQUVBYixVQUFVYyxTQUFTLEdBQUc7SUFDbEI7Ozs7S0FJQyxHQUNEQyxnQkFBZ0IsU0FBVUMsSUFBSTtRQUMxQixJQUFJQyxTQUFTLE1BQU1DLGFBQWE7UUFDaEMsSUFBSTtZQUNBLElBQUksQ0FBQ0YsTUFBTTtnQkFDUCxNQUFNLElBQUlHLE1BQU07WUFDcEI7WUFDQUQsYUFBYUYsS0FBS0ksV0FBVztZQUM3QixJQUFJQyxtQkFBbUJILGVBQWUsWUFBWUEsZUFBZTtZQUNqRSxJQUFJQSxlQUFlLGtCQUFrQkEsZUFBZSxRQUFRO2dCQUN4REEsYUFBYTtZQUNqQjtZQUNBRCxTQUFTLElBQUksQ0FBQ0ssaUJBQWlCO1lBRS9CLElBQUlDLGtCQUFrQixDQUFDLElBQUksQ0FBQ2IsV0FBVztZQUV2QyxJQUFJYSxtQkFBbUIsQ0FBQ0Ysa0JBQWtCO2dCQUN0Q0osU0FBU0EsT0FBT08sSUFBSSxDQUFDLElBQUkzQixLQUFLNEIsZ0JBQWdCO1lBQ2xEO1lBQ0EsSUFBSSxDQUFDRixtQkFBbUJGLGtCQUFrQjtnQkFDdENKLFNBQVNBLE9BQU9PLElBQUksQ0FBQyxJQUFJM0IsS0FBSzZCLGdCQUFnQjtZQUNsRDtRQUNKLEVBQUUsT0FBT0MsR0FBRztZQUNSVixTQUFTLElBQUlsQixjQUFjO1lBQzNCa0IsT0FBT1csS0FBSyxDQUFDRDtRQUNqQjtRQUVBLE9BQU8sSUFBSWpDLGFBQWF1QixRQUFRQyxZQUFZO0lBQ2hEO0lBRUE7Ozs7O0tBS0MsR0FDRFcsT0FBTyxTQUFVYixJQUFJLEVBQUVjLFFBQVE7UUFDM0IsT0FBTyxJQUFJLENBQUNmLGNBQWMsQ0FBQ0MsTUFBTWUsVUFBVSxDQUFDRDtJQUNoRDtJQUVBOzs7OztLQUtDLEdBQ0RFLFlBQVksU0FBVWhCLElBQUksRUFBRWMsUUFBUTtRQUNoQyxPQUFPLElBQUksQ0FBQ2YsY0FBYyxDQUFDQyxRQUFRLGNBQWNpQixjQUFjLENBQUNIO0lBQ3BFO0lBRUE7Ozs7OztLQU1DLEdBQ0RJLGlCQUFpQixTQUFVdEIsV0FBVyxFQUFFQyxrQkFBa0I7UUFDdEQsSUFDSSxJQUFJLENBQUNKLEtBQUssWUFBWVgsb0JBQ3RCLElBQUksQ0FBQ1csS0FBSyxDQUFDRyxXQUFXLENBQUN1QixLQUFLLEtBQUt2QixZQUFZdUIsS0FBSyxFQUNwRDtZQUNFLE9BQU8sSUFBSSxDQUFDMUIsS0FBSyxDQUFDMkIsbUJBQW1CO1FBQ3pDLE9BQU87WUFDSCxJQUFJbkIsU0FBUyxJQUFJLENBQUNLLGlCQUFpQjtZQUNuQyxJQUFHLENBQUMsSUFBSSxDQUFDWixXQUFXLEVBQUU7Z0JBQ2xCTyxTQUFTQSxPQUFPTyxJQUFJLENBQUMsSUFBSTNCLEtBQUs0QixnQkFBZ0I7WUFDbEQ7WUFDQSxPQUFPM0IsaUJBQWlCdUMsZ0JBQWdCLENBQUNwQixRQUFRTCxhQUFhQztRQUNsRTtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNEUyxtQkFBb0I7UUFDaEIsSUFBSSxJQUFJLENBQUNiLEtBQUssWUFBWVgsa0JBQWtCO1lBQ3hDLE9BQU8sSUFBSSxDQUFDVyxLQUFLLENBQUM2QixnQkFBZ0I7UUFDdEMsT0FBTyxJQUFJLElBQUksQ0FBQzdCLEtBQUssWUFBWVYsZUFBZTtZQUM1QyxPQUFPLElBQUksQ0FBQ1UsS0FBSztRQUNyQixPQUFPO1lBQ0gsT0FBTyxJQUFJYixXQUFXLElBQUksQ0FBQ2EsS0FBSztRQUNwQztJQUNKO0FBQ0o7QUFFQSxJQUFJOEIsaUJBQWlCO0lBQUM7SUFBVTtJQUFZO0lBQWdCO0lBQWdCO0NBQWdCO0FBQzVGLElBQUlDLFlBQVk7SUFDWixNQUFNLElBQUlyQixNQUFNO0FBQ3BCO0FBRUEsSUFBSSxJQUFJc0IsSUFBSSxHQUFHQSxJQUFJRixlQUFlRyxNQUFNLEVBQUVELElBQUs7SUFDM0N6QyxVQUFVYyxTQUFTLENBQUN5QixjQUFjLENBQUNFLEVBQUUsQ0FBQyxHQUFHRDtBQUM3QztBQUNBRyxPQUFPQyxPQUFPLEdBQUc1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BwdHgtb3B0aW1pemVyLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBPYmplY3QuanM/NzE0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIFN0cmVhbUhlbHBlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9TdHJlYW1IZWxwZXJcIik7XG52YXIgRGF0YVdvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9EYXRhV29ya2VyXCIpO1xudmFyIHV0ZjggPSByZXF1aXJlKFwiLi91dGY4XCIpO1xudmFyIENvbXByZXNzZWRPYmplY3QgPSByZXF1aXJlKFwiLi9jb21wcmVzc2VkT2JqZWN0XCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxuLyoqXG4gKiBBIHNpbXBsZSBvYmplY3QgcmVwcmVzZW50aW5nIGEgZmlsZSBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgb2YgdGhlIGZpbGVcbiAqL1xudmFyIFppcE9iamVjdCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuZGlyID0gb3B0aW9ucy5kaXI7XG4gICAgdGhpcy5kYXRlID0gb3B0aW9ucy5kYXRlO1xuICAgIHRoaXMuY29tbWVudCA9IG9wdGlvbnMuY29tbWVudDtcbiAgICB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9IG9wdGlvbnMudW5peFBlcm1pc3Npb25zO1xuICAgIHRoaXMuZG9zUGVybWlzc2lvbnMgPSBvcHRpb25zLmRvc1Blcm1pc3Npb25zO1xuXG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5fZGF0YUJpbmFyeSA9IG9wdGlvbnMuYmluYXJ5O1xuICAgIC8vIGtlZXAgb25seSB0aGUgY29tcHJlc3Npb25cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIGNvbXByZXNzaW9uIDogb3B0aW9ucy5jb21wcmVzc2lvbixcbiAgICAgICAgY29tcHJlc3Npb25PcHRpb25zIDogb3B0aW9ucy5jb21wcmVzc2lvbk9wdGlvbnNcbiAgICB9O1xufTtcblxuWmlwT2JqZWN0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW50ZXJuYWwgc3RyZWFtIGZvciB0aGUgY29udGVudCBvZiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiBlYWNoIGNodW5rLlxuICAgICAqIEByZXR1cm4gU3RyZWFtSGVscGVyIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgaW50ZXJuYWxTdHJlYW06IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsLCBvdXRwdXRUeXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG91dHB1dCB0eXBlIHNwZWNpZmllZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRUeXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIGFza1VuaWNvZGVTdHJpbmcgPSBvdXRwdXRUeXBlID09PSBcInN0cmluZ1wiIHx8IG91dHB1dFR5cGUgPT09IFwidGV4dFwiO1xuICAgICAgICAgICAgaWYgKG91dHB1dFR5cGUgPT09IFwiYmluYXJ5c3RyaW5nXCIgfHwgb3V0cHV0VHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRUeXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29tcHJlc3NXb3JrZXIoKTtcblxuICAgICAgICAgICAgdmFyIGlzVW5pY29kZVN0cmluZyA9ICF0aGlzLl9kYXRhQmluYXJ5O1xuXG4gICAgICAgICAgICBpZiAoaXNVbmljb2RlU3RyaW5nICYmICFhc2tVbmljb2RlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOEVuY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNVbmljb2RlU3RyaW5nICYmIGFza1VuaWNvZGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShuZXcgdXRmOC5VdGY4RGVjb2RlV29ya2VyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1IZWxwZXIocmVzdWx0LCBvdXRwdXRUeXBlLCBcIlwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0aGUgY29udGVudCBpbiB0aGUgYXNrZWQgdHlwZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uVXBkYXRlIGEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGludGVybmFsIHVwZGF0ZS5cbiAgICAgKiBAcmV0dXJuIFByb21pc2UgdGhlIHByb21pc2Ugb2YgdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYzogZnVuY3Rpb24gKHR5cGUsIG9uVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU3RyZWFtKHR5cGUpLmFjY3VtdWxhdGUob25VcGRhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBjb250ZW50IGFzIGEgbm9kZWpzIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiBlYWNoIGNodW5rLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uVXBkYXRlIGEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGludGVybmFsIHVwZGF0ZS5cbiAgICAgKiBAcmV0dXJuIFN0cmVhbSB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIG5vZGVTdHJlYW06IGZ1bmN0aW9uICh0eXBlLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0cmVhbSh0eXBlIHx8IFwibm9kZWJ1ZmZlclwiKS50b05vZGVqc1N0cmVhbShvblVwZGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHdvcmtlciBmb3IgdGhlIGNvbXByZXNzZWQgY29udGVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gb2JqZWN0IHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb25PcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIGNvbXByZXNzaW5nLlxuICAgICAqIEByZXR1cm4gV29ya2VyIHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgX2NvbXByZXNzV29ya2VyOiBmdW5jdGlvbiAoY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLl9kYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCAmJlxuICAgICAgICAgICAgdGhpcy5fZGF0YS5jb21wcmVzc2lvbi5tYWdpYyA9PT0gY29tcHJlc3Npb24ubWFnaWNcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXRDb21wcmVzc2VkV29ya2VyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZGVjb21wcmVzc1dvcmtlcigpO1xuICAgICAgICAgICAgaWYoIXRoaXMuX2RhdGFCaW5hcnkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShuZXcgdXRmOC5VdGY4RW5jb2RlV29ya2VyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENvbXByZXNzZWRPYmplY3QuY3JlYXRlV29ya2VyRnJvbShyZXN1bHQsIGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB3b3JrZXIgZm9yIHRoZSBkZWNvbXByZXNzZWQgY29udGVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gV29ya2VyIHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgX2RlY29tcHJlc3NXb3JrZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0Q29udGVudFdvcmtlcigpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBHZW5lcmljV29ya2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YVdvcmtlcih0aGlzLl9kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciByZW1vdmVkTWV0aG9kcyA9IFtcImFzVGV4dFwiLCBcImFzQmluYXJ5XCIsIFwiYXNOb2RlQnVmZmVyXCIsIFwiYXNVaW50OEFycmF5XCIsIFwiYXNBcnJheUJ1ZmZlclwiXTtcbnZhciByZW1vdmVkRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2QgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS5cIik7XG59O1xuXG5mb3IodmFyIGkgPSAwOyBpIDwgcmVtb3ZlZE1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICBaaXBPYmplY3QucHJvdG90eXBlW3JlbW92ZWRNZXRob2RzW2ldXSA9IHJlbW92ZWRGbjtcbn1cbm1vZHVsZS5leHBvcnRzID0gWmlwT2JqZWN0O1xuIl0sIm5hbWVzIjpbIlN0cmVhbUhlbHBlciIsInJlcXVpcmUiLCJEYXRhV29ya2VyIiwidXRmOCIsIkNvbXByZXNzZWRPYmplY3QiLCJHZW5lcmljV29ya2VyIiwiWmlwT2JqZWN0IiwibmFtZSIsImRhdGEiLCJvcHRpb25zIiwiZGlyIiwiZGF0ZSIsImNvbW1lbnQiLCJ1bml4UGVybWlzc2lvbnMiLCJkb3NQZXJtaXNzaW9ucyIsIl9kYXRhIiwiX2RhdGFCaW5hcnkiLCJiaW5hcnkiLCJjb21wcmVzc2lvbiIsImNvbXByZXNzaW9uT3B0aW9ucyIsInByb3RvdHlwZSIsImludGVybmFsU3RyZWFtIiwidHlwZSIsInJlc3VsdCIsIm91dHB1dFR5cGUiLCJFcnJvciIsInRvTG93ZXJDYXNlIiwiYXNrVW5pY29kZVN0cmluZyIsIl9kZWNvbXByZXNzV29ya2VyIiwiaXNVbmljb2RlU3RyaW5nIiwicGlwZSIsIlV0ZjhFbmNvZGVXb3JrZXIiLCJVdGY4RGVjb2RlV29ya2VyIiwiZSIsImVycm9yIiwiYXN5bmMiLCJvblVwZGF0ZSIsImFjY3VtdWxhdGUiLCJub2RlU3RyZWFtIiwidG9Ob2RlanNTdHJlYW0iLCJfY29tcHJlc3NXb3JrZXIiLCJtYWdpYyIsImdldENvbXByZXNzZWRXb3JrZXIiLCJjcmVhdGVXb3JrZXJGcm9tIiwiZ2V0Q29udGVudFdvcmtlciIsInJlbW92ZWRNZXRob2RzIiwicmVtb3ZlZEZuIiwiaSIsImxlbmd0aCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/zipObject.js\n");

/***/ })

};
;